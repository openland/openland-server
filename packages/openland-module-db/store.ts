// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { Subspace, Watch, RangeOptions } from '@openland/foundationdb';
// @ts-ignore
import { EntityStorage, BaseStore, codecs as c } from '@openland/foundationdb-entity';
// @ts-ignore
import { AtomicIntegerFactory, AtomicBooleanFactory } from '@openland/foundationdb-entity';
// @ts-ignore
import { Entity, EntityFactory, EntityDescriptor, SecondaryIndexDescriptor, ShapeWithMetadata, PrimaryKeyDescriptor, FieldDescriptor, StreamProps } from '@openland/foundationdb-entity';

export class UserCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userCounter');
        return new UserCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentCounter');
        return new UserMessagesSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentInDirectChatTotalCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentInDirectChatTotalCounter');
        return new UserMessagesSentInDirectChatTotalCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesReceivedCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesReceivedCounter');
        return new UserMessagesReceivedCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesChatsCounter');
        return new UserMessagesChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesDirectChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesDirectChatsCounter');
        return new UserMessagesDirectChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserSuccessfulInvitesCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userSuccessfulInvitesCounter');
        return new UserSuccessfulInvitesCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserEmailSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userEmailSentCounter');
        return new UserEmailSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserDialogCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userDialogCounter');
        return new UserDialogCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: number) {
        return this._set(ctx, [uid, cid], value);
    }

    add(ctx: Context, uid: number, cid: number, value: number) {
        return this._add(ctx, [uid, cid], value);
    }

    increment(ctx: Context, uid: number, cid: number) {
        return this._increment(ctx, [uid, cid]);
    }

    decrement(ctx: Context, uid: number, cid: number) {
        return this._decrement(ctx, [uid, cid]);
    }
}

export class UserDialogHaveMentionFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userDialogHaveMention');
        return new UserDialogHaveMentionFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: boolean) {
        return this._set(ctx, [uid, cid], value);
    }

    invert(ctx: Context, uid: number, cid: number) {
        return this._invert(ctx, [uid, cid]);
    }
}

export class NotificationCenterCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('notificationCenterCounter');
        return new NotificationCenterCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(ncid: number) {
        return this._findById([ncid]);
    }

    get(ctx: Context, ncid: number) {
        return this._get(ctx, [ncid]);
    }

    set(ctx: Context, ncid: number, value: number) {
        return this._set(ctx, [ncid], value);
    }

    add(ctx: Context, ncid: number, value: number) {
        return this._add(ctx, [ncid], value);
    }

    increment(ctx: Context, ncid: number) {
        return this._increment(ctx, [ncid]);
    }

    decrement(ctx: Context, ncid: number) {
        return this._decrement(ctx, [ncid]);
    }
}

export class UserAudienceCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userAudienceCounter');
        return new UserAudienceCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentInDirectChatCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentInDirectChatCounter');
        return new UserMessagesSentInDirectChatCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: number) {
        return this._set(ctx, [uid, cid], value);
    }

    add(ctx: Context, uid: number, cid: number, value: number) {
        return this._add(ctx, [uid, cid], value);
    }

    increment(ctx: Context, uid: number, cid: number) {
        return this._increment(ctx, [uid, cid]);
    }

    decrement(ctx: Context, uid: number, cid: number) {
        return this._decrement(ctx, [uid, cid]);
    }
}

export class User2WayDirectChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('user2WayDirectChatsCounter');
        return new User2WayDirectChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class GlobalStatisticsCountersFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('globalStatisticsCounters');
        return new GlobalStatisticsCountersFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(name: string) {
        return this._findById([name]);
    }

    get(ctx: Context, name: string) {
        return this._get(ctx, [name]);
    }

    set(ctx: Context, name: string, value: number) {
        return this._set(ctx, [name], value);
    }

    add(ctx: Context, name: string, value: number) {
        return this._add(ctx, [name], value);
    }

    increment(ctx: Context, name: string) {
        return this._increment(ctx, [name]);
    }

    decrement(ctx: Context, name: string) {
        return this._decrement(ctx, [name]);
    }
}

export class UserGlobalCounterAllUnreadMessagesFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterAllUnreadMessages');
        return new UserGlobalCounterAllUnreadMessagesFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterUnreadMessagesWithoutMutedFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterUnreadMessagesWithoutMuted');
        return new UserGlobalCounterUnreadMessagesWithoutMutedFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterAllUnreadChatsFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterAllUnreadChats');
        return new UserGlobalCounterAllUnreadChatsFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterUnreadChatsWithoutMutedFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterUnreadChatsWithoutMuted');
        return new UserGlobalCounterUnreadChatsWithoutMutedFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export interface UserShape {
    id: number;
    authId: string;
    email: string;
    isBot: boolean;
    invitedBy: number | null;
    botOwner: number | null;
    isSuperBot: boolean | null;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
}

export interface UserCreateShape {
    authId: string;
    email: string;
    isBot: boolean;
    invitedBy: number | null;
    botOwner: number | null;
    isSuperBot: boolean | null;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
}

export class User extends Entity<UserShape> {
    get id(): number { return this._rawValue.id; }
    get authId(): string { return this._rawValue.authId; }
    set authId(value: string) {
        let normalized = this.descriptor.codec.fields.authId.normalize(value);
        if (this._rawValue.authId !== normalized) {
            this._rawValue.authId = normalized;
            this._updatedValues.authId = normalized;
            this.invalidate();
        }
    }
    get email(): string { return this._rawValue.email; }
    set email(value: string) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get isBot(): boolean { return this._rawValue.isBot; }
    set isBot(value: boolean) {
        let normalized = this.descriptor.codec.fields.isBot.normalize(value);
        if (this._rawValue.isBot !== normalized) {
            this._rawValue.isBot = normalized;
            this._updatedValues.isBot = normalized;
            this.invalidate();
        }
    }
    get invitedBy(): number | null { return this._rawValue.invitedBy; }
    set invitedBy(value: number | null) {
        let normalized = this.descriptor.codec.fields.invitedBy.normalize(value);
        if (this._rawValue.invitedBy !== normalized) {
            this._rawValue.invitedBy = normalized;
            this._updatedValues.invitedBy = normalized;
            this.invalidate();
        }
    }
    get botOwner(): number | null { return this._rawValue.botOwner; }
    set botOwner(value: number | null) {
        let normalized = this.descriptor.codec.fields.botOwner.normalize(value);
        if (this._rawValue.botOwner !== normalized) {
            this._rawValue.botOwner = normalized;
            this._updatedValues.botOwner = normalized;
            this.invalidate();
        }
    }
    get isSuperBot(): boolean | null { return this._rawValue.isSuperBot; }
    set isSuperBot(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isSuperBot.normalize(value);
        if (this._rawValue.isSuperBot !== normalized) {
            this._rawValue.isSuperBot = normalized;
            this._updatedValues.isSuperBot = normalized;
            this.invalidate();
        }
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' { return this._rawValue.status; }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class UserFactory extends EntityFactory<UserShape, User> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('user');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'authId', storageKey: 'authId', type: { type: 'unique', fields: [{ name: 'authId', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'authId'), condition: src => src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'email', storageKey: 'email', type: { type: 'unique', fields: [{ name: 'email', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'email'), condition: src => src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'owner', storageKey: 'owner', type: { type: 'range', fields: [{ name: 'botOwner', type: 'opt_integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'owner'), condition: src => src.botOwner });
        secondaryIndexes.push({ name: 'superBots', storageKey: 'superBots', type: { type: 'range', fields: [] }, subspace: await storage.resolveEntityIndexDirectory('user', 'superBots'), condition: src => src.isBot === true && src.isSuperBot });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'authId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'email', type: { type: 'string' }, secure: false });
        fields.push({ name: 'isBot', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'invitedBy', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'botOwner', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'isSuperBot', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['pending', 'activated', 'suspended', 'deleted'] }, secure: false });
        let codec = c.struct({
            id: c.integer,
            authId: c.string,
            email: c.string,
            isBot: c.boolean,
            invitedBy: c.optional(c.integer),
            botOwner: c.optional(c.integer),
            isSuperBot: c.optional(c.boolean),
            status: c.enum('pending', 'activated', 'suspended', 'deleted'),
        });
        let descriptor: EntityDescriptor<UserShape> = {
            name: 'User',
            storageKey: 'user',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserShape>) {
        super(descriptor);
    }

    readonly authId = Object.freeze({
        find: async (ctx: Context, authId: string) => {
            return this._findFromUniqueIndex(ctx, [authId], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    readonly email = Object.freeze({
        find: async (ctx: Context, email: string) => {
            return this._findFromUniqueIndex(ctx, [email], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    readonly owner = Object.freeze({
        findAll: async (ctx: Context, botOwner: number | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [botOwner])).items;
        },
        query: (ctx: Context, botOwner: number | null, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [botOwner], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (botOwner: number | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [botOwner], opts);
        },
        liveStream: (ctx: Context, botOwner: number | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [botOwner], opts);
        },
    });

    readonly superBots = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [])).items;
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [], opts);
        },
    });

    create(ctx: Context, id: number, src: UserCreateShape): Promise<User> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<User | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserShape>): User {
        return new User([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserProfileShape {
    id: number;
    firstName: string;
    lastName: string | null;
    phone: string | null;
    about: string | null;
    website: string | null;
    location: string | null;
    email: string | null;
    picture: any | null;
    linkedin: string | null;
    twitter: string | null;
    locations: any | null;
    primaryOrganization: number | null;
    primaryBadge: number | null;
    role: string | null;
}

export interface UserProfileCreateShape {
    firstName: string;
    lastName: string | null;
    phone: string | null;
    about: string | null;
    website: string | null;
    location: string | null;
    email: string | null;
    picture: any | null;
    linkedin: string | null;
    twitter: string | null;
    locations: any | null;
    primaryOrganization: number | null;
    primaryBadge: number | null;
    role: string | null;
}

export class UserProfile extends Entity<UserProfileShape> {
    get id(): number { return this._rawValue.id; }
    get firstName(): string { return this._rawValue.firstName; }
    set firstName(value: string) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get phone(): string | null { return this._rawValue.phone; }
    set phone(value: string | null) {
        let normalized = this.descriptor.codec.fields.phone.normalize(value);
        if (this._rawValue.phone !== normalized) {
            this._rawValue.phone = normalized;
            this._updatedValues.phone = normalized;
            this.invalidate();
        }
    }
    get about(): string | null { return this._rawValue.about; }
    set about(value: string | null) {
        let normalized = this.descriptor.codec.fields.about.normalize(value);
        if (this._rawValue.about !== normalized) {
            this._rawValue.about = normalized;
            this._updatedValues.about = normalized;
            this.invalidate();
        }
    }
    get website(): string | null { return this._rawValue.website; }
    set website(value: string | null) {
        let normalized = this.descriptor.codec.fields.website.normalize(value);
        if (this._rawValue.website !== normalized) {
            this._rawValue.website = normalized;
            this._updatedValues.website = normalized;
            this.invalidate();
        }
    }
    get location(): string | null { return this._rawValue.location; }
    set location(value: string | null) {
        let normalized = this.descriptor.codec.fields.location.normalize(value);
        if (this._rawValue.location !== normalized) {
            this._rawValue.location = normalized;
            this._updatedValues.location = normalized;
            this.invalidate();
        }
    }
    get email(): string | null { return this._rawValue.email; }
    set email(value: string | null) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get picture(): any | null { return this._rawValue.picture; }
    set picture(value: any | null) {
        let normalized = this.descriptor.codec.fields.picture.normalize(value);
        if (this._rawValue.picture !== normalized) {
            this._rawValue.picture = normalized;
            this._updatedValues.picture = normalized;
            this.invalidate();
        }
    }
    get linkedin(): string | null { return this._rawValue.linkedin; }
    set linkedin(value: string | null) {
        let normalized = this.descriptor.codec.fields.linkedin.normalize(value);
        if (this._rawValue.linkedin !== normalized) {
            this._rawValue.linkedin = normalized;
            this._updatedValues.linkedin = normalized;
            this.invalidate();
        }
    }
    get twitter(): string | null { return this._rawValue.twitter; }
    set twitter(value: string | null) {
        let normalized = this.descriptor.codec.fields.twitter.normalize(value);
        if (this._rawValue.twitter !== normalized) {
            this._rawValue.twitter = normalized;
            this._updatedValues.twitter = normalized;
            this.invalidate();
        }
    }
    get locations(): any | null { return this._rawValue.locations; }
    set locations(value: any | null) {
        let normalized = this.descriptor.codec.fields.locations.normalize(value);
        if (this._rawValue.locations !== normalized) {
            this._rawValue.locations = normalized;
            this._updatedValues.locations = normalized;
            this.invalidate();
        }
    }
    get primaryOrganization(): number | null { return this._rawValue.primaryOrganization; }
    set primaryOrganization(value: number | null) {
        let normalized = this.descriptor.codec.fields.primaryOrganization.normalize(value);
        if (this._rawValue.primaryOrganization !== normalized) {
            this._rawValue.primaryOrganization = normalized;
            this._updatedValues.primaryOrganization = normalized;
            this.invalidate();
        }
    }
    get primaryBadge(): number | null { return this._rawValue.primaryBadge; }
    set primaryBadge(value: number | null) {
        let normalized = this.descriptor.codec.fields.primaryBadge.normalize(value);
        if (this._rawValue.primaryBadge !== normalized) {
            this._rawValue.primaryBadge = normalized;
            this._updatedValues.primaryBadge = normalized;
            this.invalidate();
        }
    }
    get role(): string | null { return this._rawValue.role; }
    set role(value: string | null) {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
}

export class UserProfileFactory extends EntityFactory<UserProfileShape, UserProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'byUpdatedAt', storageKey: 'byUpdatedAt', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userProfile', 'byUpdatedAt'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'firstName', type: { type: 'string' }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'phone', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'about', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'website', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'location', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'email', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'picture', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'linkedin', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'twitter', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'locations', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'primaryOrganization', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'primaryBadge', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            firstName: c.string,
            lastName: c.optional(c.string),
            phone: c.optional(c.string),
            about: c.optional(c.string),
            website: c.optional(c.string),
            location: c.optional(c.string),
            email: c.optional(c.string),
            picture: c.optional(c.any),
            linkedin: c.optional(c.string),
            twitter: c.optional(c.string),
            locations: c.optional(c.any),
            primaryOrganization: c.optional(c.integer),
            primaryBadge: c.optional(c.integer),
            role: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserProfileShape> = {
            name: 'UserProfile',
            storageKey: 'userProfile',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserProfileShape>) {
        super(descriptor);
    }

    readonly byUpdatedAt = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: UserProfileCreateShape): Promise<UserProfile> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserProfile | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserProfileShape>): UserProfile {
        return new UserProfile([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserProfilePrefilShape {
    id: number;
    firstName: string | null;
    lastName: string | null;
    picture: string | null;
}

export interface UserProfilePrefilCreateShape {
    firstName: string | null;
    lastName: string | null;
    picture: string | null;
}

export class UserProfilePrefil extends Entity<UserProfilePrefilShape> {
    get id(): number { return this._rawValue.id; }
    get firstName(): string | null { return this._rawValue.firstName; }
    set firstName(value: string | null) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get picture(): string | null { return this._rawValue.picture; }
    set picture(value: string | null) {
        let normalized = this.descriptor.codec.fields.picture.normalize(value);
        if (this._rawValue.picture !== normalized) {
            this._rawValue.picture = normalized;
            this._updatedValues.picture = normalized;
            this.invalidate();
        }
    }
}

export class UserProfilePrefilFactory extends EntityFactory<UserProfilePrefilShape, UserProfilePrefil> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userProfilePrefil');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'firstName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'picture', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            firstName: c.optional(c.string),
            lastName: c.optional(c.string),
            picture: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserProfilePrefilShape> = {
            name: 'UserProfilePrefil',
            storageKey: 'userProfilePrefil',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserProfilePrefilFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserProfilePrefilShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: UserProfilePrefilCreateShape): Promise<UserProfilePrefil> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserProfilePrefil | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserProfilePrefilShape>): UserProfilePrefil {
        return new UserProfilePrefil([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserSettingsShape {
    id: number;
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    commentNotifications: 'all' | 'direct' | 'none' | null;
    commentNotificationsDelivery: 'all' | 'none' | null;
    mobileAlert: boolean | null;
    mobileIncludeText: boolean | null;
    notificationsDelay: 'none' | '1min' | '15min' | null;
    globalCounterType: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null;
}

export interface UserSettingsCreateShape {
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    commentNotifications: 'all' | 'direct' | 'none' | null;
    commentNotificationsDelivery: 'all' | 'none' | null;
    mobileAlert: boolean | null;
    mobileIncludeText: boolean | null;
    notificationsDelay: 'none' | '1min' | '15min' | null;
    globalCounterType: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null;
}

export class UserSettings extends Entity<UserSettingsShape> {
    get id(): number { return this._rawValue.id; }
    get emailFrequency(): '1hour' | '15min' | 'never' | '24hour' | '1week' { return this._rawValue.emailFrequency; }
    set emailFrequency(value: '1hour' | '15min' | 'never' | '24hour' | '1week') {
        let normalized = this.descriptor.codec.fields.emailFrequency.normalize(value);
        if (this._rawValue.emailFrequency !== normalized) {
            this._rawValue.emailFrequency = normalized;
            this._updatedValues.emailFrequency = normalized;
            this.invalidate();
        }
    }
    get desktopNotifications(): 'all' | 'direct' | 'none' { return this._rawValue.desktopNotifications; }
    set desktopNotifications(value: 'all' | 'direct' | 'none') {
        let normalized = this.descriptor.codec.fields.desktopNotifications.normalize(value);
        if (this._rawValue.desktopNotifications !== normalized) {
            this._rawValue.desktopNotifications = normalized;
            this._updatedValues.desktopNotifications = normalized;
            this.invalidate();
        }
    }
    get mobileNotifications(): 'all' | 'direct' | 'none' { return this._rawValue.mobileNotifications; }
    set mobileNotifications(value: 'all' | 'direct' | 'none') {
        let normalized = this.descriptor.codec.fields.mobileNotifications.normalize(value);
        if (this._rawValue.mobileNotifications !== normalized) {
            this._rawValue.mobileNotifications = normalized;
            this._updatedValues.mobileNotifications = normalized;
            this.invalidate();
        }
    }
    get commentNotifications(): 'all' | 'direct' | 'none' | null { return this._rawValue.commentNotifications; }
    set commentNotifications(value: 'all' | 'direct' | 'none' | null) {
        let normalized = this.descriptor.codec.fields.commentNotifications.normalize(value);
        if (this._rawValue.commentNotifications !== normalized) {
            this._rawValue.commentNotifications = normalized;
            this._updatedValues.commentNotifications = normalized;
            this.invalidate();
        }
    }
    get commentNotificationsDelivery(): 'all' | 'none' | null { return this._rawValue.commentNotificationsDelivery; }
    set commentNotificationsDelivery(value: 'all' | 'none' | null) {
        let normalized = this.descriptor.codec.fields.commentNotificationsDelivery.normalize(value);
        if (this._rawValue.commentNotificationsDelivery !== normalized) {
            this._rawValue.commentNotificationsDelivery = normalized;
            this._updatedValues.commentNotificationsDelivery = normalized;
            this.invalidate();
        }
    }
    get mobileAlert(): boolean | null { return this._rawValue.mobileAlert; }
    set mobileAlert(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.mobileAlert.normalize(value);
        if (this._rawValue.mobileAlert !== normalized) {
            this._rawValue.mobileAlert = normalized;
            this._updatedValues.mobileAlert = normalized;
            this.invalidate();
        }
    }
    get mobileIncludeText(): boolean | null { return this._rawValue.mobileIncludeText; }
    set mobileIncludeText(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.mobileIncludeText.normalize(value);
        if (this._rawValue.mobileIncludeText !== normalized) {
            this._rawValue.mobileIncludeText = normalized;
            this._updatedValues.mobileIncludeText = normalized;
            this.invalidate();
        }
    }
    get notificationsDelay(): 'none' | '1min' | '15min' | null { return this._rawValue.notificationsDelay; }
    set notificationsDelay(value: 'none' | '1min' | '15min' | null) {
        let normalized = this.descriptor.codec.fields.notificationsDelay.normalize(value);
        if (this._rawValue.notificationsDelay !== normalized) {
            this._rawValue.notificationsDelay = normalized;
            this._updatedValues.notificationsDelay = normalized;
            this.invalidate();
        }
    }
    get globalCounterType(): 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null { return this._rawValue.globalCounterType; }
    set globalCounterType(value: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null) {
        let normalized = this.descriptor.codec.fields.globalCounterType.normalize(value);
        if (this._rawValue.globalCounterType !== normalized) {
            this._rawValue.globalCounterType = normalized;
            this._updatedValues.globalCounterType = normalized;
            this.invalidate();
        }
    }
}

export class UserSettingsFactory extends EntityFactory<UserSettingsShape, UserSettings> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userSettings');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'emailFrequency', type: { type: 'enum', values: ['1hour', '15min', 'never', '24hour', '1week'] }, secure: false });
        fields.push({ name: 'desktopNotifications', type: { type: 'enum', values: ['all', 'direct', 'none'] }, secure: false });
        fields.push({ name: 'mobileNotifications', type: { type: 'enum', values: ['all', 'direct', 'none'] }, secure: false });
        fields.push({ name: 'commentNotifications', type: { type: 'optional', inner: { type: 'enum', values: ['all', 'direct', 'none'] } }, secure: false });
        fields.push({ name: 'commentNotificationsDelivery', type: { type: 'optional', inner: { type: 'enum', values: ['all', 'none'] } }, secure: false });
        fields.push({ name: 'mobileAlert', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'mobileIncludeText', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'notificationsDelay', type: { type: 'optional', inner: { type: 'enum', values: ['none', '1min', '15min'] } }, secure: false });
        fields.push({ name: 'globalCounterType', type: { type: 'optional', inner: { type: 'enum', values: ['unread_messages', 'unread_chats', 'unread_messages_no_muted', 'unread_chats_no_muted'] } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            emailFrequency: c.enum('1hour', '15min', 'never', '24hour', '1week'),
            desktopNotifications: c.enum('all', 'direct', 'none'),
            mobileNotifications: c.enum('all', 'direct', 'none'),
            commentNotifications: c.optional(c.enum('all', 'direct', 'none')),
            commentNotificationsDelivery: c.optional(c.enum('all', 'none')),
            mobileAlert: c.optional(c.boolean),
            mobileIncludeText: c.optional(c.boolean),
            notificationsDelay: c.optional(c.enum('none', '1min', '15min')),
            globalCounterType: c.optional(c.enum('unread_messages', 'unread_chats', 'unread_messages_no_muted', 'unread_chats_no_muted')),
        });
        let descriptor: EntityDescriptor<UserSettingsShape> = {
            name: 'UserSettings',
            storageKey: 'userSettings',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserSettingsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserSettingsShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: UserSettingsCreateShape): Promise<UserSettings> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserSettings | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserSettingsShape>): UserSettings {
        return new UserSettings([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface OrganizationShape {
    id: number;
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
    kind: 'organization' | 'community';
    editorial: boolean;
    private: boolean | null;
    personal: boolean | null;
}

export interface OrganizationCreateShape {
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
    kind: 'organization' | 'community';
    editorial: boolean;
    private: boolean | null;
    personal: boolean | null;
}

export class Organization extends Entity<OrganizationShape> {
    get id(): number { return this._rawValue.id; }
    get ownerId(): number { return this._rawValue.ownerId; }
    set ownerId(value: number) {
        let normalized = this.descriptor.codec.fields.ownerId.normalize(value);
        if (this._rawValue.ownerId !== normalized) {
            this._rawValue.ownerId = normalized;
            this._updatedValues.ownerId = normalized;
            this.invalidate();
        }
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' { return this._rawValue.status; }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
    get kind(): 'organization' | 'community' { return this._rawValue.kind; }
    set kind(value: 'organization' | 'community') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get editorial(): boolean { return this._rawValue.editorial; }
    set editorial(value: boolean) {
        let normalized = this.descriptor.codec.fields.editorial.normalize(value);
        if (this._rawValue.editorial !== normalized) {
            this._rawValue.editorial = normalized;
            this._updatedValues.editorial = normalized;
            this.invalidate();
        }
    }
    get private(): boolean | null { return this._rawValue.private; }
    set private(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.private.normalize(value);
        if (this._rawValue.private !== normalized) {
            this._rawValue.private = normalized;
            this._updatedValues.private = normalized;
            this.invalidate();
        }
    }
    get personal(): boolean | null { return this._rawValue.personal; }
    set personal(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.personal.normalize(value);
        if (this._rawValue.personal !== normalized) {
            this._rawValue.personal = normalized;
            this._updatedValues.personal = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationFactory extends EntityFactory<OrganizationShape, Organization> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organization');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'community', storageKey: 'community', type: { type: 'range', fields: [] }, subspace: await storage.resolveEntityIndexDirectory('organization', 'community'), condition: (src) => src.kind === 'community' && src.status === 'activated' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ownerId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['pending', 'activated', 'suspended', 'deleted'] }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['organization', 'community'] }, secure: false });
        fields.push({ name: 'editorial', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'private', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'personal', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ownerId: c.integer,
            status: c.enum('pending', 'activated', 'suspended', 'deleted'),
            kind: c.enum('organization', 'community'),
            editorial: c.boolean,
            private: c.optional(c.boolean),
            personal: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<OrganizationShape> = {
            name: 'Organization',
            storageKey: 'organization',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationShape>) {
        super(descriptor);
    }

    readonly community = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: OrganizationCreateShape): Promise<Organization> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Organization | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationShape>): Organization {
        return new Organization([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface OrganizationProfileShape {
    id: number;
    name: string;
    photo: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    about: string | null;
    twitter: string | null;
    facebook: string | null;
    linkedin: string | null;
    website: string | null;
    joinedMembersCount: number | null;
}

export interface OrganizationProfileCreateShape {
    name: string;
    photo: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    about: string | null;
    twitter: string | null;
    facebook: string | null;
    linkedin: string | null;
    website: string | null;
    joinedMembersCount: number | null;
}

export class OrganizationProfile extends Entity<OrganizationProfileShape> {
    get id(): number { return this._rawValue.id; }
    get name(): string { return this._rawValue.name; }
    set name(value: string) {
        let normalized = this.descriptor.codec.fields.name.normalize(value);
        if (this._rawValue.name !== normalized) {
            this._rawValue.name = normalized;
            this._updatedValues.name = normalized;
            this.invalidate();
        }
    }
    get photo(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.photo; }
    set photo(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.photo.normalize(value);
        if (this._rawValue.photo !== normalized) {
            this._rawValue.photo = normalized;
            this._updatedValues.photo = normalized;
            this.invalidate();
        }
    }
    get about(): string | null { return this._rawValue.about; }
    set about(value: string | null) {
        let normalized = this.descriptor.codec.fields.about.normalize(value);
        if (this._rawValue.about !== normalized) {
            this._rawValue.about = normalized;
            this._updatedValues.about = normalized;
            this.invalidate();
        }
    }
    get twitter(): string | null { return this._rawValue.twitter; }
    set twitter(value: string | null) {
        let normalized = this.descriptor.codec.fields.twitter.normalize(value);
        if (this._rawValue.twitter !== normalized) {
            this._rawValue.twitter = normalized;
            this._updatedValues.twitter = normalized;
            this.invalidate();
        }
    }
    get facebook(): string | null { return this._rawValue.facebook; }
    set facebook(value: string | null) {
        let normalized = this.descriptor.codec.fields.facebook.normalize(value);
        if (this._rawValue.facebook !== normalized) {
            this._rawValue.facebook = normalized;
            this._updatedValues.facebook = normalized;
            this.invalidate();
        }
    }
    get linkedin(): string | null { return this._rawValue.linkedin; }
    set linkedin(value: string | null) {
        let normalized = this.descriptor.codec.fields.linkedin.normalize(value);
        if (this._rawValue.linkedin !== normalized) {
            this._rawValue.linkedin = normalized;
            this._updatedValues.linkedin = normalized;
            this.invalidate();
        }
    }
    get website(): string | null { return this._rawValue.website; }
    set website(value: string | null) {
        let normalized = this.descriptor.codec.fields.website.normalize(value);
        if (this._rawValue.website !== normalized) {
            this._rawValue.website = normalized;
            this._updatedValues.website = normalized;
            this.invalidate();
        }
    }
    get joinedMembersCount(): number | null { return this._rawValue.joinedMembersCount; }
    set joinedMembersCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.joinedMembersCount.normalize(value);
        if (this._rawValue.joinedMembersCount !== normalized) {
            this._rawValue.joinedMembersCount = normalized;
            this._updatedValues.joinedMembersCount = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationProfileFactory extends EntityFactory<OrganizationProfileShape, OrganizationProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'name', type: { type: 'string' }, secure: false });
        fields.push({ name: 'photo', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'about', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'twitter', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'facebook', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'linkedin', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'website', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'joinedMembersCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            name: c.string,
            photo: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            about: c.optional(c.string),
            twitter: c.optional(c.string),
            facebook: c.optional(c.string),
            linkedin: c.optional(c.string),
            website: c.optional(c.string),
            joinedMembersCount: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<OrganizationProfileShape> = {
            name: 'OrganizationProfile',
            storageKey: 'organizationProfile',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationProfileShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: OrganizationProfileCreateShape): Promise<OrganizationProfile> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OrganizationProfile | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationProfileShape>): OrganizationProfile {
        return new OrganizationProfile([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface OrganizationEditorialShape {
    id: number;
    listed: boolean;
    featured: boolean;
}

export interface OrganizationEditorialCreateShape {
    listed: boolean;
    featured: boolean;
}

export class OrganizationEditorial extends Entity<OrganizationEditorialShape> {
    get id(): number { return this._rawValue.id; }
    get listed(): boolean { return this._rawValue.listed; }
    set listed(value: boolean) {
        let normalized = this.descriptor.codec.fields.listed.normalize(value);
        if (this._rawValue.listed !== normalized) {
            this._rawValue.listed = normalized;
            this._updatedValues.listed = normalized;
            this.invalidate();
        }
    }
    get featured(): boolean { return this._rawValue.featured; }
    set featured(value: boolean) {
        let normalized = this.descriptor.codec.fields.featured.normalize(value);
        if (this._rawValue.featured !== normalized) {
            this._rawValue.featured = normalized;
            this._updatedValues.featured = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationEditorialFactory extends EntityFactory<OrganizationEditorialShape, OrganizationEditorial> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationEditorial');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'listed', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'featured', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            listed: c.boolean,
            featured: c.boolean,
        });
        let descriptor: EntityDescriptor<OrganizationEditorialShape> = {
            name: 'OrganizationEditorial',
            storageKey: 'organizationEditorial',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationEditorialFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationEditorialShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: OrganizationEditorialCreateShape): Promise<OrganizationEditorial> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OrganizationEditorial | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationEditorialShape>): OrganizationEditorial {
        return new OrganizationEditorial([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface OrganizationMemberShape {
    oid: number;
    uid: number;
    invitedBy: number | null;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export interface OrganizationMemberCreateShape {
    invitedBy: number | null;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export class OrganizationMember extends Entity<OrganizationMemberShape> {
    get oid(): number { return this._rawValue.oid; }
    get uid(): number { return this._rawValue.uid; }
    get invitedBy(): number | null { return this._rawValue.invitedBy; }
    set invitedBy(value: number | null) {
        let normalized = this.descriptor.codec.fields.invitedBy.normalize(value);
        if (this._rawValue.invitedBy !== normalized) {
            this._rawValue.invitedBy = normalized;
            this._updatedValues.invitedBy = normalized;
            this.invalidate();
        }
    }
    get role(): 'admin' | 'member' { return this._rawValue.role; }
    set role(value: 'admin' | 'member') {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get status(): 'requested' | 'joined' | 'left' { return this._rawValue.status; }
    set status(value: 'requested' | 'joined' | 'left') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationMemberFactory extends EntityFactory<OrganizationMemberShape, OrganizationMember> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationMember');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'ids', storageKey: 'ids', type: { type: 'unique', fields: [{ name: 'oid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'ids'), condition: undefined });
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'range', fields: [{ name: 'status', type: 'string' }, { name: 'oid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'organization'), condition: undefined });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'status', type: 'string' }, { name: 'uid', type: 'integer' }, { name: 'oid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'oid', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'invitedBy', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'enum', values: ['admin', 'member'] }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['requested', 'joined', 'left'] }, secure: false });
        let codec = c.struct({
            oid: c.integer,
            uid: c.integer,
            invitedBy: c.optional(c.integer),
            role: c.enum('admin', 'member'),
            status: c.enum('requested', 'joined', 'left'),
        });
        let descriptor: EntityDescriptor<OrganizationMemberShape> = {
            name: 'OrganizationMember',
            storageKey: 'organizationMember',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationMemberFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationMemberShape>) {
        super(descriptor);
    }

    readonly ids = Object.freeze({
        find: async (ctx: Context, oid: number, uid: number) => {
            return this._findFromUniqueIndex(ctx, [oid, uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, oid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [oid])).items;
        },
        query: (ctx: Context, oid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    readonly organization = Object.freeze({
        findAll: async (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [status, oid])).items;
        },
        query: (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [status, oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (status: 'requested' | 'joined' | 'left', oid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [status, oid], opts);
        },
        liveStream: (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [status, oid], opts);
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [status, uid])).items;
        },
        query: (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [status, uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (status: 'requested' | 'joined' | 'left', uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [status, uid], opts);
        },
        liveStream: (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [status, uid], opts);
        },
    });

    create(ctx: Context, oid: number, uid: number, src: OrganizationMemberCreateShape): Promise<OrganizationMember> {
        return this._create(ctx, [oid, uid], this.descriptor.codec.normalize({ oid, uid, ...src }));
    }

    findById(ctx: Context, oid: number, uid: number): Promise<OrganizationMember | null> {
        return this._findById(ctx, [oid, uid]);
    }

    watch(ctx: Context, oid: number, uid: number): Watch {
        return this._watch(ctx, [oid, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationMemberShape>): OrganizationMember {
        return new OrganizationMember([value.oid, value.uid], value, this.descriptor, this._flush, ctx);
    }
}

export interface OnlineShape {
    uid: number;
    lastSeen: number;
    activeExpires: number | null;
    active: boolean | null;
}

export interface OnlineCreateShape {
    lastSeen: number;
    activeExpires: number | null;
    active: boolean | null;
}

export class Online extends Entity<OnlineShape> {
    get uid(): number { return this._rawValue.uid; }
    get lastSeen(): number { return this._rawValue.lastSeen; }
    set lastSeen(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeen.normalize(value);
        if (this._rawValue.lastSeen !== normalized) {
            this._rawValue.lastSeen = normalized;
            this._updatedValues.lastSeen = normalized;
            this.invalidate();
        }
    }
    get activeExpires(): number | null { return this._rawValue.activeExpires; }
    set activeExpires(value: number | null) {
        let normalized = this.descriptor.codec.fields.activeExpires.normalize(value);
        if (this._rawValue.activeExpires !== normalized) {
            this._rawValue.activeExpires = normalized;
            this._updatedValues.activeExpires = normalized;
            this.invalidate();
        }
    }
    get active(): boolean | null { return this._rawValue.active; }
    set active(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class OnlineFactory extends EntityFactory<OnlineShape, Online> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('online');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastSeen', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'activeExpires', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'active', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            lastSeen: c.integer,
            activeExpires: c.optional(c.integer),
            active: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<OnlineShape> = {
            name: 'Online',
            storageKey: 'online',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OnlineFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OnlineShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: OnlineCreateShape): Promise<Online> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<Online | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OnlineShape>): Online {
        return new Online([value.uid], value, this.descriptor, this._flush, ctx);
    }
}

export interface PresenceShape {
    uid: number;
    tid: string;
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
    active: boolean | null;
}

export interface PresenceCreateShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
    active: boolean | null;
}

export class Presence extends Entity<PresenceShape> {
    get uid(): number { return this._rawValue.uid; }
    get tid(): string { return this._rawValue.tid; }
    get lastSeen(): number { return this._rawValue.lastSeen; }
    set lastSeen(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeen.normalize(value);
        if (this._rawValue.lastSeen !== normalized) {
            this._rawValue.lastSeen = normalized;
            this._updatedValues.lastSeen = normalized;
            this.invalidate();
        }
    }
    get lastSeenTimeout(): number { return this._rawValue.lastSeenTimeout; }
    set lastSeenTimeout(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeenTimeout.normalize(value);
        if (this._rawValue.lastSeenTimeout !== normalized) {
            this._rawValue.lastSeenTimeout = normalized;
            this._updatedValues.lastSeenTimeout = normalized;
            this.invalidate();
        }
    }
    get platform(): string { return this._rawValue.platform; }
    set platform(value: string) {
        let normalized = this.descriptor.codec.fields.platform.normalize(value);
        if (this._rawValue.platform !== normalized) {
            this._rawValue.platform = normalized;
            this._updatedValues.platform = normalized;
            this.invalidate();
        }
    }
    get active(): boolean | null { return this._rawValue.active; }
    set active(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class PresenceFactory extends EntityFactory<PresenceShape, Presence> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('presence');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'lastSeen', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('presence', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'tid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastSeen', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'lastSeenTimeout', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'platform', type: { type: 'string' }, secure: false });
        fields.push({ name: 'active', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            tid: c.string,
            lastSeen: c.integer,
            lastSeenTimeout: c.integer,
            platform: c.string,
            active: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<PresenceShape> = {
            name: 'Presence',
            storageKey: 'presence',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PresenceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PresenceShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, tid: string, src: PresenceCreateShape): Promise<Presence> {
        return this._create(ctx, [uid, tid], this.descriptor.codec.normalize({ uid, tid, ...src }));
    }

    findById(ctx: Context, uid: number, tid: string): Promise<Presence | null> {
        return this._findById(ctx, [uid, tid]);
    }

    watch(ctx: Context, uid: number, tid: string): Watch {
        return this._watch(ctx, [uid, tid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PresenceShape>): Presence {
        return new Presence([value.uid, value.tid], value, this.descriptor, this._flush, ctx);
    }
}

export interface MessageDraftShape {
    uid: number;
    cid: number;
    contents: string | null;
}

export interface MessageDraftCreateShape {
    contents: string | null;
}

export class MessageDraft extends Entity<MessageDraftShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get contents(): string | null { return this._rawValue.contents; }
    set contents(value: string | null) {
        let normalized = this.descriptor.codec.fields.contents.normalize(value);
        if (this._rawValue.contents !== normalized) {
            this._rawValue.contents = normalized;
            this._updatedValues.contents = normalized;
            this.invalidate();
        }
    }
}

export class MessageDraftFactory extends EntityFactory<MessageDraftShape, MessageDraft> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('messageDraft');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'contents', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            contents: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<MessageDraftShape> = {
            name: 'MessageDraft',
            storageKey: 'messageDraft',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new MessageDraftFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<MessageDraftShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, cid: number, src: MessageDraftCreateShape): Promise<MessageDraft> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<MessageDraft | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<MessageDraftShape>): MessageDraft {
        return new MessageDraft([value.uid, value.cid], value, this.descriptor, this._flush, ctx);
    }
}

export interface ConferenceRoomShape {
    id: number;
    startTime: number | null;
    strategy: 'direct' | 'bridged' | null;
}

export interface ConferenceRoomCreateShape {
    startTime: number | null;
    strategy: 'direct' | 'bridged' | null;
}

export class ConferenceRoom extends Entity<ConferenceRoomShape> {
    get id(): number { return this._rawValue.id; }
    get startTime(): number | null { return this._rawValue.startTime; }
    set startTime(value: number | null) {
        let normalized = this.descriptor.codec.fields.startTime.normalize(value);
        if (this._rawValue.startTime !== normalized) {
            this._rawValue.startTime = normalized;
            this._updatedValues.startTime = normalized;
            this.invalidate();
        }
    }
    get strategy(): 'direct' | 'bridged' | null { return this._rawValue.strategy; }
    set strategy(value: 'direct' | 'bridged' | null) {
        let normalized = this.descriptor.codec.fields.strategy.normalize(value);
        if (this._rawValue.strategy !== normalized) {
            this._rawValue.strategy = normalized;
            this._updatedValues.strategy = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceRoomFactory extends EntityFactory<ConferenceRoomShape, ConferenceRoom> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceRoom');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'startTime', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'strategy', type: { type: 'optional', inner: { type: 'enum', values: ['direct', 'bridged'] } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            startTime: c.optional(c.integer),
            strategy: c.optional(c.enum('direct', 'bridged')),
        });
        let descriptor: EntityDescriptor<ConferenceRoomShape> = {
            name: 'ConferenceRoom',
            storageKey: 'conferenceRoom',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceRoomFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceRoomShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: ConferenceRoomCreateShape): Promise<ConferenceRoom> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConferenceRoom | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceRoomShape>): ConferenceRoom {
        return new ConferenceRoom([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface ConferencePeerShape {
    id: number;
    cid: number;
    uid: number;
    tid: string;
    keepAliveTimeout: number;
    enabled: boolean;
}

export interface ConferencePeerCreateShape {
    cid: number;
    uid: number;
    tid: string;
    keepAliveTimeout: number;
    enabled: boolean;
}

export class ConferencePeer extends Entity<ConferencePeerShape> {
    get id(): number { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get keepAliveTimeout(): number { return this._rawValue.keepAliveTimeout; }
    set keepAliveTimeout(value: number) {
        let normalized = this.descriptor.codec.fields.keepAliveTimeout.normalize(value);
        if (this._rawValue.keepAliveTimeout !== normalized) {
            this._rawValue.keepAliveTimeout = normalized;
            this._updatedValues.keepAliveTimeout = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class ConferencePeerFactory extends EntityFactory<ConferencePeerShape, ConferencePeer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferencePeer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'auth', storageKey: 'auth', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'uid', type: 'integer' }, { name: 'tid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'auth'), condition: (src) => src.enabled });
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'keepAliveTimeout', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'conference'), condition: (src) => src.enabled });
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'range', fields: [{ name: 'keepAliveTimeout', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'active'), condition: (src) => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'keepAliveTimeout', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            cid: c.integer,
            uid: c.integer,
            tid: c.string,
            keepAliveTimeout: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<ConferencePeerShape> = {
            name: 'ConferencePeer',
            storageKey: 'conferencePeer',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferencePeerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferencePeerShape>) {
        super(descriptor);
    }

    readonly auth = Object.freeze({
        find: async (ctx: Context, cid: number, uid: number, tid: string) => {
            return this._findFromUniqueIndex(ctx, [cid, uid, tid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, cid: number, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid, uid])).items;
        },
        query: (ctx: Context, cid: number, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid, uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [cid], opts);
        },
    });

    readonly active = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    create(ctx: Context, id: number, src: ConferencePeerCreateShape): Promise<ConferencePeer> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConferencePeer | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferencePeerShape>): ConferencePeer {
        return new ConferencePeer([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface ConferenceMediaStreamShape {
    id: number;
    cid: number;
    peer1: number;
    peer2: number | null;
    kind: 'direct' | 'bridged';
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer: string | null;
    answer: string | null;
    ice1: any;
    ice2: any;
}

export interface ConferenceMediaStreamCreateShape {
    cid: number;
    peer1: number;
    peer2: number | null;
    kind: 'direct' | 'bridged';
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer: string | null;
    answer: string | null;
    ice1: any;
    ice2: any;
}

export class ConferenceMediaStream extends Entity<ConferenceMediaStreamShape> {
    get id(): number { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get peer1(): number { return this._rawValue.peer1; }
    set peer1(value: number) {
        let normalized = this.descriptor.codec.fields.peer1.normalize(value);
        if (this._rawValue.peer1 !== normalized) {
            this._rawValue.peer1 = normalized;
            this._updatedValues.peer1 = normalized;
            this.invalidate();
        }
    }
    get peer2(): number | null { return this._rawValue.peer2; }
    set peer2(value: number | null) {
        let normalized = this.descriptor.codec.fields.peer2.normalize(value);
        if (this._rawValue.peer2 !== normalized) {
            this._rawValue.peer2 = normalized;
            this._updatedValues.peer2 = normalized;
            this.invalidate();
        }
    }
    get kind(): 'direct' | 'bridged' { return this._rawValue.kind; }
    set kind(value: 'direct' | 'bridged') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get state(): 'wait-offer' | 'wait-answer' | 'online' | 'completed' { return this._rawValue.state; }
    set state(value: 'wait-offer' | 'wait-answer' | 'online' | 'completed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get offer(): string | null { return this._rawValue.offer; }
    set offer(value: string | null) {
        let normalized = this.descriptor.codec.fields.offer.normalize(value);
        if (this._rawValue.offer !== normalized) {
            this._rawValue.offer = normalized;
            this._updatedValues.offer = normalized;
            this.invalidate();
        }
    }
    get answer(): string | null { return this._rawValue.answer; }
    set answer(value: string | null) {
        let normalized = this.descriptor.codec.fields.answer.normalize(value);
        if (this._rawValue.answer !== normalized) {
            this._rawValue.answer = normalized;
            this._updatedValues.answer = normalized;
            this.invalidate();
        }
    }
    get ice1(): any { return this._rawValue.ice1; }
    set ice1(value: any) {
        let normalized = this.descriptor.codec.fields.ice1.normalize(value);
        if (this._rawValue.ice1 !== normalized) {
            this._rawValue.ice1 = normalized;
            this._updatedValues.ice1 = normalized;
            this.invalidate();
        }
    }
    get ice2(): any { return this._rawValue.ice2; }
    set ice2(value: any) {
        let normalized = this.descriptor.codec.fields.ice2.normalize(value);
        if (this._rawValue.ice2 !== normalized) {
            this._rawValue.ice2 = normalized;
            this._updatedValues.ice2 = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceMediaStreamFactory extends EntityFactory<ConferenceMediaStreamShape, ConferenceMediaStream> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceMediaStream');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceMediaStream', 'conference'), condition: (src) => src.state !== 'completed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'peer1', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'peer2', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['direct', 'bridged'] }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['wait-offer', 'wait-answer', 'online', 'completed'] }, secure: false });
        fields.push({ name: 'offer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'answer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'ice1', type: { type: 'json' }, secure: false });
        fields.push({ name: 'ice2', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            cid: c.integer,
            peer1: c.integer,
            peer2: c.optional(c.integer),
            kind: c.enum('direct', 'bridged'),
            state: c.enum('wait-offer', 'wait-answer', 'online', 'completed'),
            offer: c.optional(c.string),
            answer: c.optional(c.string),
            ice1: c.any,
            ice2: c.any,
        });
        let descriptor: EntityDescriptor<ConferenceMediaStreamShape> = {
            name: 'ConferenceMediaStream',
            storageKey: 'conferenceMediaStream',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceMediaStreamFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceMediaStreamShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, id: number, src: ConferenceMediaStreamCreateShape): Promise<ConferenceMediaStream> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConferenceMediaStream | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceMediaStreamShape>): ConferenceMediaStream {
        return new ConferenceMediaStream([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface ConferenceConnectionShape {
    peer1: number;
    peer2: number;
    cid: number;
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer: string | null;
    answer: string | null;
    ice1: any;
    ice2: any;
}

export interface ConferenceConnectionCreateShape {
    cid: number;
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer: string | null;
    answer: string | null;
    ice1: any;
    ice2: any;
}

export class ConferenceConnection extends Entity<ConferenceConnectionShape> {
    get peer1(): number { return this._rawValue.peer1; }
    get peer2(): number { return this._rawValue.peer2; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get state(): 'wait-offer' | 'wait-answer' | 'online' | 'completed' { return this._rawValue.state; }
    set state(value: 'wait-offer' | 'wait-answer' | 'online' | 'completed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get offer(): string | null { return this._rawValue.offer; }
    set offer(value: string | null) {
        let normalized = this.descriptor.codec.fields.offer.normalize(value);
        if (this._rawValue.offer !== normalized) {
            this._rawValue.offer = normalized;
            this._updatedValues.offer = normalized;
            this.invalidate();
        }
    }
    get answer(): string | null { return this._rawValue.answer; }
    set answer(value: string | null) {
        let normalized = this.descriptor.codec.fields.answer.normalize(value);
        if (this._rawValue.answer !== normalized) {
            this._rawValue.answer = normalized;
            this._updatedValues.answer = normalized;
            this.invalidate();
        }
    }
    get ice1(): any { return this._rawValue.ice1; }
    set ice1(value: any) {
        let normalized = this.descriptor.codec.fields.ice1.normalize(value);
        if (this._rawValue.ice1 !== normalized) {
            this._rawValue.ice1 = normalized;
            this._updatedValues.ice1 = normalized;
            this.invalidate();
        }
    }
    get ice2(): any { return this._rawValue.ice2; }
    set ice2(value: any) {
        let normalized = this.descriptor.codec.fields.ice2.normalize(value);
        if (this._rawValue.ice2 !== normalized) {
            this._rawValue.ice2 = normalized;
            this._updatedValues.ice2 = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceConnectionFactory extends EntityFactory<ConferenceConnectionShape, ConferenceConnection> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceConnection');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceConnection', 'conference'), condition: (src) => src.state !== 'completed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peer1', type: 'integer' });
        primaryKeys.push({ name: 'peer2', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['wait-offer', 'wait-answer', 'online', 'completed'] }, secure: false });
        fields.push({ name: 'offer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'answer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'ice1', type: { type: 'json' }, secure: false });
        fields.push({ name: 'ice2', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            peer1: c.integer,
            peer2: c.integer,
            cid: c.integer,
            state: c.enum('wait-offer', 'wait-answer', 'online', 'completed'),
            offer: c.optional(c.string),
            answer: c.optional(c.string),
            ice1: c.any,
            ice2: c.any,
        });
        let descriptor: EntityDescriptor<ConferenceConnectionShape> = {
            name: 'ConferenceConnection',
            storageKey: 'conferenceConnection',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceConnectionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceConnectionShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, peer1: number, peer2: number, src: ConferenceConnectionCreateShape): Promise<ConferenceConnection> {
        return this._create(ctx, [peer1, peer2], this.descriptor.codec.normalize({ peer1, peer2, ...src }));
    }

    findById(ctx: Context, peer1: number, peer2: number): Promise<ConferenceConnection | null> {
        return this._findById(ctx, [peer1, peer2]);
    }

    watch(ctx: Context, peer1: number, peer2: number): Watch {
        return this._watch(ctx, [peer1, peer2]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceConnectionShape>): ConferenceConnection {
        return new ConferenceConnection([value.peer1, value.peer2], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserEdgeShape {
    uid1: number;
    uid2: number;
}

export interface UserEdgeCreateShape {
}

export class UserEdge extends Entity<UserEdgeShape> {
    get uid1(): number { return this._rawValue.uid1; }
    get uid2(): number { return this._rawValue.uid2; }
}

export class UserEdgeFactory extends EntityFactory<UserEdgeShape, UserEdge> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userEdge');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'forward', storageKey: 'forward', type: { type: 'range', fields: [{ name: 'uid1', type: 'integer' }, { name: 'uid2', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'forward'), condition: undefined });
        secondaryIndexes.push({ name: 'reverse', storageKey: 'reverse', type: { type: 'range', fields: [{ name: 'uid2', type: 'integer' }, { name: 'uid1', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'reverse'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid1', type: 'integer' });
        primaryKeys.push({ name: 'uid2', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        let codec = c.struct({
            uid1: c.integer,
            uid2: c.integer,
        });
        let descriptor: EntityDescriptor<UserEdgeShape> = {
            name: 'UserEdge',
            storageKey: 'userEdge',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserEdgeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserEdgeShape>) {
        super(descriptor);
    }

    readonly forward = Object.freeze({
        findAll: async (ctx: Context, uid1: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1])).items;
        },
        query: (ctx: Context, uid1: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid1: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid1], opts);
        },
        liveStream: (ctx: Context, uid1: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid1], opts);
        },
    });

    readonly reverse = Object.freeze({
        findAll: async (ctx: Context, uid2: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2])).items;
        },
        query: (ctx: Context, uid2: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid2: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid2], opts);
        },
        liveStream: (ctx: Context, uid2: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid2], opts);
        },
    });

    create(ctx: Context, uid1: number, uid2: number, src: UserEdgeCreateShape): Promise<UserEdge> {
        return this._create(ctx, [uid1, uid2], this.descriptor.codec.normalize({ uid1, uid2, ...src }));
    }

    findById(ctx: Context, uid1: number, uid2: number): Promise<UserEdge | null> {
        return this._findById(ctx, [uid1, uid2]);
    }

    watch(ctx: Context, uid1: number, uid2: number): Watch {
        return this._watch(ctx, [uid1, uid2]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserEdgeShape>): UserEdge {
        return new UserEdge([value.uid1, value.uid2], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserInfluencerUserIndexShape {
    uid: number;
    value: number;
}

export interface UserInfluencerUserIndexCreateShape {
    value: number;
}

export class UserInfluencerUserIndex extends Entity<UserInfluencerUserIndexShape> {
    get uid(): number { return this._rawValue.uid; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserInfluencerUserIndexFactory extends EntityFactory<UserInfluencerUserIndexShape, UserInfluencerUserIndex> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userInfluencerUserIndex');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<UserInfluencerUserIndexShape> = {
            name: 'UserInfluencerUserIndex',
            storageKey: 'userInfluencerUserIndex',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserInfluencerUserIndexFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserInfluencerUserIndexShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserInfluencerUserIndexCreateShape): Promise<UserInfluencerUserIndex> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserInfluencerUserIndex | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserInfluencerUserIndexShape>): UserInfluencerUserIndex {
        return new UserInfluencerUserIndex([value.uid], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserInfluencerIndexShape {
    uid: number;
    value: number;
}

export interface UserInfluencerIndexCreateShape {
    value: number;
}

export class UserInfluencerIndex extends Entity<UserInfluencerIndexShape> {
    get uid(): number { return this._rawValue.uid; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserInfluencerIndexFactory extends EntityFactory<UserInfluencerIndexShape, UserInfluencerIndex> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userInfluencerIndex');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<UserInfluencerIndexShape> = {
            name: 'UserInfluencerIndex',
            storageKey: 'userInfluencerIndex',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserInfluencerIndexFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserInfluencerIndexShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserInfluencerIndexCreateShape): Promise<UserInfluencerIndex> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserInfluencerIndex | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserInfluencerIndexShape>): UserInfluencerIndex {
        return new UserInfluencerIndex([value.uid], value, this.descriptor, this._flush, ctx);
    }
}

export interface FeedSubscriberShape {
    id: number;
    key: string;
}

export interface FeedSubscriberCreateShape {
    key: string;
}

export class FeedSubscriber extends Entity<FeedSubscriberShape> {
    get id(): number { return this._rawValue.id; }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
}

export class FeedSubscriberFactory extends EntityFactory<FeedSubscriberShape, FeedSubscriber> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedSubscriber');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscriber', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            key: c.string,
        });
        let descriptor: EntityDescriptor<FeedSubscriberShape> = {
            name: 'FeedSubscriber',
            storageKey: 'feedSubscriber',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedSubscriberFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedSubscriberShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, key: string) => {
            return this._findFromUniqueIndex(ctx, [key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: number, src: FeedSubscriberCreateShape): Promise<FeedSubscriber> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedSubscriber | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedSubscriberShape>): FeedSubscriber {
        return new FeedSubscriber([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface FeedSubscriptionShape {
    sid: number;
    tid: number;
    enabled: boolean;
}

export interface FeedSubscriptionCreateShape {
    enabled: boolean;
}

export class FeedSubscription extends Entity<FeedSubscriptionShape> {
    get sid(): number { return this._rawValue.sid; }
    get tid(): number { return this._rawValue.tid; }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class FeedSubscriptionFactory extends EntityFactory<FeedSubscriptionShape, FeedSubscription> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedSubscription');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'subscriber', storageKey: 'subscriber', type: { type: 'range', fields: [{ name: 'sid', type: 'integer' }, { name: 'tid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscription', 'subscriber'), condition: (state) => state.enabled });
        secondaryIndexes.push({ name: 'topic', storageKey: 'topic', type: { type: 'range', fields: [{ name: 'tid', type: 'integer' }, { name: 'sid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscription', 'topic'), condition: (state) => state.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'sid', type: 'integer' });
        primaryKeys.push({ name: 'tid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            sid: c.integer,
            tid: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<FeedSubscriptionShape> = {
            name: 'FeedSubscription',
            storageKey: 'feedSubscription',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedSubscriptionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedSubscriptionShape>) {
        super(descriptor);
    }

    readonly subscriber = Object.freeze({
        findAll: async (ctx: Context, sid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [sid])).items;
        },
        query: (ctx: Context, sid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [sid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (sid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [sid], opts);
        },
        liveStream: (ctx: Context, sid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [sid], opts);
        },
    });

    readonly topic = Object.freeze({
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (tid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [tid], opts);
        },
        liveStream: (ctx: Context, tid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [tid], opts);
        },
    });

    create(ctx: Context, sid: number, tid: number, src: FeedSubscriptionCreateShape): Promise<FeedSubscription> {
        return this._create(ctx, [sid, tid], this.descriptor.codec.normalize({ sid, tid, ...src }));
    }

    findById(ctx: Context, sid: number, tid: number): Promise<FeedSubscription | null> {
        return this._findById(ctx, [sid, tid]);
    }

    watch(ctx: Context, sid: number, tid: number): Watch {
        return this._watch(ctx, [sid, tid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedSubscriptionShape>): FeedSubscription {
        return new FeedSubscription([value.sid, value.tid], value, this.descriptor, this._flush, ctx);
    }
}

export interface FeedTopicShape {
    id: number;
    key: string;
}

export interface FeedTopicCreateShape {
    key: string;
}

export class FeedTopic extends Entity<FeedTopicShape> {
    get id(): number { return this._rawValue.id; }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
}

export class FeedTopicFactory extends EntityFactory<FeedTopicShape, FeedTopic> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedTopic');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('feedTopic', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            key: c.string,
        });
        let descriptor: EntityDescriptor<FeedTopicShape> = {
            name: 'FeedTopic',
            storageKey: 'feedTopic',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedTopicFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedTopicShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, key: string) => {
            return this._findFromUniqueIndex(ctx, [key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: number, src: FeedTopicCreateShape): Promise<FeedTopic> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedTopic | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedTopicShape>): FeedTopic {
        return new FeedTopic([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface FeedEventShape {
    id: number;
    tid: number;
    type: string;
    content: any;
}

export interface FeedEventCreateShape {
    tid: number;
    type: string;
    content: any;
}

export class FeedEvent extends Entity<FeedEventShape> {
    get id(): number { return this._rawValue.id; }
    get tid(): number { return this._rawValue.tid; }
    set tid(value: number) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get type(): string { return this._rawValue.type; }
    set type(value: string) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get content(): any { return this._rawValue.content; }
    set content(value: any) {
        let normalized = this.descriptor.codec.fields.content.normalize(value);
        if (this._rawValue.content !== normalized) {
            this._rawValue.content = normalized;
            this._updatedValues.content = normalized;
            this.invalidate();
        }
    }
}

export class FeedEventFactory extends EntityFactory<FeedEventShape, FeedEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'topic', storageKey: 'topic', type: { type: 'range', fields: [{ name: 'tid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'topic'), condition: undefined });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'tid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'type', type: { type: 'string' }, secure: false });
        fields.push({ name: 'content', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            tid: c.integer,
            type: c.string,
            content: c.any,
        });
        let descriptor: EntityDescriptor<FeedEventShape> = {
            name: 'FeedEvent',
            storageKey: 'feedEvent',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedEventShape>) {
        super(descriptor);
    }

    readonly topic = Object.freeze({
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (tid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [tid], opts);
        },
        liveStream: (ctx: Context, tid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [tid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: number, src: FeedEventCreateShape): Promise<FeedEvent> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedEvent | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedEventShape>): FeedEvent {
        return new FeedEvent([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface PushFirebaseShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushFirebaseCreateShape {
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export class PushFirebase extends Entity<PushFirebaseShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get packageId(): string { return this._rawValue.packageId; }
    set packageId(value: string) {
        let normalized = this.descriptor.codec.fields.packageId.normalize(value);
        if (this._rawValue.packageId !== normalized) {
            this._rawValue.packageId = normalized;
            this._updatedValues.packageId = normalized;
            this.invalidate();
        }
    }
    get sandbox(): boolean { return this._rawValue.sandbox; }
    set sandbox(value: boolean) {
        let normalized = this.descriptor.codec.fields.sandbox.normalize(value);
        if (this._rawValue.sandbox !== normalized) {
            this._rawValue.sandbox = normalized;
            this._updatedValues.sandbox = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushFirebaseFactory extends EntityFactory<PushFirebaseShape, PushFirebase> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushFirebase');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushFirebase', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushFirebase', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'packageId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'sandbox', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            packageId: c.string,
            sandbox: c.boolean,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushFirebaseShape> = {
            name: 'PushFirebase',
            storageKey: 'pushFirebase',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushFirebaseFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushFirebaseShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: string, src: PushFirebaseCreateShape): Promise<PushFirebase> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushFirebase | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushFirebaseShape>): PushFirebase {
        return new PushFirebase([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface PushAppleShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushAppleCreateShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export class PushApple extends Entity<PushAppleShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get bundleId(): string { return this._rawValue.bundleId; }
    set bundleId(value: string) {
        let normalized = this.descriptor.codec.fields.bundleId.normalize(value);
        if (this._rawValue.bundleId !== normalized) {
            this._rawValue.bundleId = normalized;
            this._updatedValues.bundleId = normalized;
            this.invalidate();
        }
    }
    get sandbox(): boolean { return this._rawValue.sandbox; }
    set sandbox(value: boolean) {
        let normalized = this.descriptor.codec.fields.sandbox.normalize(value);
        if (this._rawValue.sandbox !== normalized) {
            this._rawValue.sandbox = normalized;
            this._updatedValues.sandbox = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushAppleFactory extends EntityFactory<PushAppleShape, PushApple> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushApple');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushApple', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushApple', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'bundleId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'sandbox', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            bundleId: c.string,
            sandbox: c.boolean,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushAppleShape> = {
            name: 'PushApple',
            storageKey: 'pushApple',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushAppleFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushAppleShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: string, src: PushAppleCreateShape): Promise<PushApple> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushApple | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushAppleShape>): PushApple {
        return new PushApple([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface PushWebShape {
    id: string;
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushWebCreateShape {
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export class PushWeb extends Entity<PushWebShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get endpoint(): string { return this._rawValue.endpoint; }
    set endpoint(value: string) {
        let normalized = this.descriptor.codec.fields.endpoint.normalize(value);
        if (this._rawValue.endpoint !== normalized) {
            this._rawValue.endpoint = normalized;
            this._updatedValues.endpoint = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushWebFactory extends EntityFactory<PushWebShape, PushWeb> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushWeb');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushWeb', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'endpoint', storageKey: 'endpoint', type: { type: 'unique', fields: [{ name: 'endpoint', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushWeb', 'endpoint'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'endpoint', type: { type: 'string' }, secure: true });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            endpoint: c.string,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushWebShape> = {
            name: 'PushWeb',
            storageKey: 'pushWeb',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushWebFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushWebShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly endpoint = Object.freeze({
        find: async (ctx: Context, endpoint: string) => {
            return this._findFromUniqueIndex(ctx, [endpoint], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: string, src: PushWebCreateShape): Promise<PushWeb> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushWeb | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushWebShape>): PushWeb {
        return new PushWeb([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface PushSafariShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushSafariCreateShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export class PushSafari extends Entity<PushSafariShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get bundleId(): string { return this._rawValue.bundleId; }
    set bundleId(value: string) {
        let normalized = this.descriptor.codec.fields.bundleId.normalize(value);
        if (this._rawValue.bundleId !== normalized) {
            this._rawValue.bundleId = normalized;
            this._updatedValues.bundleId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushSafariFactory extends EntityFactory<PushSafariShape, PushSafari> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushSafari');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushSafari', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushSafari', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'bundleId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            bundleId: c.string,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushSafariShape> = {
            name: 'PushSafari',
            storageKey: 'pushSafari',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushSafariFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushSafariShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: string, src: PushSafariCreateShape): Promise<PushSafari> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushSafari | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushSafariShape>): PushSafari {
        return new PushSafari([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserStorageNamespaceShape {
    id: number;
    ns: string;
}

export interface UserStorageNamespaceCreateShape {
    ns: string;
}

export class UserStorageNamespace extends Entity<UserStorageNamespaceShape> {
    get id(): number { return this._rawValue.id; }
    get ns(): string { return this._rawValue.ns; }
    set ns(value: string) {
        let normalized = this.descriptor.codec.fields.ns.normalize(value);
        if (this._rawValue.ns !== normalized) {
            this._rawValue.ns = normalized;
            this._updatedValues.ns = normalized;
            this.invalidate();
        }
    }
}

export class UserStorageNamespaceFactory extends EntityFactory<UserStorageNamespaceShape, UserStorageNamespace> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStorageNamespace');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'namespace', storageKey: 'namespace', type: { type: 'unique', fields: [{ name: 'ns', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStorageNamespace', 'namespace'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ns', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ns: c.string,
        });
        let descriptor: EntityDescriptor<UserStorageNamespaceShape> = {
            name: 'UserStorageNamespace',
            storageKey: 'userStorageNamespace',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStorageNamespaceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStorageNamespaceShape>) {
        super(descriptor);
    }

    readonly namespace = Object.freeze({
        find: async (ctx: Context, ns: string) => {
            return this._findFromUniqueIndex(ctx, [ns], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: number, src: UserStorageNamespaceCreateShape): Promise<UserStorageNamespace> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserStorageNamespace | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStorageNamespaceShape>): UserStorageNamespace {
        return new UserStorageNamespace([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface UserStorageRecordShape {
    uid: number;
    id: number;
    ns: number;
    key: string;
    value: string | null;
}

export interface UserStorageRecordCreateShape {
    ns: number;
    key: string;
    value: string | null;
}

export class UserStorageRecord extends Entity<UserStorageRecordShape> {
    get uid(): number { return this._rawValue.uid; }
    get id(): number { return this._rawValue.id; }
    get ns(): number { return this._rawValue.ns; }
    set ns(value: number) {
        let normalized = this.descriptor.codec.fields.ns.normalize(value);
        if (this._rawValue.ns !== normalized) {
            this._rawValue.ns = normalized;
            this._updatedValues.ns = normalized;
            this.invalidate();
        }
    }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
    get value(): string | null { return this._rawValue.value; }
    set value(value: string | null) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserStorageRecordFactory extends EntityFactory<UserStorageRecordShape, UserStorageRecord> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStorageRecord');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'ns', type: 'integer' }, { name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStorageRecord', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ns', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        fields.push({ name: 'value', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            id: c.integer,
            ns: c.integer,
            key: c.string,
            value: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserStorageRecordShape> = {
            name: 'UserStorageRecord',
            storageKey: 'userStorageRecord',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStorageRecordFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStorageRecordShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, uid: number, ns: number, key: string) => {
            return this._findFromUniqueIndex(ctx, [uid, ns, key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, uid: number, ns: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid, ns])).items;
        },
        query: (ctx: Context, uid: number, ns: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid, ns], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, uid: number, id: number, src: UserStorageRecordCreateShape): Promise<UserStorageRecord> {
        return this._create(ctx, [uid, id], this.descriptor.codec.normalize({ uid, id, ...src }));
    }

    findById(ctx: Context, uid: number, id: number): Promise<UserStorageRecord | null> {
        return this._findById(ctx, [uid, id]);
    }

    watch(ctx: Context, uid: number, id: number): Watch {
        return this._watch(ctx, [uid, id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStorageRecordShape>): UserStorageRecord {
        return new UserStorageRecord([value.uid, value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface SequenceShape {
    sequence: string;
    value: number;
}

export interface SequenceCreateShape {
    value: number;
}

export class Sequence extends Entity<SequenceShape> {
    get sequence(): string { return this._rawValue.sequence; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class SequenceFactory extends EntityFactory<SequenceShape, Sequence> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('sequence');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'sequence', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            sequence: c.string,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<SequenceShape> = {
            name: 'Sequence',
            storageKey: 'sequence',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SequenceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SequenceShape>) {
        super(descriptor);
    }

    create(ctx: Context, sequence: string, src: SequenceCreateShape): Promise<Sequence> {
        return this._create(ctx, [sequence], this.descriptor.codec.normalize({ sequence, ...src }));
    }

    findById(ctx: Context, sequence: string): Promise<Sequence | null> {
        return this._findById(ctx, [sequence]);
    }

    watch(ctx: Context, sequence: string): Watch {
        return this._watch(ctx, [sequence]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SequenceShape>): Sequence {
        return new Sequence([value.sequence], value, this.descriptor, this._flush, ctx);
    }
}

export interface EnvironmentShape {
    production: number;
    comment: string;
}

export interface EnvironmentCreateShape {
    comment: string;
}

export class Environment extends Entity<EnvironmentShape> {
    get production(): number { return this._rawValue.production; }
    get comment(): string { return this._rawValue.comment; }
    set comment(value: string) {
        let normalized = this.descriptor.codec.fields.comment.normalize(value);
        if (this._rawValue.comment !== normalized) {
            this._rawValue.comment = normalized;
            this._updatedValues.comment = normalized;
            this.invalidate();
        }
    }
}

export class EnvironmentFactory extends EntityFactory<EnvironmentShape, Environment> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('environment');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'production', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'comment', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            production: c.integer,
            comment: c.string,
        });
        let descriptor: EntityDescriptor<EnvironmentShape> = {
            name: 'Environment',
            storageKey: 'environment',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EnvironmentFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EnvironmentShape>) {
        super(descriptor);
    }

    create(ctx: Context, production: number, src: EnvironmentCreateShape): Promise<Environment> {
        return this._create(ctx, [production], this.descriptor.codec.normalize({ production, ...src }));
    }

    findById(ctx: Context, production: number): Promise<Environment | null> {
        return this._findById(ctx, [production]);
    }

    watch(ctx: Context, production: number): Watch {
        return this._watch(ctx, [production]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EnvironmentShape>): Environment {
        return new Environment([value.production], value, this.descriptor, this._flush, ctx);
    }
}

export interface EnvironmentVariableShape {
    name: string;
    value: string;
}

export interface EnvironmentVariableCreateShape {
    value: string;
}

export class EnvironmentVariable extends Entity<EnvironmentVariableShape> {
    get name(): string { return this._rawValue.name; }
    get value(): string { return this._rawValue.value; }
    set value(value: string) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class EnvironmentVariableFactory extends EntityFactory<EnvironmentVariableShape, EnvironmentVariable> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('environmentVariable');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'name', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            name: c.string,
            value: c.string,
        });
        let descriptor: EntityDescriptor<EnvironmentVariableShape> = {
            name: 'EnvironmentVariable',
            storageKey: 'environmentVariable',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EnvironmentVariableFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EnvironmentVariableShape>) {
        super(descriptor);
    }

    create(ctx: Context, name: string, src: EnvironmentVariableCreateShape): Promise<EnvironmentVariable> {
        return this._create(ctx, [name], this.descriptor.codec.normalize({ name, ...src }));
    }

    findById(ctx: Context, name: string): Promise<EnvironmentVariable | null> {
        return this._findById(ctx, [name]);
    }

    watch(ctx: Context, name: string): Watch {
        return this._watch(ctx, [name]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EnvironmentVariableShape>): EnvironmentVariable {
        return new EnvironmentVariable([value.name], value, this.descriptor, this._flush, ctx);
    }
}

export interface ServiceCacheShape {
    service: string;
    key: string;
    value: string | null;
}

export interface ServiceCacheCreateShape {
    value: string | null;
}

export class ServiceCache extends Entity<ServiceCacheShape> {
    get service(): string { return this._rawValue.service; }
    get key(): string { return this._rawValue.key; }
    get value(): string | null { return this._rawValue.value; }
    set value(value: string | null) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class ServiceCacheFactory extends EntityFactory<ServiceCacheShape, ServiceCache> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('serviceCache');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromService', storageKey: 'fromService', type: { type: 'range', fields: [{ name: 'service', type: 'string' }, { name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('serviceCache', 'fromService'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'service', type: 'string' });
        primaryKeys.push({ name: 'key', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            service: c.string,
            key: c.string,
            value: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<ServiceCacheShape> = {
            name: 'ServiceCache',
            storageKey: 'serviceCache',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ServiceCacheFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ServiceCacheShape>) {
        super(descriptor);
    }

    readonly fromService = Object.freeze({
        findAll: async (ctx: Context, service: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [service])).items;
        },
        query: (ctx: Context, service: string, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [service], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (service: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [service], opts);
        },
        liveStream: (ctx: Context, service: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [service], opts);
        },
    });

    create(ctx: Context, service: string, key: string, src: ServiceCacheCreateShape): Promise<ServiceCache> {
        return this._create(ctx, [service, key], this.descriptor.codec.normalize({ service, key, ...src }));
    }

    findById(ctx: Context, service: string, key: string): Promise<ServiceCache | null> {
        return this._findById(ctx, [service, key]);
    }

    watch(ctx: Context, service: string, key: string): Watch {
        return this._watch(ctx, [service, key]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ServiceCacheShape>): ServiceCache {
        return new ServiceCache([value.service, value.key], value, this.descriptor, this._flush, ctx);
    }
}

export interface ReaderStateShape {
    id: string;
    cursor: string;
    version: number | null;
}

export interface ReaderStateCreateShape {
    cursor: string;
    version: number | null;
}

export class ReaderState extends Entity<ReaderStateShape> {
    get id(): string { return this._rawValue.id; }
    get cursor(): string { return this._rawValue.cursor; }
    set cursor(value: string) {
        let normalized = this.descriptor.codec.fields.cursor.normalize(value);
        if (this._rawValue.cursor !== normalized) {
            this._rawValue.cursor = normalized;
            this._updatedValues.cursor = normalized;
            this.invalidate();
        }
    }
    get version(): number | null { return this._rawValue.version; }
    set version(value: number | null) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
}

export class ReaderStateFactory extends EntityFactory<ReaderStateShape, ReaderState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('readerState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cursor', type: { type: 'string' }, secure: false });
        fields.push({ name: 'version', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            cursor: c.string,
            version: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<ReaderStateShape> = {
            name: 'ReaderState',
            storageKey: 'readerState',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ReaderStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ReaderStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: ReaderStateCreateShape): Promise<ReaderState> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ReaderState | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ReaderStateShape>): ReaderState {
        return new ReaderState([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface SuperAdminShape {
    id: number;
    role: string;
    enabled: boolean;
}

export interface SuperAdminCreateShape {
    role: string;
    enabled: boolean;
}

export class SuperAdmin extends Entity<SuperAdminShape> {
    get id(): number { return this._rawValue.id; }
    get role(): string { return this._rawValue.role; }
    set role(value: string) {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class SuperAdminFactory extends EntityFactory<SuperAdminShape, SuperAdmin> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('superAdmin');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'role', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            role: c.string,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<SuperAdminShape> = {
            name: 'SuperAdmin',
            storageKey: 'superAdmin',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SuperAdminFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SuperAdminShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: SuperAdminCreateShape): Promise<SuperAdmin> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<SuperAdmin | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SuperAdminShape>): SuperAdmin {
        return new SuperAdmin([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface AuthTokenShape {
    uuid: string;
    salt: string;
    uid: number;
    lastIp: string;
    enabled: boolean | null;
}

export interface AuthTokenCreateShape {
    salt: string;
    uid: number;
    lastIp: string;
    enabled: boolean | null;
}

export class AuthToken extends Entity<AuthTokenShape> {
    get uuid(): string { return this._rawValue.uuid; }
    get salt(): string { return this._rawValue.salt; }
    set salt(value: string) {
        let normalized = this.descriptor.codec.fields.salt.normalize(value);
        if (this._rawValue.salt !== normalized) {
            this._rawValue.salt = normalized;
            this._updatedValues.salt = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get lastIp(): string { return this._rawValue.lastIp; }
    set lastIp(value: string) {
        let normalized = this.descriptor.codec.fields.lastIp.normalize(value);
        if (this._rawValue.lastIp !== normalized) {
            this._rawValue.lastIp = normalized;
            this._updatedValues.lastIp = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class AuthTokenFactory extends EntityFactory<AuthTokenShape, AuthToken> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('authToken');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'salt', storageKey: 'salt', type: { type: 'unique', fields: [{ name: 'salt', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('authToken', 'salt'), condition: undefined });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'uuid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('authToken', 'user'), condition: src => src.enabled !== false });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uuid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'salt', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'lastIp', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uuid: c.string,
            salt: c.string,
            uid: c.integer,
            lastIp: c.string,
            enabled: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<AuthTokenShape> = {
            name: 'AuthToken',
            storageKey: 'authToken',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AuthTokenFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AuthTokenShape>) {
        super(descriptor);
    }

    readonly salt = Object.freeze({
        find: async (ctx: Context, salt: string) => {
            return this._findFromUniqueIndex(ctx, [salt], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, uuid: string, src: AuthTokenCreateShape): Promise<AuthToken> {
        return this._create(ctx, [uuid], this.descriptor.codec.normalize({ uuid, ...src }));
    }

    findById(ctx: Context, uuid: string): Promise<AuthToken | null> {
        return this._findById(ctx, [uuid]);
    }

    watch(ctx: Context, uuid: string): Watch {
        return this._watch(ctx, [uuid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AuthTokenShape>): AuthToken {
        return new AuthToken([value.uuid], value, this.descriptor, this._flush, ctx);
    }
}

export interface AuthCodeSessionShape {
    uid: string;
    code: string;
    expires: number;
    email: string;
    tokenId: string | null;
    enabled: boolean;
}

export interface AuthCodeSessionCreateShape {
    code: string;
    expires: number;
    email: string;
    tokenId: string | null;
    enabled: boolean;
}

export class AuthCodeSession extends Entity<AuthCodeSessionShape> {
    get uid(): string { return this._rawValue.uid; }
    get code(): string { return this._rawValue.code; }
    set code(value: string) {
        let normalized = this.descriptor.codec.fields.code.normalize(value);
        if (this._rawValue.code !== normalized) {
            this._rawValue.code = normalized;
            this._updatedValues.code = normalized;
            this.invalidate();
        }
    }
    get expires(): number { return this._rawValue.expires; }
    set expires(value: number) {
        let normalized = this.descriptor.codec.fields.expires.normalize(value);
        if (this._rawValue.expires !== normalized) {
            this._rawValue.expires = normalized;
            this._updatedValues.expires = normalized;
            this.invalidate();
        }
    }
    get email(): string { return this._rawValue.email; }
    set email(value: string) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get tokenId(): string | null { return this._rawValue.tokenId; }
    set tokenId(value: string | null) {
        let normalized = this.descriptor.codec.fields.tokenId.normalize(value);
        if (this._rawValue.tokenId !== normalized) {
            this._rawValue.tokenId = normalized;
            this._updatedValues.tokenId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class AuthCodeSessionFactory extends EntityFactory<AuthCodeSessionShape, AuthCodeSession> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('authCodeSession');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'code', type: { type: 'string' }, secure: true });
        fields.push({ name: 'expires', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'email', type: { type: 'string' }, secure: false });
        fields.push({ name: 'tokenId', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.string,
            code: c.string,
            expires: c.integer,
            email: c.string,
            tokenId: c.optional(c.string),
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<AuthCodeSessionShape> = {
            name: 'AuthCodeSession',
            storageKey: 'authCodeSession',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AuthCodeSessionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AuthCodeSessionShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: string, src: AuthCodeSessionCreateShape): Promise<AuthCodeSession> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: string): Promise<AuthCodeSession | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: string): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AuthCodeSessionShape>): AuthCodeSession {
        return new AuthCodeSession([value.uid], value, this.descriptor, this._flush, ctx);
    }
}

export interface FeatureFlagShape {
    key: string;
    title: string;
}

export interface FeatureFlagCreateShape {
    title: string;
}

export class FeatureFlag extends Entity<FeatureFlagShape> {
    get key(): string { return this._rawValue.key; }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
}

export class FeatureFlagFactory extends EntityFactory<FeatureFlagShape, FeatureFlag> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('featureFlag');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'key', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            key: c.string,
            title: c.string,
        });
        let descriptor: EntityDescriptor<FeatureFlagShape> = {
            name: 'FeatureFlag',
            storageKey: 'featureFlag',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeatureFlagFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeatureFlagShape>) {
        super(descriptor);
    }

    create(ctx: Context, key: string, src: FeatureFlagCreateShape): Promise<FeatureFlag> {
        return this._create(ctx, [key], this.descriptor.codec.normalize({ key, ...src }));
    }

    findById(ctx: Context, key: string): Promise<FeatureFlag | null> {
        return this._findById(ctx, [key]);
    }

    watch(ctx: Context, key: string): Watch {
        return this._watch(ctx, [key]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeatureFlagShape>): FeatureFlag {
        return new FeatureFlag([value.key], value, this.descriptor, this._flush, ctx);
    }
}

export interface OrganizationFeaturesShape {
    id: string;
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export interface OrganizationFeaturesCreateShape {
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export class OrganizationFeatures extends Entity<OrganizationFeaturesShape> {
    get id(): string { return this._rawValue.id; }
    get featureKey(): string { return this._rawValue.featureKey; }
    set featureKey(value: string) {
        let normalized = this.descriptor.codec.fields.featureKey.normalize(value);
        if (this._rawValue.featureKey !== normalized) {
            this._rawValue.featureKey = normalized;
            this._updatedValues.featureKey = normalized;
            this.invalidate();
        }
    }
    get organizationId(): number { return this._rawValue.organizationId; }
    set organizationId(value: number) {
        let normalized = this.descriptor.codec.fields.organizationId.normalize(value);
        if (this._rawValue.organizationId !== normalized) {
            this._rawValue.organizationId = normalized;
            this._updatedValues.organizationId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationFeaturesFactory extends EntityFactory<OrganizationFeaturesShape, OrganizationFeatures> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationFeatures');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'unique', fields: [{ name: 'organizationId', type: 'integer' }, { name: 'featureKey', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationFeatures', 'organization'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'featureKey', type: { type: 'string' }, secure: false });
        fields.push({ name: 'organizationId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            featureKey: c.string,
            organizationId: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<OrganizationFeaturesShape> = {
            name: 'OrganizationFeatures',
            storageKey: 'organizationFeatures',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationFeaturesFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationFeaturesShape>) {
        super(descriptor);
    }

    readonly organization = Object.freeze({
        find: async (ctx: Context, organizationId: number, featureKey: string) => {
            return this._findFromUniqueIndex(ctx, [organizationId, featureKey], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, organizationId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [organizationId])).items;
        },
        query: (ctx: Context, organizationId: number, opts?: RangeOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [organizationId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined});
        },
    });

    create(ctx: Context, id: string, src: OrganizationFeaturesCreateShape): Promise<OrganizationFeatures> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<OrganizationFeatures | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationFeaturesShape>): OrganizationFeatures {
        return new OrganizationFeatures([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface Store extends BaseStore {
    readonly UserCounter: UserCounterFactory;
    readonly UserMessagesSentCounter: UserMessagesSentCounterFactory;
    readonly UserMessagesSentInDirectChatTotalCounter: UserMessagesSentInDirectChatTotalCounterFactory;
    readonly UserMessagesReceivedCounter: UserMessagesReceivedCounterFactory;
    readonly UserMessagesChatsCounter: UserMessagesChatsCounterFactory;
    readonly UserMessagesDirectChatsCounter: UserMessagesDirectChatsCounterFactory;
    readonly UserSuccessfulInvitesCounter: UserSuccessfulInvitesCounterFactory;
    readonly UserEmailSentCounter: UserEmailSentCounterFactory;
    readonly UserDialogCounter: UserDialogCounterFactory;
    readonly UserDialogHaveMention: UserDialogHaveMentionFactory;
    readonly NotificationCenterCounter: NotificationCenterCounterFactory;
    readonly UserAudienceCounter: UserAudienceCounterFactory;
    readonly UserMessagesSentInDirectChatCounter: UserMessagesSentInDirectChatCounterFactory;
    readonly User2WayDirectChatsCounter: User2WayDirectChatsCounterFactory;
    readonly GlobalStatisticsCounters: GlobalStatisticsCountersFactory;
    readonly UserGlobalCounterAllUnreadMessages: UserGlobalCounterAllUnreadMessagesFactory;
    readonly UserGlobalCounterUnreadMessagesWithoutMuted: UserGlobalCounterUnreadMessagesWithoutMutedFactory;
    readonly UserGlobalCounterAllUnreadChats: UserGlobalCounterAllUnreadChatsFactory;
    readonly UserGlobalCounterUnreadChatsWithoutMuted: UserGlobalCounterUnreadChatsWithoutMutedFactory;
    readonly User: UserFactory;
    readonly UserProfile: UserProfileFactory;
    readonly UserProfilePrefil: UserProfilePrefilFactory;
    readonly UserSettings: UserSettingsFactory;
    readonly Organization: OrganizationFactory;
    readonly OrganizationProfile: OrganizationProfileFactory;
    readonly OrganizationEditorial: OrganizationEditorialFactory;
    readonly OrganizationMember: OrganizationMemberFactory;
    readonly Online: OnlineFactory;
    readonly Presence: PresenceFactory;
    readonly MessageDraft: MessageDraftFactory;
    readonly ConferenceRoom: ConferenceRoomFactory;
    readonly ConferencePeer: ConferencePeerFactory;
    readonly ConferenceMediaStream: ConferenceMediaStreamFactory;
    readonly ConferenceConnection: ConferenceConnectionFactory;
    readonly UserEdge: UserEdgeFactory;
    readonly UserInfluencerUserIndex: UserInfluencerUserIndexFactory;
    readonly UserInfluencerIndex: UserInfluencerIndexFactory;
    readonly FeedSubscriber: FeedSubscriberFactory;
    readonly FeedSubscription: FeedSubscriptionFactory;
    readonly FeedTopic: FeedTopicFactory;
    readonly FeedEvent: FeedEventFactory;
    readonly PushFirebase: PushFirebaseFactory;
    readonly PushApple: PushAppleFactory;
    readonly PushWeb: PushWebFactory;
    readonly PushSafari: PushSafariFactory;
    readonly UserStorageNamespace: UserStorageNamespaceFactory;
    readonly UserStorageRecord: UserStorageRecordFactory;
    readonly Sequence: SequenceFactory;
    readonly Environment: EnvironmentFactory;
    readonly EnvironmentVariable: EnvironmentVariableFactory;
    readonly ServiceCache: ServiceCacheFactory;
    readonly ReaderState: ReaderStateFactory;
    readonly SuperAdmin: SuperAdminFactory;
    readonly AuthToken: AuthTokenFactory;
    readonly AuthCodeSession: AuthCodeSessionFactory;
    readonly FeatureFlag: FeatureFlagFactory;
    readonly OrganizationFeatures: OrganizationFeaturesFactory;
}

export async function openStore(storage: EntityStorage): Promise<Store> {
    let UserCounterPromise = UserCounterFactory.open(storage);
    let UserMessagesSentCounterPromise = UserMessagesSentCounterFactory.open(storage);
    let UserMessagesSentInDirectChatTotalCounterPromise = UserMessagesSentInDirectChatTotalCounterFactory.open(storage);
    let UserMessagesReceivedCounterPromise = UserMessagesReceivedCounterFactory.open(storage);
    let UserMessagesChatsCounterPromise = UserMessagesChatsCounterFactory.open(storage);
    let UserMessagesDirectChatsCounterPromise = UserMessagesDirectChatsCounterFactory.open(storage);
    let UserSuccessfulInvitesCounterPromise = UserSuccessfulInvitesCounterFactory.open(storage);
    let UserEmailSentCounterPromise = UserEmailSentCounterFactory.open(storage);
    let UserDialogCounterPromise = UserDialogCounterFactory.open(storage);
    let UserDialogHaveMentionPromise = UserDialogHaveMentionFactory.open(storage);
    let NotificationCenterCounterPromise = NotificationCenterCounterFactory.open(storage);
    let UserAudienceCounterPromise = UserAudienceCounterFactory.open(storage);
    let UserMessagesSentInDirectChatCounterPromise = UserMessagesSentInDirectChatCounterFactory.open(storage);
    let User2WayDirectChatsCounterPromise = User2WayDirectChatsCounterFactory.open(storage);
    let GlobalStatisticsCountersPromise = GlobalStatisticsCountersFactory.open(storage);
    let UserGlobalCounterAllUnreadMessagesPromise = UserGlobalCounterAllUnreadMessagesFactory.open(storage);
    let UserGlobalCounterUnreadMessagesWithoutMutedPromise = UserGlobalCounterUnreadMessagesWithoutMutedFactory.open(storage);
    let UserGlobalCounterAllUnreadChatsPromise = UserGlobalCounterAllUnreadChatsFactory.open(storage);
    let UserGlobalCounterUnreadChatsWithoutMutedPromise = UserGlobalCounterUnreadChatsWithoutMutedFactory.open(storage);
    let UserPromise = UserFactory.open(storage);
    let UserProfilePromise = UserProfileFactory.open(storage);
    let UserProfilePrefilPromise = UserProfilePrefilFactory.open(storage);
    let UserSettingsPromise = UserSettingsFactory.open(storage);
    let OrganizationPromise = OrganizationFactory.open(storage);
    let OrganizationProfilePromise = OrganizationProfileFactory.open(storage);
    let OrganizationEditorialPromise = OrganizationEditorialFactory.open(storage);
    let OrganizationMemberPromise = OrganizationMemberFactory.open(storage);
    let OnlinePromise = OnlineFactory.open(storage);
    let PresencePromise = PresenceFactory.open(storage);
    let MessageDraftPromise = MessageDraftFactory.open(storage);
    let ConferenceRoomPromise = ConferenceRoomFactory.open(storage);
    let ConferencePeerPromise = ConferencePeerFactory.open(storage);
    let ConferenceMediaStreamPromise = ConferenceMediaStreamFactory.open(storage);
    let ConferenceConnectionPromise = ConferenceConnectionFactory.open(storage);
    let UserEdgePromise = UserEdgeFactory.open(storage);
    let UserInfluencerUserIndexPromise = UserInfluencerUserIndexFactory.open(storage);
    let UserInfluencerIndexPromise = UserInfluencerIndexFactory.open(storage);
    let FeedSubscriberPromise = FeedSubscriberFactory.open(storage);
    let FeedSubscriptionPromise = FeedSubscriptionFactory.open(storage);
    let FeedTopicPromise = FeedTopicFactory.open(storage);
    let FeedEventPromise = FeedEventFactory.open(storage);
    let PushFirebasePromise = PushFirebaseFactory.open(storage);
    let PushApplePromise = PushAppleFactory.open(storage);
    let PushWebPromise = PushWebFactory.open(storage);
    let PushSafariPromise = PushSafariFactory.open(storage);
    let UserStorageNamespacePromise = UserStorageNamespaceFactory.open(storage);
    let UserStorageRecordPromise = UserStorageRecordFactory.open(storage);
    let SequencePromise = SequenceFactory.open(storage);
    let EnvironmentPromise = EnvironmentFactory.open(storage);
    let EnvironmentVariablePromise = EnvironmentVariableFactory.open(storage);
    let ServiceCachePromise = ServiceCacheFactory.open(storage);
    let ReaderStatePromise = ReaderStateFactory.open(storage);
    let SuperAdminPromise = SuperAdminFactory.open(storage);
    let AuthTokenPromise = AuthTokenFactory.open(storage);
    let AuthCodeSessionPromise = AuthCodeSessionFactory.open(storage);
    let FeatureFlagPromise = FeatureFlagFactory.open(storage);
    let OrganizationFeaturesPromise = OrganizationFeaturesFactory.open(storage);
    return {
        storage,
        UserCounter: await UserCounterPromise,
        UserMessagesSentCounter: await UserMessagesSentCounterPromise,
        UserMessagesSentInDirectChatTotalCounter: await UserMessagesSentInDirectChatTotalCounterPromise,
        UserMessagesReceivedCounter: await UserMessagesReceivedCounterPromise,
        UserMessagesChatsCounter: await UserMessagesChatsCounterPromise,
        UserMessagesDirectChatsCounter: await UserMessagesDirectChatsCounterPromise,
        UserSuccessfulInvitesCounter: await UserSuccessfulInvitesCounterPromise,
        UserEmailSentCounter: await UserEmailSentCounterPromise,
        UserDialogCounter: await UserDialogCounterPromise,
        UserDialogHaveMention: await UserDialogHaveMentionPromise,
        NotificationCenterCounter: await NotificationCenterCounterPromise,
        UserAudienceCounter: await UserAudienceCounterPromise,
        UserMessagesSentInDirectChatCounter: await UserMessagesSentInDirectChatCounterPromise,
        User2WayDirectChatsCounter: await User2WayDirectChatsCounterPromise,
        GlobalStatisticsCounters: await GlobalStatisticsCountersPromise,
        UserGlobalCounterAllUnreadMessages: await UserGlobalCounterAllUnreadMessagesPromise,
        UserGlobalCounterUnreadMessagesWithoutMuted: await UserGlobalCounterUnreadMessagesWithoutMutedPromise,
        UserGlobalCounterAllUnreadChats: await UserGlobalCounterAllUnreadChatsPromise,
        UserGlobalCounterUnreadChatsWithoutMuted: await UserGlobalCounterUnreadChatsWithoutMutedPromise,
        User: await UserPromise,
        UserProfile: await UserProfilePromise,
        UserProfilePrefil: await UserProfilePrefilPromise,
        UserSettings: await UserSettingsPromise,
        Organization: await OrganizationPromise,
        OrganizationProfile: await OrganizationProfilePromise,
        OrganizationEditorial: await OrganizationEditorialPromise,
        OrganizationMember: await OrganizationMemberPromise,
        Online: await OnlinePromise,
        Presence: await PresencePromise,
        MessageDraft: await MessageDraftPromise,
        ConferenceRoom: await ConferenceRoomPromise,
        ConferencePeer: await ConferencePeerPromise,
        ConferenceMediaStream: await ConferenceMediaStreamPromise,
        ConferenceConnection: await ConferenceConnectionPromise,
        UserEdge: await UserEdgePromise,
        UserInfluencerUserIndex: await UserInfluencerUserIndexPromise,
        UserInfluencerIndex: await UserInfluencerIndexPromise,
        FeedSubscriber: await FeedSubscriberPromise,
        FeedSubscription: await FeedSubscriptionPromise,
        FeedTopic: await FeedTopicPromise,
        FeedEvent: await FeedEventPromise,
        PushFirebase: await PushFirebasePromise,
        PushApple: await PushApplePromise,
        PushWeb: await PushWebPromise,
        PushSafari: await PushSafariPromise,
        UserStorageNamespace: await UserStorageNamespacePromise,
        UserStorageRecord: await UserStorageRecordPromise,
        Sequence: await SequencePromise,
        Environment: await EnvironmentPromise,
        EnvironmentVariable: await EnvironmentVariablePromise,
        ServiceCache: await ServiceCachePromise,
        ReaderState: await ReaderStatePromise,
        SuperAdmin: await SuperAdminPromise,
        AuthToken: await AuthTokenPromise,
        AuthCodeSession: await AuthCodeSessionPromise,
        FeatureFlag: await FeatureFlagPromise,
        OrganizationFeatures: await OrganizationFeaturesPromise,
    };
}
