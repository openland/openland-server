// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { Subspace, Watch } from '@openland/foundationdb';
// @ts-ignore
import { EntityStorage, EventStore, EventStoreDescriptor, EventFactory, BaseStore, RangeQueryOptions, BaseEvent, codecs as c } from '@openland/foundationdb-entity';
// @ts-ignore
import { AtomicIntegerFactory, AtomicBooleanFactory } from '@openland/foundationdb-entity';
// @ts-ignore
import { Entity, EntityFactory, EntityDescriptor, SecondaryIndexDescriptor, ShapeWithMetadata, PrimaryKeyDescriptor, FieldDescriptor, StreamProps } from '@openland/foundationdb-entity';
// @ts-ignore
import { QueueStorage } from 'openland-module-workers/QueueStorage';

export class ConversationLastSeqFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('conversationLastSeq');
        return new ConversationLastSeqFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(cid: number) {
        return this._findById([cid]);
    }

    get(ctx: Context, cid: number) {
        return this._get(ctx, [cid]);
    }

    set(ctx: Context, cid: number, value: number) {
        return this._set(ctx, [cid], value);
    }

    add(ctx: Context, cid: number, value: number) {
        return this._add(ctx, [cid], value);
    }

    increment(ctx: Context, cid: number) {
        return this._increment(ctx, [cid]);
    }

    decrement(ctx: Context, cid: number) {
        return this._decrement(ctx, [cid]);
    }
}

export class RoomParticipantsVersionFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('roomParticipantsVersion');
        return new RoomParticipantsVersionFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(cid: number) {
        return this._findById([cid]);
    }

    get(ctx: Context, cid: number) {
        return this._get(ctx, [cid]);
    }

    set(ctx: Context, cid: number, value: number) {
        return this._set(ctx, [cid], value);
    }

    add(ctx: Context, cid: number, value: number) {
        return this._add(ctx, [cid], value);
    }

    increment(ctx: Context, cid: number) {
        return this._increment(ctx, [cid]);
    }

    decrement(ctx: Context, cid: number) {
        return this._decrement(ctx, [cid]);
    }
}

export class UserDialogReadMessageIdFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userDialogReadMessageId');
        return new UserDialogReadMessageIdFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: number) {
        return this._set(ctx, [uid, cid], value);
    }

    add(ctx: Context, uid: number, cid: number, value: number) {
        return this._add(ctx, [uid, cid], value);
    }

    increment(ctx: Context, uid: number, cid: number) {
        return this._increment(ctx, [uid, cid]);
    }

    decrement(ctx: Context, uid: number, cid: number) {
        return this._decrement(ctx, [uid, cid]);
    }
}

export class FeedChannelMembersCountFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('feedChannelMembersCount');
        return new FeedChannelMembersCountFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(channelId: number) {
        return this._findById([channelId]);
    }

    get(ctx: Context, channelId: number) {
        return this._get(ctx, [channelId]);
    }

    set(ctx: Context, channelId: number, value: number) {
        return this._set(ctx, [channelId], value);
    }

    add(ctx: Context, channelId: number, value: number) {
        return this._add(ctx, [channelId], value);
    }

    increment(ctx: Context, channelId: number) {
        return this._increment(ctx, [channelId]);
    }

    decrement(ctx: Context, channelId: number) {
        return this._decrement(ctx, [channelId]);
    }
}

export class FeedChannelPostsCountFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('feedChannelPostsCount');
        return new FeedChannelPostsCountFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(channelId: number) {
        return this._findById([channelId]);
    }

    get(ctx: Context, channelId: number) {
        return this._get(ctx, [channelId]);
    }

    set(ctx: Context, channelId: number, value: number) {
        return this._set(ctx, [channelId], value);
    }

    add(ctx: Context, channelId: number, value: number) {
        return this._add(ctx, [channelId], value);
    }

    increment(ctx: Context, channelId: number) {
        return this._increment(ctx, [channelId]);
    }

    decrement(ctx: Context, channelId: number) {
        return this._decrement(ctx, [channelId]);
    }
}

export class UserCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userCounter');
        return new UserCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentCounter');
        return new UserMessagesSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentWeeklyCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentWeeklyCounter');
        return new UserMessagesSentWeeklyCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentInDirectChatTotalCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentInDirectChatTotalCounter');
        return new UserMessagesSentInDirectChatTotalCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesReceivedCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesReceivedCounter');
        return new UserMessagesReceivedCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesChatsCounter');
        return new UserMessagesChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesChannelsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesChannelsCounter');
        return new UserMessagesChannelsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesDirectChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesDirectChatsCounter');
        return new UserMessagesDirectChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserSuccessfulInvitesCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userSuccessfulInvitesCounter');
        return new UserSuccessfulInvitesCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserSuccessfulInvitesPrevWeekCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userSuccessfulInvitesPrevWeekCounter');
        return new UserSuccessfulInvitesPrevWeekCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserEmailSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userEmailSentCounter');
        return new UserEmailSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserBrowserPushSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userBrowserPushSentCounter');
        return new UserBrowserPushSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMobilePushSentCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMobilePushSentCounter');
        return new UserMobilePushSentCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserEmailSentWeeklyCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userEmailSentWeeklyCounter');
        return new UserEmailSentWeeklyCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserBrowserPushSentWeeklyCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userBrowserPushSentWeeklyCounter');
        return new UserBrowserPushSentWeeklyCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMobilePushSentWeeklyCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMobilePushSentWeeklyCounter');
        return new UserMobilePushSentWeeklyCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserDialogCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userDialogCounter');
        return new UserDialogCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: number) {
        return this._set(ctx, [uid, cid], value);
    }

    add(ctx: Context, uid: number, cid: number, value: number) {
        return this._add(ctx, [uid, cid], value);
    }

    increment(ctx: Context, uid: number, cid: number) {
        return this._increment(ctx, [uid, cid]);
    }

    decrement(ctx: Context, uid: number, cid: number) {
        return this._decrement(ctx, [uid, cid]);
    }
}

export class UserDialogHaveMentionFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userDialogHaveMention');
        return new UserDialogHaveMentionFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: boolean) {
        return this._set(ctx, [uid, cid], value);
    }

    invert(ctx: Context, uid: number, cid: number) {
        return this._invert(ctx, [uid, cid]);
    }
}

export class NotificationCenterCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('notificationCenterCounter');
        return new NotificationCenterCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(ncid: number) {
        return this._findById([ncid]);
    }

    get(ctx: Context, ncid: number) {
        return this._get(ctx, [ncid]);
    }

    set(ctx: Context, ncid: number, value: number) {
        return this._set(ctx, [ncid], value);
    }

    add(ctx: Context, ncid: number, value: number) {
        return this._add(ctx, [ncid], value);
    }

    increment(ctx: Context, ncid: number) {
        return this._increment(ctx, [ncid]);
    }

    decrement(ctx: Context, ncid: number) {
        return this._decrement(ctx, [ncid]);
    }
}

export class UserAudienceCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userAudienceCounter');
        return new UserAudienceCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserMessagesSentInDirectChatCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userMessagesSentInDirectChatCounter');
        return new UserMessagesSentInDirectChatCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number, cid: number) {
        return this._findById([uid, cid]);
    }

    get(ctx: Context, uid: number, cid: number) {
        return this._get(ctx, [uid, cid]);
    }

    set(ctx: Context, uid: number, cid: number, value: number) {
        return this._set(ctx, [uid, cid], value);
    }

    add(ctx: Context, uid: number, cid: number, value: number) {
        return this._add(ctx, [uid, cid], value);
    }

    increment(ctx: Context, uid: number, cid: number) {
        return this._increment(ctx, [uid, cid]);
    }

    decrement(ctx: Context, uid: number, cid: number) {
        return this._decrement(ctx, [uid, cid]);
    }
}

export class User2WayDirectChatsCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('user2WayDirectChatsCounter');
        return new User2WayDirectChatsCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class GlobalStatisticsCountersFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('globalStatisticsCounters');
        return new GlobalStatisticsCountersFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(name: string) {
        return this._findById([name]);
    }

    get(ctx: Context, name: string) {
        return this._get(ctx, [name]);
    }

    set(ctx: Context, name: string, value: number) {
        return this._set(ctx, [name], value);
    }

    add(ctx: Context, name: string, value: number) {
        return this._add(ctx, [name], value);
    }

    increment(ctx: Context, name: string) {
        return this._increment(ctx, [name]);
    }

    decrement(ctx: Context, name: string) {
        return this._decrement(ctx, [name]);
    }
}

export class UserGlobalCounterAllUnreadMessagesFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterAllUnreadMessages');
        return new UserGlobalCounterAllUnreadMessagesFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterUnreadMessagesWithoutMutedFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterUnreadMessagesWithoutMuted');
        return new UserGlobalCounterUnreadMessagesWithoutMutedFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterAllUnreadChatsFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterAllUnreadChats');
        return new UserGlobalCounterAllUnreadChatsFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserGlobalCounterUnreadChatsWithoutMutedFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userGlobalCounterUnreadChatsWithoutMuted');
        return new UserGlobalCounterUnreadChatsWithoutMutedFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserHasFilledAboutFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userHasFilledAbout');
        return new UserHasFilledAboutFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: boolean) {
        return this._set(ctx, [uid], value);
    }

    invert(ctx: Context, uid: number) {
        return this._invert(ctx, [uid]);
    }
}

export class UserReactionsGotFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userReactionsGot');
        return new UserReactionsGotFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class UserReactionsGivenFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('userReactionsGiven');
        return new UserReactionsGivenFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: number) {
        return this._set(ctx, [uid], value);
    }

    add(ctx: Context, uid: number, value: number) {
        return this._add(ctx, [uid], value);
    }

    increment(ctx: Context, uid: number) {
        return this._increment(ctx, [uid]);
    }

    decrement(ctx: Context, uid: number) {
        return this._decrement(ctx, [uid]);
    }
}

export class StatsRecordsFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('statsRecords');
        return new StatsRecordsFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(metricName: string) {
        return this._findById([metricName]);
    }

    get(ctx: Context, metricName: string) {
        return this._get(ctx, [metricName]);
    }

    set(ctx: Context, metricName: string, value: number) {
        return this._set(ctx, [metricName], value);
    }

    add(ctx: Context, metricName: string, value: number) {
        return this._add(ctx, [metricName], value);
    }

    increment(ctx: Context, metricName: string) {
        return this._increment(ctx, [metricName]);
    }

    decrement(ctx: Context, metricName: string) {
        return this._decrement(ctx, [metricName]);
    }
}

export class RoomMessagesCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('roomMessagesCounter');
        return new RoomMessagesCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(rid: number) {
        return this._findById([rid]);
    }

    get(ctx: Context, rid: number) {
        return this._get(ctx, [rid]);
    }

    set(ctx: Context, rid: number, value: number) {
        return this._set(ctx, [rid], value);
    }

    add(ctx: Context, rid: number, value: number) {
        return this._add(ctx, [rid], value);
    }

    increment(ctx: Context, rid: number) {
        return this._increment(ctx, [rid]);
    }

    decrement(ctx: Context, rid: number) {
        return this._decrement(ctx, [rid]);
    }
}

export class RoomActiveMembersPrevWeekCounterFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('roomActiveMembersPrevWeekCounter');
        return new RoomActiveMembersPrevWeekCounterFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(rid: number) {
        return this._findById([rid]);
    }

    get(ctx: Context, rid: number) {
        return this._get(ctx, [rid]);
    }

    set(ctx: Context, rid: number, value: number) {
        return this._set(ctx, [rid], value);
    }

    add(ctx: Context, rid: number, value: number) {
        return this._add(ctx, [rid], value);
    }

    increment(ctx: Context, rid: number) {
        return this._increment(ctx, [rid]);
    }

    decrement(ctx: Context, rid: number) {
        return this._decrement(ctx, [rid]);
    }
}

export class ReaderEstimateFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('readerEstimate');
        return new ReaderEstimateFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(id: string) {
        return this._findById([id]);
    }

    get(ctx: Context, id: string) {
        return this._get(ctx, [id]);
    }

    set(ctx: Context, id: string, value: number) {
        return this._set(ctx, [id], value);
    }

    add(ctx: Context, id: string, value: number) {
        return this._add(ctx, [id], value);
    }

    increment(ctx: Context, id: string) {
        return this._increment(ctx, [id]);
    }

    decrement(ctx: Context, id: string) {
        return this._decrement(ctx, [id]);
    }
}

export class LastAuthEmailSentTimeFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('lastAuthEmailSentTime');
        return new LastAuthEmailSentTimeFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(email: string) {
        return this._findById([email]);
    }

    get(ctx: Context, email: string) {
        return this._get(ctx, [email]);
    }

    set(ctx: Context, email: string, value: number) {
        return this._set(ctx, [email], value);
    }

    add(ctx: Context, email: string, value: number) {
        return this._add(ctx, [email], value);
    }

    increment(ctx: Context, email: string) {
        return this._increment(ctx, [email]);
    }

    decrement(ctx: Context, email: string) {
        return this._decrement(ctx, [email]);
    }
}

export class AuthEmailsSentCountFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('authEmailsSentCount');
        return new AuthEmailsSentCountFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(email: string) {
        return this._findById([email]);
    }

    get(ctx: Context, email: string) {
        return this._get(ctx, [email]);
    }

    set(ctx: Context, email: string, value: number) {
        return this._set(ctx, [email], value);
    }

    add(ctx: Context, email: string, value: number) {
        return this._add(ctx, [email], value);
    }

    increment(ctx: Context, email: string) {
        return this._increment(ctx, [email]);
    }

    decrement(ctx: Context, email: string) {
        return this._decrement(ctx, [email]);
    }
}

export class PhonebookJoinMessageSentForPhoneFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('phonebookJoinMessageSentForPhone');
        return new PhonebookJoinMessageSentForPhoneFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(phone: string) {
        return this._findById([phone]);
    }

    get(ctx: Context, phone: string) {
        return this._get(ctx, [phone]);
    }

    set(ctx: Context, phone: string, value: boolean) {
        return this._set(ctx, [phone], value);
    }

    invert(ctx: Context, phone: string) {
        return this._invert(ctx, [phone]);
    }
}

export class PhonebookUserImportedContactsFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('phonebookUserImportedContacts');
        return new PhonebookUserImportedContactsFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(uid: number) {
        return this._findById([uid]);
    }

    get(ctx: Context, uid: number) {
        return this._get(ctx, [uid]);
    }

    set(ctx: Context, uid: number, value: boolean) {
        return this._set(ctx, [uid], value);
    }

    invert(ctx: Context, uid: number) {
        return this._invert(ctx, [uid]);
    }
}

export interface UserShape {
    id: number;
    authId: string;
    email: string | null;
    googleId: string | null;
    phone: string | null;
    isBot: boolean;
    invitedBy: number | null;
    botOwner: number | null;
    isSuperBot: boolean | null;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
}

export interface UserCreateShape {
    authId: string;
    email?: string | null | undefined;
    googleId?: string | null | undefined;
    phone?: string | null | undefined;
    isBot: boolean;
    invitedBy?: number | null | undefined;
    botOwner?: number | null | undefined;
    isSuperBot?: boolean | null | undefined;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
}

export class User extends Entity<UserShape> {
    get id(): number { return this._rawValue.id; }
    get authId(): string { return this._rawValue.authId; }
    set authId(value: string) {
        let normalized = this.descriptor.codec.fields.authId.normalize(value);
        if (this._rawValue.authId !== normalized) {
            this._rawValue.authId = normalized;
            this._updatedValues.authId = normalized;
            this.invalidate();
        }
    }
    get email(): string | null { return this._rawValue.email; }
    set email(value: string | null) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get googleId(): string | null { return this._rawValue.googleId; }
    set googleId(value: string | null) {
        let normalized = this.descriptor.codec.fields.googleId.normalize(value);
        if (this._rawValue.googleId !== normalized) {
            this._rawValue.googleId = normalized;
            this._updatedValues.googleId = normalized;
            this.invalidate();
        }
    }
    get phone(): string | null { return this._rawValue.phone; }
    set phone(value: string | null) {
        let normalized = this.descriptor.codec.fields.phone.normalize(value);
        if (this._rawValue.phone !== normalized) {
            this._rawValue.phone = normalized;
            this._updatedValues.phone = normalized;
            this.invalidate();
        }
    }
    get isBot(): boolean { return this._rawValue.isBot; }
    set isBot(value: boolean) {
        let normalized = this.descriptor.codec.fields.isBot.normalize(value);
        if (this._rawValue.isBot !== normalized) {
            this._rawValue.isBot = normalized;
            this._updatedValues.isBot = normalized;
            this.invalidate();
        }
    }
    get invitedBy(): number | null { return this._rawValue.invitedBy; }
    set invitedBy(value: number | null) {
        let normalized = this.descriptor.codec.fields.invitedBy.normalize(value);
        if (this._rawValue.invitedBy !== normalized) {
            this._rawValue.invitedBy = normalized;
            this._updatedValues.invitedBy = normalized;
            this.invalidate();
        }
    }
    get botOwner(): number | null { return this._rawValue.botOwner; }
    set botOwner(value: number | null) {
        let normalized = this.descriptor.codec.fields.botOwner.normalize(value);
        if (this._rawValue.botOwner !== normalized) {
            this._rawValue.botOwner = normalized;
            this._updatedValues.botOwner = normalized;
            this.invalidate();
        }
    }
    get isSuperBot(): boolean | null { return this._rawValue.isSuperBot; }
    set isSuperBot(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isSuperBot.normalize(value);
        if (this._rawValue.isSuperBot !== normalized) {
            this._rawValue.isSuperBot = normalized;
            this._updatedValues.isSuperBot = normalized;
            this.invalidate();
        }
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' { return this._rawValue.status; }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class UserFactory extends EntityFactory<UserShape, User> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('user');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'authId', storageKey: 'authId', type: { type: 'unique', fields: [{ name: 'authId', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'authId'), condition: src => src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'email', storageKey: 'email', type: { type: 'unique', fields: [{ name: 'email', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'email'), condition: src => (!!src.email) && src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'googleId', storageKey: 'googleId', type: { type: 'unique', fields: [{ name: 'googleId', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'googleId'), condition: src => (!!src.googleId) && src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'fromPhone', storageKey: 'fromPhone', type: { type: 'unique', fields: [{ name: 'phone', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'fromPhone'), condition: src => (!!src.phone) && src.status !== 'deleted' });
        secondaryIndexes.push({ name: 'owner', storageKey: 'owner', type: { type: 'range', fields: [{ name: 'botOwner', type: 'opt_integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('user', 'owner'), condition: src => src.botOwner });
        secondaryIndexes.push({ name: 'superBots', storageKey: 'superBots', type: { type: 'range', fields: [] }, subspace: await storage.resolveEntityIndexDirectory('user', 'superBots'), condition: src => src.isBot === true && src.isSuperBot });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'authId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'email', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'googleId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'phone', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'isBot', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'invitedBy', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'botOwner', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'isSuperBot', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['pending', 'activated', 'suspended', 'deleted'] }, secure: false });
        let codec = c.struct({
            id: c.integer,
            authId: c.string,
            email: c.optional(c.string),
            googleId: c.optional(c.string),
            phone: c.optional(c.string),
            isBot: c.boolean,
            invitedBy: c.optional(c.integer),
            botOwner: c.optional(c.integer),
            isSuperBot: c.optional(c.boolean),
            status: c.enum('pending', 'activated', 'suspended', 'deleted'),
        });
        let descriptor: EntityDescriptor<UserShape> = {
            name: 'User',
            storageKey: 'user',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserShape>) {
        super(descriptor);
    }

    readonly authId = Object.freeze({
        find: async (ctx: Context, authId: string) => {
            return this._findFromUniqueIndex(ctx, [authId], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly email = Object.freeze({
        find: async (ctx: Context, email: string | null) => {
            return this._findFromUniqueIndex(ctx, [email], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly googleId = Object.freeze({
        find: async (ctx: Context, googleId: string | null) => {
            return this._findFromUniqueIndex(ctx, [googleId], this.descriptor.secondaryIndexes[2]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly fromPhone = Object.freeze({
        find: async (ctx: Context, phone: string | null) => {
            return this._findFromUniqueIndex(ctx, [phone], this.descriptor.secondaryIndexes[3]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly owner = Object.freeze({
        findAll: async (ctx: Context, botOwner: number | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[4], [botOwner])).items;
        },
        query: (ctx: Context, botOwner: number | null, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[4], [botOwner], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (botOwner: number | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[4], [botOwner], opts);
        },
        liveStream: (ctx: Context, botOwner: number | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[4], [botOwner], opts);
        },
    });

    readonly superBots = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[5], [])).items;
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[5], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[5], [], opts);
        },
    });

    create(ctx: Context, id: number, src: UserCreateShape): Promise<User> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserCreateShape): User {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<User | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserShape>): User {
        return new User([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserProfileShape {
    id: number;
    firstName: string;
    lastName: string | null;
    phone: string | null;
    about: string | null;
    website: string | null;
    location: string | null;
    email: string | null;
    picture: any | null;
    twitter: string | null;
    facebook: string | null;
    linkedin: string | null;
    instagram: string | null;
    locations: any | null;
    primaryOrganization: number | null;
    primaryBadge: number | null;
    role: string | null;
}

export interface UserProfileCreateShape {
    firstName: string;
    lastName?: string | null | undefined;
    phone?: string | null | undefined;
    about?: string | null | undefined;
    website?: string | null | undefined;
    location?: string | null | undefined;
    email?: string | null | undefined;
    picture?: any | null | undefined;
    twitter?: string | null | undefined;
    facebook?: string | null | undefined;
    linkedin?: string | null | undefined;
    instagram?: string | null | undefined;
    locations?: any | null | undefined;
    primaryOrganization?: number | null | undefined;
    primaryBadge?: number | null | undefined;
    role?: string | null | undefined;
}

export class UserProfile extends Entity<UserProfileShape> {
    get id(): number { return this._rawValue.id; }
    get firstName(): string { return this._rawValue.firstName; }
    set firstName(value: string) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get phone(): string | null { return this._rawValue.phone; }
    set phone(value: string | null) {
        let normalized = this.descriptor.codec.fields.phone.normalize(value);
        if (this._rawValue.phone !== normalized) {
            this._rawValue.phone = normalized;
            this._updatedValues.phone = normalized;
            this.invalidate();
        }
    }
    get about(): string | null { return this._rawValue.about; }
    set about(value: string | null) {
        let normalized = this.descriptor.codec.fields.about.normalize(value);
        if (this._rawValue.about !== normalized) {
            this._rawValue.about = normalized;
            this._updatedValues.about = normalized;
            this.invalidate();
        }
    }
    get website(): string | null { return this._rawValue.website; }
    set website(value: string | null) {
        let normalized = this.descriptor.codec.fields.website.normalize(value);
        if (this._rawValue.website !== normalized) {
            this._rawValue.website = normalized;
            this._updatedValues.website = normalized;
            this.invalidate();
        }
    }
    get location(): string | null { return this._rawValue.location; }
    set location(value: string | null) {
        let normalized = this.descriptor.codec.fields.location.normalize(value);
        if (this._rawValue.location !== normalized) {
            this._rawValue.location = normalized;
            this._updatedValues.location = normalized;
            this.invalidate();
        }
    }
    get email(): string | null { return this._rawValue.email; }
    set email(value: string | null) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get picture(): any | null { return this._rawValue.picture; }
    set picture(value: any | null) {
        let normalized = this.descriptor.codec.fields.picture.normalize(value);
        if (this._rawValue.picture !== normalized) {
            this._rawValue.picture = normalized;
            this._updatedValues.picture = normalized;
            this.invalidate();
        }
    }
    get twitter(): string | null { return this._rawValue.twitter; }
    set twitter(value: string | null) {
        let normalized = this.descriptor.codec.fields.twitter.normalize(value);
        if (this._rawValue.twitter !== normalized) {
            this._rawValue.twitter = normalized;
            this._updatedValues.twitter = normalized;
            this.invalidate();
        }
    }
    get facebook(): string | null { return this._rawValue.facebook; }
    set facebook(value: string | null) {
        let normalized = this.descriptor.codec.fields.facebook.normalize(value);
        if (this._rawValue.facebook !== normalized) {
            this._rawValue.facebook = normalized;
            this._updatedValues.facebook = normalized;
            this.invalidate();
        }
    }
    get linkedin(): string | null { return this._rawValue.linkedin; }
    set linkedin(value: string | null) {
        let normalized = this.descriptor.codec.fields.linkedin.normalize(value);
        if (this._rawValue.linkedin !== normalized) {
            this._rawValue.linkedin = normalized;
            this._updatedValues.linkedin = normalized;
            this.invalidate();
        }
    }
    get instagram(): string | null { return this._rawValue.instagram; }
    set instagram(value: string | null) {
        let normalized = this.descriptor.codec.fields.instagram.normalize(value);
        if (this._rawValue.instagram !== normalized) {
            this._rawValue.instagram = normalized;
            this._updatedValues.instagram = normalized;
            this.invalidate();
        }
    }
    get locations(): any | null { return this._rawValue.locations; }
    set locations(value: any | null) {
        let normalized = this.descriptor.codec.fields.locations.normalize(value);
        if (this._rawValue.locations !== normalized) {
            this._rawValue.locations = normalized;
            this._updatedValues.locations = normalized;
            this.invalidate();
        }
    }
    get primaryOrganization(): number | null { return this._rawValue.primaryOrganization; }
    set primaryOrganization(value: number | null) {
        let normalized = this.descriptor.codec.fields.primaryOrganization.normalize(value);
        if (this._rawValue.primaryOrganization !== normalized) {
            this._rawValue.primaryOrganization = normalized;
            this._updatedValues.primaryOrganization = normalized;
            this.invalidate();
        }
    }
    get primaryBadge(): number | null { return this._rawValue.primaryBadge; }
    set primaryBadge(value: number | null) {
        let normalized = this.descriptor.codec.fields.primaryBadge.normalize(value);
        if (this._rawValue.primaryBadge !== normalized) {
            this._rawValue.primaryBadge = normalized;
            this._updatedValues.primaryBadge = normalized;
            this.invalidate();
        }
    }
    get role(): string | null { return this._rawValue.role; }
    set role(value: string | null) {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
}

export class UserProfileFactory extends EntityFactory<UserProfileShape, UserProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'byUpdatedAt', storageKey: 'byUpdatedAt', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userProfile', 'byUpdatedAt'), condition: undefined });
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userProfile', 'created'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'firstName', type: { type: 'string' }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'phone', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'about', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'website', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'location', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'email', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'picture', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'twitter', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'facebook', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'linkedin', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'instagram', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'locations', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'primaryOrganization', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'primaryBadge', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            firstName: c.string,
            lastName: c.optional(c.string),
            phone: c.optional(c.string),
            about: c.optional(c.string),
            website: c.optional(c.string),
            location: c.optional(c.string),
            email: c.optional(c.string),
            picture: c.optional(c.any),
            twitter: c.optional(c.string),
            facebook: c.optional(c.string),
            linkedin: c.optional(c.string),
            instagram: c.optional(c.string),
            locations: c.optional(c.any),
            primaryOrganization: c.optional(c.integer),
            primaryBadge: c.optional(c.integer),
            role: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserProfileShape> = {
            name: 'UserProfile',
            storageKey: 'userProfile',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserProfileShape>) {
        super(descriptor);
    }

    readonly byUpdatedAt = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly created = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: number, src: UserProfileCreateShape): Promise<UserProfile> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserProfileCreateShape): UserProfile {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserProfile | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserProfileShape>): UserProfile {
        return new UserProfile([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserProfilePrefilShape {
    id: number;
    firstName: string | null;
    lastName: string | null;
    picture: string | null;
}

export interface UserProfilePrefilCreateShape {
    firstName?: string | null | undefined;
    lastName?: string | null | undefined;
    picture?: string | null | undefined;
}

export class UserProfilePrefil extends Entity<UserProfilePrefilShape> {
    get id(): number { return this._rawValue.id; }
    get firstName(): string | null { return this._rawValue.firstName; }
    set firstName(value: string | null) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get picture(): string | null { return this._rawValue.picture; }
    set picture(value: string | null) {
        let normalized = this.descriptor.codec.fields.picture.normalize(value);
        if (this._rawValue.picture !== normalized) {
            this._rawValue.picture = normalized;
            this._updatedValues.picture = normalized;
            this.invalidate();
        }
    }
}

export class UserProfilePrefilFactory extends EntityFactory<UserProfilePrefilShape, UserProfilePrefil> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userProfilePrefil');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'firstName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'picture', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            firstName: c.optional(c.string),
            lastName: c.optional(c.string),
            picture: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserProfilePrefilShape> = {
            name: 'UserProfilePrefil',
            storageKey: 'userProfilePrefil',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserProfilePrefilFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserProfilePrefilShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: UserProfilePrefilCreateShape): Promise<UserProfilePrefil> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserProfilePrefilCreateShape): UserProfilePrefil {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserProfilePrefil | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserProfilePrefilShape>): UserProfilePrefil {
        return new UserProfilePrefil([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserSettingsShape {
    id: number;
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    commentNotifications: 'all' | 'direct' | 'none' | null;
    commentNotificationsDelivery: 'all' | 'none' | null;
    mobileAlert: boolean | null;
    mobileIncludeText: boolean | null;
    notificationsDelay: 'none' | '1min' | '15min' | null;
    globalCounterType: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null;
    desktop: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' };
    mobile: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' };
    privacy: { whoCanSeeEmail: 'everyone' | 'nobody', whoCanSeePhone: 'everyone' | 'nobody' } | null;
}

export interface UserSettingsCreateShape {
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    commentNotifications?: 'all' | 'direct' | 'none' | null | undefined;
    commentNotificationsDelivery?: 'all' | 'none' | null | undefined;
    mobileAlert?: boolean | null | undefined;
    mobileIncludeText?: boolean | null | undefined;
    notificationsDelay?: 'none' | '1min' | '15min' | null | undefined;
    globalCounterType?: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null | undefined;
    desktop: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' };
    mobile: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' };
    privacy?: { whoCanSeeEmail: 'everyone' | 'nobody', whoCanSeePhone: 'everyone' | 'nobody' } | null | undefined;
}

export class UserSettings extends Entity<UserSettingsShape> {
    get id(): number { return this._rawValue.id; }
    get emailFrequency(): '1hour' | '15min' | 'never' | '24hour' | '1week' { return this._rawValue.emailFrequency; }
    set emailFrequency(value: '1hour' | '15min' | 'never' | '24hour' | '1week') {
        let normalized = this.descriptor.codec.fields.emailFrequency.normalize(value);
        if (this._rawValue.emailFrequency !== normalized) {
            this._rawValue.emailFrequency = normalized;
            this._updatedValues.emailFrequency = normalized;
            this.invalidate();
        }
    }
    get desktopNotifications(): 'all' | 'direct' | 'none' { return this._rawValue.desktopNotifications; }
    set desktopNotifications(value: 'all' | 'direct' | 'none') {
        let normalized = this.descriptor.codec.fields.desktopNotifications.normalize(value);
        if (this._rawValue.desktopNotifications !== normalized) {
            this._rawValue.desktopNotifications = normalized;
            this._updatedValues.desktopNotifications = normalized;
            this.invalidate();
        }
    }
    get mobileNotifications(): 'all' | 'direct' | 'none' { return this._rawValue.mobileNotifications; }
    set mobileNotifications(value: 'all' | 'direct' | 'none') {
        let normalized = this.descriptor.codec.fields.mobileNotifications.normalize(value);
        if (this._rawValue.mobileNotifications !== normalized) {
            this._rawValue.mobileNotifications = normalized;
            this._updatedValues.mobileNotifications = normalized;
            this.invalidate();
        }
    }
    get commentNotifications(): 'all' | 'direct' | 'none' | null { return this._rawValue.commentNotifications; }
    set commentNotifications(value: 'all' | 'direct' | 'none' | null) {
        let normalized = this.descriptor.codec.fields.commentNotifications.normalize(value);
        if (this._rawValue.commentNotifications !== normalized) {
            this._rawValue.commentNotifications = normalized;
            this._updatedValues.commentNotifications = normalized;
            this.invalidate();
        }
    }
    get commentNotificationsDelivery(): 'all' | 'none' | null { return this._rawValue.commentNotificationsDelivery; }
    set commentNotificationsDelivery(value: 'all' | 'none' | null) {
        let normalized = this.descriptor.codec.fields.commentNotificationsDelivery.normalize(value);
        if (this._rawValue.commentNotificationsDelivery !== normalized) {
            this._rawValue.commentNotificationsDelivery = normalized;
            this._updatedValues.commentNotificationsDelivery = normalized;
            this.invalidate();
        }
    }
    get mobileAlert(): boolean | null { return this._rawValue.mobileAlert; }
    set mobileAlert(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.mobileAlert.normalize(value);
        if (this._rawValue.mobileAlert !== normalized) {
            this._rawValue.mobileAlert = normalized;
            this._updatedValues.mobileAlert = normalized;
            this.invalidate();
        }
    }
    get mobileIncludeText(): boolean | null { return this._rawValue.mobileIncludeText; }
    set mobileIncludeText(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.mobileIncludeText.normalize(value);
        if (this._rawValue.mobileIncludeText !== normalized) {
            this._rawValue.mobileIncludeText = normalized;
            this._updatedValues.mobileIncludeText = normalized;
            this.invalidate();
        }
    }
    get notificationsDelay(): 'none' | '1min' | '15min' | null { return this._rawValue.notificationsDelay; }
    set notificationsDelay(value: 'none' | '1min' | '15min' | null) {
        let normalized = this.descriptor.codec.fields.notificationsDelay.normalize(value);
        if (this._rawValue.notificationsDelay !== normalized) {
            this._rawValue.notificationsDelay = normalized;
            this._updatedValues.notificationsDelay = normalized;
            this.invalidate();
        }
    }
    get globalCounterType(): 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null { return this._rawValue.globalCounterType; }
    set globalCounterType(value: 'unread_messages' | 'unread_chats' | 'unread_messages_no_muted' | 'unread_chats_no_muted' | null) {
        let normalized = this.descriptor.codec.fields.globalCounterType.normalize(value);
        if (this._rawValue.globalCounterType !== normalized) {
            this._rawValue.globalCounterType = normalized;
            this._updatedValues.globalCounterType = normalized;
            this.invalidate();
        }
    }
    get desktop(): { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' } { return this._rawValue.desktop; }
    set desktop(value: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' }) {
        let normalized = this.descriptor.codec.fields.desktop.normalize(value);
        if (this._rawValue.desktop !== normalized) {
            this._rawValue.desktop = normalized;
            this._updatedValues.desktop = normalized;
            this.invalidate();
        }
    }
    get mobile(): { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' } { return this._rawValue.mobile; }
    set mobile(value: { direct: { showNotification: boolean, sound: boolean }, secretChat: { showNotification: boolean, sound: boolean }, organizationChat: { showNotification: boolean, sound: boolean }, communityChat: { showNotification: boolean, sound: boolean }, comments: { showNotification: boolean, sound: boolean }, notificationPreview: 'name_text' | 'name' }) {
        let normalized = this.descriptor.codec.fields.mobile.normalize(value);
        if (this._rawValue.mobile !== normalized) {
            this._rawValue.mobile = normalized;
            this._updatedValues.mobile = normalized;
            this.invalidate();
        }
    }
    get privacy(): { whoCanSeeEmail: 'everyone' | 'nobody', whoCanSeePhone: 'everyone' | 'nobody' } | null { return this._rawValue.privacy; }
    set privacy(value: { whoCanSeeEmail: 'everyone' | 'nobody', whoCanSeePhone: 'everyone' | 'nobody' } | null) {
        let normalized = this.descriptor.codec.fields.privacy.normalize(value);
        if (this._rawValue.privacy !== normalized) {
            this._rawValue.privacy = normalized;
            this._updatedValues.privacy = normalized;
            this.invalidate();
        }
    }
}

export class UserSettingsFactory extends EntityFactory<UserSettingsShape, UserSettings> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userSettings');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'emailFrequency', type: { type: 'enum', values: ['1hour', '15min', 'never', '24hour', '1week'] }, secure: false });
        fields.push({ name: 'desktopNotifications', type: { type: 'enum', values: ['all', 'direct', 'none'] }, secure: false });
        fields.push({ name: 'mobileNotifications', type: { type: 'enum', values: ['all', 'direct', 'none'] }, secure: false });
        fields.push({ name: 'commentNotifications', type: { type: 'optional', inner: { type: 'enum', values: ['all', 'direct', 'none'] } }, secure: false });
        fields.push({ name: 'commentNotificationsDelivery', type: { type: 'optional', inner: { type: 'enum', values: ['all', 'none'] } }, secure: false });
        fields.push({ name: 'mobileAlert', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'mobileIncludeText', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'notificationsDelay', type: { type: 'optional', inner: { type: 'enum', values: ['none', '1min', '15min'] } }, secure: false });
        fields.push({ name: 'globalCounterType', type: { type: 'optional', inner: { type: 'enum', values: ['unread_messages', 'unread_chats', 'unread_messages_no_muted', 'unread_chats_no_muted'] } }, secure: false });
        fields.push({ name: 'desktop', type: { type: 'struct', fields: { direct: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, secretChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, organizationChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, communityChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, comments: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, notificationPreview: { type: 'enum', values: ['name_text', 'name'] } } }, secure: false });
        fields.push({ name: 'mobile', type: { type: 'struct', fields: { direct: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, secretChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, organizationChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, communityChat: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, comments: { type: 'struct', fields: { showNotification: { type: 'boolean' }, sound: { type: 'boolean' } } }, notificationPreview: { type: 'enum', values: ['name_text', 'name'] } } }, secure: false });
        fields.push({ name: 'privacy', type: { type: 'optional', inner: { type: 'struct', fields: { whoCanSeeEmail: { type: 'enum', values: ['everyone', 'nobody'] }, whoCanSeePhone: { type: 'enum', values: ['everyone', 'nobody'] } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            emailFrequency: c.enum('1hour', '15min', 'never', '24hour', '1week'),
            desktopNotifications: c.enum('all', 'direct', 'none'),
            mobileNotifications: c.enum('all', 'direct', 'none'),
            commentNotifications: c.optional(c.enum('all', 'direct', 'none')),
            commentNotificationsDelivery: c.optional(c.enum('all', 'none')),
            mobileAlert: c.optional(c.boolean),
            mobileIncludeText: c.optional(c.boolean),
            notificationsDelay: c.optional(c.enum('none', '1min', '15min')),
            globalCounterType: c.optional(c.enum('unread_messages', 'unread_chats', 'unread_messages_no_muted', 'unread_chats_no_muted')),
            desktop: c.struct({ direct: c.struct({ showNotification: c.boolean, sound: c.boolean }), secretChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), organizationChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), communityChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), comments: c.struct({ showNotification: c.boolean, sound: c.boolean }), notificationPreview: c.enum('name_text', 'name') }),
            mobile: c.struct({ direct: c.struct({ showNotification: c.boolean, sound: c.boolean }), secretChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), organizationChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), communityChat: c.struct({ showNotification: c.boolean, sound: c.boolean }), comments: c.struct({ showNotification: c.boolean, sound: c.boolean }), notificationPreview: c.enum('name_text', 'name') }),
            privacy: c.optional(c.struct({ whoCanSeeEmail: c.enum('everyone', 'nobody'), whoCanSeePhone: c.enum('everyone', 'nobody') })),
        });
        let descriptor: EntityDescriptor<UserSettingsShape> = {
            name: 'UserSettings',
            storageKey: 'userSettings',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserSettingsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserSettingsShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: UserSettingsCreateShape): Promise<UserSettings> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserSettingsCreateShape): UserSettings {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserSettings | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserSettingsShape>): UserSettings {
        return new UserSettings([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserIndexingQueueShape {
    id: number;
}

export interface UserIndexingQueueCreateShape {
}

export class UserIndexingQueue extends Entity<UserIndexingQueueShape> {
    get id(): number { return this._rawValue.id; }
}

export class UserIndexingQueueFactory extends EntityFactory<UserIndexingQueueShape, UserIndexingQueue> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userIndexingQueue');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userIndexingQueue', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        let codec = c.struct({
            id: c.integer,
        });
        let descriptor: EntityDescriptor<UserIndexingQueueShape> = {
            name: 'UserIndexingQueue',
            storageKey: 'userIndexingQueue',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserIndexingQueueFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserIndexingQueueShape>) {
        super(descriptor);
    }

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: UserIndexingQueueCreateShape): Promise<UserIndexingQueue> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserIndexingQueueCreateShape): UserIndexingQueue {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserIndexingQueue | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserIndexingQueueShape>): UserIndexingQueue {
        return new UserIndexingQueue([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationShape {
    id: number;
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
    kind: 'organization' | 'community';
    editorial: boolean;
    private: boolean | null;
    personal: boolean | null;
}

export interface OrganizationCreateShape {
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
    kind: 'organization' | 'community';
    editorial: boolean;
    private?: boolean | null | undefined;
    personal?: boolean | null | undefined;
}

export class Organization extends Entity<OrganizationShape> {
    get id(): number { return this._rawValue.id; }
    get ownerId(): number { return this._rawValue.ownerId; }
    set ownerId(value: number) {
        let normalized = this.descriptor.codec.fields.ownerId.normalize(value);
        if (this._rawValue.ownerId !== normalized) {
            this._rawValue.ownerId = normalized;
            this._updatedValues.ownerId = normalized;
            this.invalidate();
        }
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' { return this._rawValue.status; }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
    get kind(): 'organization' | 'community' { return this._rawValue.kind; }
    set kind(value: 'organization' | 'community') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get editorial(): boolean { return this._rawValue.editorial; }
    set editorial(value: boolean) {
        let normalized = this.descriptor.codec.fields.editorial.normalize(value);
        if (this._rawValue.editorial !== normalized) {
            this._rawValue.editorial = normalized;
            this._updatedValues.editorial = normalized;
            this.invalidate();
        }
    }
    get private(): boolean | null { return this._rawValue.private; }
    set private(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.private.normalize(value);
        if (this._rawValue.private !== normalized) {
            this._rawValue.private = normalized;
            this._updatedValues.private = normalized;
            this.invalidate();
        }
    }
    get personal(): boolean | null { return this._rawValue.personal; }
    set personal(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.personal.normalize(value);
        if (this._rawValue.personal !== normalized) {
            this._rawValue.personal = normalized;
            this._updatedValues.personal = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationFactory extends EntityFactory<OrganizationShape, Organization> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organization');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'community', storageKey: 'community', type: { type: 'range', fields: [] }, subspace: await storage.resolveEntityIndexDirectory('organization', 'community'), condition: (src) => src.kind === 'community' && src.status === 'activated' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ownerId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['pending', 'activated', 'suspended', 'deleted'] }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['organization', 'community'] }, secure: false });
        fields.push({ name: 'editorial', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'private', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'personal', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ownerId: c.integer,
            status: c.enum('pending', 'activated', 'suspended', 'deleted'),
            kind: c.enum('organization', 'community'),
            editorial: c.boolean,
            private: c.optional(c.boolean),
            personal: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<OrganizationShape> = {
            name: 'Organization',
            storageKey: 'organization',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationShape>) {
        super(descriptor);
    }

    readonly community = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: OrganizationCreateShape): Promise<Organization> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: OrganizationCreateShape): Organization {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Organization | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationShape>): Organization {
        return new Organization([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationProfileShape {
    id: number;
    name: string;
    photo: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    about: string | null;
    twitter: string | null;
    facebook: string | null;
    linkedin: string | null;
    instagram: string | null;
    website: string | null;
    joinedMembersCount: number | null;
}

export interface OrganizationProfileCreateShape {
    name: string;
    photo?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    about?: string | null | undefined;
    twitter?: string | null | undefined;
    facebook?: string | null | undefined;
    linkedin?: string | null | undefined;
    instagram?: string | null | undefined;
    website?: string | null | undefined;
    joinedMembersCount?: number | null | undefined;
}

export class OrganizationProfile extends Entity<OrganizationProfileShape> {
    get id(): number { return this._rawValue.id; }
    get name(): string { return this._rawValue.name; }
    set name(value: string) {
        let normalized = this.descriptor.codec.fields.name.normalize(value);
        if (this._rawValue.name !== normalized) {
            this._rawValue.name = normalized;
            this._updatedValues.name = normalized;
            this.invalidate();
        }
    }
    get photo(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.photo; }
    set photo(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.photo.normalize(value);
        if (this._rawValue.photo !== normalized) {
            this._rawValue.photo = normalized;
            this._updatedValues.photo = normalized;
            this.invalidate();
        }
    }
    get about(): string | null { return this._rawValue.about; }
    set about(value: string | null) {
        let normalized = this.descriptor.codec.fields.about.normalize(value);
        if (this._rawValue.about !== normalized) {
            this._rawValue.about = normalized;
            this._updatedValues.about = normalized;
            this.invalidate();
        }
    }
    get twitter(): string | null { return this._rawValue.twitter; }
    set twitter(value: string | null) {
        let normalized = this.descriptor.codec.fields.twitter.normalize(value);
        if (this._rawValue.twitter !== normalized) {
            this._rawValue.twitter = normalized;
            this._updatedValues.twitter = normalized;
            this.invalidate();
        }
    }
    get facebook(): string | null { return this._rawValue.facebook; }
    set facebook(value: string | null) {
        let normalized = this.descriptor.codec.fields.facebook.normalize(value);
        if (this._rawValue.facebook !== normalized) {
            this._rawValue.facebook = normalized;
            this._updatedValues.facebook = normalized;
            this.invalidate();
        }
    }
    get linkedin(): string | null { return this._rawValue.linkedin; }
    set linkedin(value: string | null) {
        let normalized = this.descriptor.codec.fields.linkedin.normalize(value);
        if (this._rawValue.linkedin !== normalized) {
            this._rawValue.linkedin = normalized;
            this._updatedValues.linkedin = normalized;
            this.invalidate();
        }
    }
    get instagram(): string | null { return this._rawValue.instagram; }
    set instagram(value: string | null) {
        let normalized = this.descriptor.codec.fields.instagram.normalize(value);
        if (this._rawValue.instagram !== normalized) {
            this._rawValue.instagram = normalized;
            this._updatedValues.instagram = normalized;
            this.invalidate();
        }
    }
    get website(): string | null { return this._rawValue.website; }
    set website(value: string | null) {
        let normalized = this.descriptor.codec.fields.website.normalize(value);
        if (this._rawValue.website !== normalized) {
            this._rawValue.website = normalized;
            this._updatedValues.website = normalized;
            this.invalidate();
        }
    }
    get joinedMembersCount(): number | null { return this._rawValue.joinedMembersCount; }
    set joinedMembersCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.joinedMembersCount.normalize(value);
        if (this._rawValue.joinedMembersCount !== normalized) {
            this._rawValue.joinedMembersCount = normalized;
            this._updatedValues.joinedMembersCount = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationProfileFactory extends EntityFactory<OrganizationProfileShape, OrganizationProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'name', type: { type: 'string' }, secure: false });
        fields.push({ name: 'photo', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'about', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'twitter', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'facebook', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'linkedin', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'instagram', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'website', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'joinedMembersCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            name: c.string,
            photo: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            about: c.optional(c.string),
            twitter: c.optional(c.string),
            facebook: c.optional(c.string),
            linkedin: c.optional(c.string),
            instagram: c.optional(c.string),
            website: c.optional(c.string),
            joinedMembersCount: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<OrganizationProfileShape> = {
            name: 'OrganizationProfile',
            storageKey: 'organizationProfile',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationProfileShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: OrganizationProfileCreateShape): Promise<OrganizationProfile> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: OrganizationProfileCreateShape): OrganizationProfile {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OrganizationProfile | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationProfileShape>): OrganizationProfile {
        return new OrganizationProfile([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationEditorialShape {
    id: number;
    listed: boolean;
    featured: boolean;
}

export interface OrganizationEditorialCreateShape {
    listed: boolean;
    featured: boolean;
}

export class OrganizationEditorial extends Entity<OrganizationEditorialShape> {
    get id(): number { return this._rawValue.id; }
    get listed(): boolean { return this._rawValue.listed; }
    set listed(value: boolean) {
        let normalized = this.descriptor.codec.fields.listed.normalize(value);
        if (this._rawValue.listed !== normalized) {
            this._rawValue.listed = normalized;
            this._updatedValues.listed = normalized;
            this.invalidate();
        }
    }
    get featured(): boolean { return this._rawValue.featured; }
    set featured(value: boolean) {
        let normalized = this.descriptor.codec.fields.featured.normalize(value);
        if (this._rawValue.featured !== normalized) {
            this._rawValue.featured = normalized;
            this._updatedValues.featured = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationEditorialFactory extends EntityFactory<OrganizationEditorialShape, OrganizationEditorial> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationEditorial');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'listed', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'featured', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            listed: c.boolean,
            featured: c.boolean,
        });
        let descriptor: EntityDescriptor<OrganizationEditorialShape> = {
            name: 'OrganizationEditorial',
            storageKey: 'organizationEditorial',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationEditorialFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationEditorialShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: OrganizationEditorialCreateShape): Promise<OrganizationEditorial> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: OrganizationEditorialCreateShape): OrganizationEditorial {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OrganizationEditorial | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationEditorialShape>): OrganizationEditorial {
        return new OrganizationEditorial([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationMemberShape {
    oid: number;
    uid: number;
    invitedBy: number | null;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export interface OrganizationMemberCreateShape {
    invitedBy?: number | null | undefined;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export class OrganizationMember extends Entity<OrganizationMemberShape> {
    get oid(): number { return this._rawValue.oid; }
    get uid(): number { return this._rawValue.uid; }
    get invitedBy(): number | null { return this._rawValue.invitedBy; }
    set invitedBy(value: number | null) {
        let normalized = this.descriptor.codec.fields.invitedBy.normalize(value);
        if (this._rawValue.invitedBy !== normalized) {
            this._rawValue.invitedBy = normalized;
            this._updatedValues.invitedBy = normalized;
            this.invalidate();
        }
    }
    get role(): 'admin' | 'member' { return this._rawValue.role; }
    set role(value: 'admin' | 'member') {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get status(): 'requested' | 'joined' | 'left' { return this._rawValue.status; }
    set status(value: 'requested' | 'joined' | 'left') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationMemberFactory extends EntityFactory<OrganizationMemberShape, OrganizationMember> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationMember');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'ids', storageKey: 'ids', type: { type: 'unique', fields: [{ name: 'oid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'ids'), condition: undefined });
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'range', fields: [{ name: 'status', type: 'string' }, { name: 'oid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'organization'), condition: undefined });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'status', type: 'string' }, { name: 'uid', type: 'integer' }, { name: 'oid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'updated'), condition: undefined });
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationMember', 'created'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'oid', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'invitedBy', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'enum', values: ['admin', 'member'] }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['requested', 'joined', 'left'] }, secure: false });
        let codec = c.struct({
            oid: c.integer,
            uid: c.integer,
            invitedBy: c.optional(c.integer),
            role: c.enum('admin', 'member'),
            status: c.enum('requested', 'joined', 'left'),
        });
        let descriptor: EntityDescriptor<OrganizationMemberShape> = {
            name: 'OrganizationMember',
            storageKey: 'organizationMember',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationMemberFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationMemberShape>) {
        super(descriptor);
    }

    readonly ids = Object.freeze({
        find: async (ctx: Context, oid: number, uid: number) => {
            return this._findFromUniqueIndex(ctx, [oid, uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, oid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [oid])).items;
        },
        query: (ctx: Context, oid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly organization = Object.freeze({
        findAll: async (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [status, oid])).items;
        },
        query: (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [status, oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (status: 'requested' | 'joined' | 'left', oid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [status, oid], opts);
        },
        liveStream: (ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [status, oid], opts);
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [status, uid])).items;
        },
        query: (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [status, uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (status: 'requested' | 'joined' | 'left', uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [status, uid], opts);
        },
        liveStream: (ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [status, uid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [], opts);
        },
    });

    readonly created = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[4], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[4], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[4], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[4], [], opts);
        },
    });

    create(ctx: Context, oid: number, uid: number, src: OrganizationMemberCreateShape): Promise<OrganizationMember> {
        return this._create(ctx, [oid, uid], this.descriptor.codec.normalize({ oid, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, oid: number, uid: number, src: OrganizationMemberCreateShape): OrganizationMember {
        return this._create_UNSAFE(ctx, [oid, uid], this.descriptor.codec.normalize({ oid, uid, ...src }));
    }

    findById(ctx: Context, oid: number, uid: number): Promise<OrganizationMember | null> {
        return this._findById(ctx, [oid, uid]);
    }

    watch(ctx: Context, oid: number, uid: number): Watch {
        return this._watch(ctx, [oid, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationMemberShape>): OrganizationMember {
        return new OrganizationMember([value.oid, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationIndexingQueueShape {
    id: number;
}

export interface OrganizationIndexingQueueCreateShape {
}

export class OrganizationIndexingQueue extends Entity<OrganizationIndexingQueueShape> {
    get id(): number { return this._rawValue.id; }
}

export class OrganizationIndexingQueueFactory extends EntityFactory<OrganizationIndexingQueueShape, OrganizationIndexingQueue> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationIndexingQueue');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationIndexingQueue', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        let codec = c.struct({
            id: c.integer,
        });
        let descriptor: EntityDescriptor<OrganizationIndexingQueueShape> = {
            name: 'OrganizationIndexingQueue',
            storageKey: 'organizationIndexingQueue',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationIndexingQueueFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationIndexingQueueShape>) {
        super(descriptor);
    }

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: OrganizationIndexingQueueCreateShape): Promise<OrganizationIndexingQueue> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: OrganizationIndexingQueueCreateShape): OrganizationIndexingQueue {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OrganizationIndexingQueue | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationIndexingQueueShape>): OrganizationIndexingQueue {
        return new OrganizationIndexingQueue([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OnlineShape {
    uid: number;
    lastSeen: number;
    activeExpires: number | null;
    active: boolean | null;
}

export interface OnlineCreateShape {
    lastSeen: number;
    activeExpires?: number | null | undefined;
    active?: boolean | null | undefined;
}

export class Online extends Entity<OnlineShape> {
    get uid(): number { return this._rawValue.uid; }
    get lastSeen(): number { return this._rawValue.lastSeen; }
    set lastSeen(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeen.normalize(value);
        if (this._rawValue.lastSeen !== normalized) {
            this._rawValue.lastSeen = normalized;
            this._updatedValues.lastSeen = normalized;
            this.invalidate();
        }
    }
    get activeExpires(): number | null { return this._rawValue.activeExpires; }
    set activeExpires(value: number | null) {
        let normalized = this.descriptor.codec.fields.activeExpires.normalize(value);
        if (this._rawValue.activeExpires !== normalized) {
            this._rawValue.activeExpires = normalized;
            this._updatedValues.activeExpires = normalized;
            this.invalidate();
        }
    }
    get active(): boolean | null { return this._rawValue.active; }
    set active(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class OnlineFactory extends EntityFactory<OnlineShape, Online> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('online');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastSeen', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'activeExpires', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'active', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            lastSeen: c.integer,
            activeExpires: c.optional(c.integer),
            active: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<OnlineShape> = {
            name: 'Online',
            storageKey: 'online',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OnlineFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OnlineShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: OnlineCreateShape): Promise<Online> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: OnlineCreateShape): Online {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<Online | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OnlineShape>): Online {
        return new Online([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PresenceShape {
    uid: number;
    tid: string;
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
    active: boolean | null;
}

export interface PresenceCreateShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
    active?: boolean | null | undefined;
}

export class Presence extends Entity<PresenceShape> {
    get uid(): number { return this._rawValue.uid; }
    get tid(): string { return this._rawValue.tid; }
    get lastSeen(): number { return this._rawValue.lastSeen; }
    set lastSeen(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeen.normalize(value);
        if (this._rawValue.lastSeen !== normalized) {
            this._rawValue.lastSeen = normalized;
            this._updatedValues.lastSeen = normalized;
            this.invalidate();
        }
    }
    get lastSeenTimeout(): number { return this._rawValue.lastSeenTimeout; }
    set lastSeenTimeout(value: number) {
        let normalized = this.descriptor.codec.fields.lastSeenTimeout.normalize(value);
        if (this._rawValue.lastSeenTimeout !== normalized) {
            this._rawValue.lastSeenTimeout = normalized;
            this._updatedValues.lastSeenTimeout = normalized;
            this.invalidate();
        }
    }
    get platform(): string { return this._rawValue.platform; }
    set platform(value: string) {
        let normalized = this.descriptor.codec.fields.platform.normalize(value);
        if (this._rawValue.platform !== normalized) {
            this._rawValue.platform = normalized;
            this._updatedValues.platform = normalized;
            this.invalidate();
        }
    }
    get active(): boolean | null { return this._rawValue.active; }
    set active(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class PresenceFactory extends EntityFactory<PresenceShape, Presence> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('presence');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'lastSeen', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('presence', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'tid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastSeen', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'lastSeenTimeout', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'platform', type: { type: 'string' }, secure: false });
        fields.push({ name: 'active', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            tid: c.string,
            lastSeen: c.integer,
            lastSeenTimeout: c.integer,
            platform: c.string,
            active: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<PresenceShape> = {
            name: 'Presence',
            storageKey: 'presence',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PresenceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PresenceShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, tid: string, src: PresenceCreateShape): Promise<Presence> {
        return this._create(ctx, [uid, tid], this.descriptor.codec.normalize({ uid, tid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, tid: string, src: PresenceCreateShape): Presence {
        return this._create_UNSAFE(ctx, [uid, tid], this.descriptor.codec.normalize({ uid, tid, ...src }));
    }

    findById(ctx: Context, uid: number, tid: string): Promise<Presence | null> {
        return this._findById(ctx, [uid, tid]);
    }

    watch(ctx: Context, uid: number, tid: string): Watch {
        return this._watch(ctx, [uid, tid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PresenceShape>): Presence {
        return new Presence([value.uid, value.tid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationShape {
    id: number;
    kind: 'private' | 'organization' | 'room';
    deleted: boolean | null;
    archived: boolean | null;
}

export interface ConversationCreateShape {
    kind: 'private' | 'organization' | 'room';
    deleted?: boolean | null | undefined;
    archived?: boolean | null | undefined;
}

export class Conversation extends Entity<ConversationShape> {
    get id(): number { return this._rawValue.id; }
    get kind(): 'private' | 'organization' | 'room' { return this._rawValue.kind; }
    set kind(value: 'private' | 'organization' | 'room') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get archived(): boolean | null { return this._rawValue.archived; }
    set archived(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.archived.normalize(value);
        if (this._rawValue.archived !== normalized) {
            this._rawValue.archived = normalized;
            this._updatedValues.archived = normalized;
            this.invalidate();
        }
    }
}

export class ConversationFactory extends EntityFactory<ConversationShape, Conversation> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversation');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'kind', type: { type: 'enum', values: ['private', 'organization', 'room'] }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'archived', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            kind: c.enum('private', 'organization', 'room'),
            deleted: c.optional(c.boolean),
            archived: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<ConversationShape> = {
            name: 'Conversation',
            storageKey: 'conversation',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: ConversationCreateShape): Promise<Conversation> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConversationCreateShape): Conversation {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Conversation | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationShape>): Conversation {
        return new Conversation([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationPrivateShape {
    id: number;
    uid1: number;
    uid2: number;
    pinnedMessage: number | null;
}

export interface ConversationPrivateCreateShape {
    uid1: number;
    uid2: number;
    pinnedMessage?: number | null | undefined;
}

export class ConversationPrivate extends Entity<ConversationPrivateShape> {
    get id(): number { return this._rawValue.id; }
    get uid1(): number { return this._rawValue.uid1; }
    set uid1(value: number) {
        let normalized = this.descriptor.codec.fields.uid1.normalize(value);
        if (this._rawValue.uid1 !== normalized) {
            this._rawValue.uid1 = normalized;
            this._updatedValues.uid1 = normalized;
            this.invalidate();
        }
    }
    get uid2(): number { return this._rawValue.uid2; }
    set uid2(value: number) {
        let normalized = this.descriptor.codec.fields.uid2.normalize(value);
        if (this._rawValue.uid2 !== normalized) {
            this._rawValue.uid2 = normalized;
            this._updatedValues.uid2 = normalized;
            this.invalidate();
        }
    }
    get pinnedMessage(): number | null { return this._rawValue.pinnedMessage; }
    set pinnedMessage(value: number | null) {
        let normalized = this.descriptor.codec.fields.pinnedMessage.normalize(value);
        if (this._rawValue.pinnedMessage !== normalized) {
            this._rawValue.pinnedMessage = normalized;
            this._updatedValues.pinnedMessage = normalized;
            this.invalidate();
        }
    }
}

export class ConversationPrivateFactory extends EntityFactory<ConversationPrivateShape, ConversationPrivate> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversationPrivate');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'users', storageKey: 'users', type: { type: 'unique', fields: [{ name: 'uid1', type: 'integer' }, { name: 'uid2', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationPrivate', 'users'), condition: undefined });
        secondaryIndexes.push({ name: 'usersReverse', storageKey: 'usersReverse', type: { type: 'unique', fields: [{ name: 'uid2', type: 'integer' }, { name: 'uid1', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationPrivate', 'usersReverse'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid1', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'uid2', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'pinnedMessage', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid1: c.integer,
            uid2: c.integer,
            pinnedMessage: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<ConversationPrivateShape> = {
            name: 'ConversationPrivate',
            storageKey: 'conversationPrivate',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationPrivateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationPrivateShape>) {
        super(descriptor);
    }

    readonly users = Object.freeze({
        find: async (ctx: Context, uid1: number, uid2: number) => {
            return this._findFromUniqueIndex(ctx, [uid1, uid2], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, uid1: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1])).items;
        },
        query: (ctx: Context, uid1: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly usersReverse = Object.freeze({
        find: async (ctx: Context, uid2: number, uid1: number) => {
            return this._findFromUniqueIndex(ctx, [uid2, uid1], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context, uid2: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2])).items;
        },
        query: (ctx: Context, uid2: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: ConversationPrivateCreateShape): Promise<ConversationPrivate> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConversationPrivateCreateShape): ConversationPrivate {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConversationPrivate | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationPrivateShape>): ConversationPrivate {
        return new ConversationPrivate([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationOrganizationShape {
    id: number;
    oid: number;
}

export interface ConversationOrganizationCreateShape {
    oid: number;
}

export class ConversationOrganization extends Entity<ConversationOrganizationShape> {
    get id(): number { return this._rawValue.id; }
    get oid(): number { return this._rawValue.oid; }
    set oid(value: number) {
        let normalized = this.descriptor.codec.fields.oid.normalize(value);
        if (this._rawValue.oid !== normalized) {
            this._rawValue.oid = normalized;
            this._updatedValues.oid = normalized;
            this.invalidate();
        }
    }
}

export class ConversationOrganizationFactory extends EntityFactory<ConversationOrganizationShape, ConversationOrganization> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversationOrganization');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'unique', fields: [{ name: 'oid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationOrganization', 'organization'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'oid', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            oid: c.integer,
        });
        let descriptor: EntityDescriptor<ConversationOrganizationShape> = {
            name: 'ConversationOrganization',
            storageKey: 'conversationOrganization',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationOrganizationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationOrganizationShape>) {
        super(descriptor);
    }

    readonly organization = Object.freeze({
        find: async (ctx: Context, oid: number) => {
            return this._findFromUniqueIndex(ctx, [oid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: ConversationOrganizationCreateShape): Promise<ConversationOrganization> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConversationOrganizationCreateShape): ConversationOrganization {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConversationOrganization | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationOrganizationShape>): ConversationOrganization {
        return new ConversationOrganization([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationRoomShape {
    id: number;
    kind: 'organization' | 'internal' | 'public' | 'group';
    oid: number | null;
    ownerId: number | null;
    featured: boolean | null;
    listed: boolean | null;
    isChannel: boolean | null;
    isPremium: boolean | null;
    isDeleted: boolean | null;
}

export interface ConversationRoomCreateShape {
    kind: 'organization' | 'internal' | 'public' | 'group';
    oid?: number | null | undefined;
    ownerId?: number | null | undefined;
    featured?: boolean | null | undefined;
    listed?: boolean | null | undefined;
    isChannel?: boolean | null | undefined;
    isPremium?: boolean | null | undefined;
    isDeleted?: boolean | null | undefined;
}

export class ConversationRoom extends Entity<ConversationRoomShape> {
    get id(): number { return this._rawValue.id; }
    get kind(): 'organization' | 'internal' | 'public' | 'group' { return this._rawValue.kind; }
    set kind(value: 'organization' | 'internal' | 'public' | 'group') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get oid(): number | null { return this._rawValue.oid; }
    set oid(value: number | null) {
        let normalized = this.descriptor.codec.fields.oid.normalize(value);
        if (this._rawValue.oid !== normalized) {
            this._rawValue.oid = normalized;
            this._updatedValues.oid = normalized;
            this.invalidate();
        }
    }
    get ownerId(): number | null { return this._rawValue.ownerId; }
    set ownerId(value: number | null) {
        let normalized = this.descriptor.codec.fields.ownerId.normalize(value);
        if (this._rawValue.ownerId !== normalized) {
            this._rawValue.ownerId = normalized;
            this._updatedValues.ownerId = normalized;
            this.invalidate();
        }
    }
    get featured(): boolean | null { return this._rawValue.featured; }
    set featured(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.featured.normalize(value);
        if (this._rawValue.featured !== normalized) {
            this._rawValue.featured = normalized;
            this._updatedValues.featured = normalized;
            this.invalidate();
        }
    }
    get listed(): boolean | null { return this._rawValue.listed; }
    set listed(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.listed.normalize(value);
        if (this._rawValue.listed !== normalized) {
            this._rawValue.listed = normalized;
            this._updatedValues.listed = normalized;
            this.invalidate();
        }
    }
    get isChannel(): boolean | null { return this._rawValue.isChannel; }
    set isChannel(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isChannel.normalize(value);
        if (this._rawValue.isChannel !== normalized) {
            this._rawValue.isChannel = normalized;
            this._updatedValues.isChannel = normalized;
            this.invalidate();
        }
    }
    get isPremium(): boolean | null { return this._rawValue.isPremium; }
    set isPremium(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isPremium.normalize(value);
        if (this._rawValue.isPremium !== normalized) {
            this._rawValue.isPremium = normalized;
            this._updatedValues.isPremium = normalized;
            this.invalidate();
        }
    }
    get isDeleted(): boolean | null { return this._rawValue.isDeleted; }
    set isDeleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isDeleted.normalize(value);
        if (this._rawValue.isDeleted !== normalized) {
            this._rawValue.isDeleted = normalized;
            this._updatedValues.isDeleted = normalized;
            this.invalidate();
        }
    }
}

export class ConversationRoomFactory extends EntityFactory<ConversationRoomShape, ConversationRoom> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversationRoom');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'range', fields: [{ name: 'oid', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationRoom', 'organization'), condition: (v) => (v.kind === 'public' || v.kind === 'internal') && !v.isDeleted });
        secondaryIndexes.push({ name: 'organizationPublicRooms', storageKey: 'organizationPublicRooms', type: { type: 'unique', fields: [{ name: 'oid', type: 'opt_integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationRoom', 'organizationPublicRooms'), condition: (v) => v.kind === 'public' && !v.isDeleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'kind', type: { type: 'enum', values: ['organization', 'internal', 'public', 'group'] }, secure: false });
        fields.push({ name: 'oid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'ownerId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'featured', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'listed', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'isChannel', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'isPremium', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'isDeleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            kind: c.enum('organization', 'internal', 'public', 'group'),
            oid: c.optional(c.integer),
            ownerId: c.optional(c.integer),
            featured: c.optional(c.boolean),
            listed: c.optional(c.boolean),
            isChannel: c.optional(c.boolean),
            isPremium: c.optional(c.boolean),
            isDeleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<ConversationRoomShape> = {
            name: 'ConversationRoom',
            storageKey: 'conversationRoom',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationRoomFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationRoomShape>) {
        super(descriptor);
    }

    readonly organization = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly organizationPublicRooms = Object.freeze({
        find: async (ctx: Context, oid: number | null, id: number) => {
            return this._findFromUniqueIndex(ctx, [oid, id], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context, oid: number | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [oid])).items;
        },
        query: (ctx: Context, oid: number | null, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: ConversationRoomCreateShape): Promise<ConversationRoom> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConversationRoomCreateShape): ConversationRoom {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConversationRoom | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationRoomShape>): ConversationRoom {
        return new ConversationRoom([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PremiumChatSettingsShape {
    id: number;
    price: number;
    interval: 'week' | 'month' | null;
    commissionPercents: number | null;
}

export interface PremiumChatSettingsCreateShape {
    price: number;
    interval?: 'week' | 'month' | null | undefined;
    commissionPercents?: number | null | undefined;
}

export class PremiumChatSettings extends Entity<PremiumChatSettingsShape> {
    get id(): number { return this._rawValue.id; }
    get price(): number { return this._rawValue.price; }
    set price(value: number) {
        let normalized = this.descriptor.codec.fields.price.normalize(value);
        if (this._rawValue.price !== normalized) {
            this._rawValue.price = normalized;
            this._updatedValues.price = normalized;
            this.invalidate();
        }
    }
    get interval(): 'week' | 'month' | null { return this._rawValue.interval; }
    set interval(value: 'week' | 'month' | null) {
        let normalized = this.descriptor.codec.fields.interval.normalize(value);
        if (this._rawValue.interval !== normalized) {
            this._rawValue.interval = normalized;
            this._updatedValues.interval = normalized;
            this.invalidate();
        }
    }
    get commissionPercents(): number | null { return this._rawValue.commissionPercents; }
    set commissionPercents(value: number | null) {
        let normalized = this.descriptor.codec.fields.commissionPercents.normalize(value);
        if (this._rawValue.commissionPercents !== normalized) {
            this._rawValue.commissionPercents = normalized;
            this._updatedValues.commissionPercents = normalized;
            this.invalidate();
        }
    }
}

export class PremiumChatSettingsFactory extends EntityFactory<PremiumChatSettingsShape, PremiumChatSettings> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('premiumChatSettings');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'price', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'interval', type: { type: 'optional', inner: { type: 'enum', values: ['week', 'month'] } }, secure: false });
        fields.push({ name: 'commissionPercents', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            price: c.integer,
            interval: c.optional(c.enum('week', 'month')),
            commissionPercents: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PremiumChatSettingsShape> = {
            name: 'PremiumChatSettings',
            storageKey: 'premiumChatSettings',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PremiumChatSettingsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PremiumChatSettingsShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: PremiumChatSettingsCreateShape): Promise<PremiumChatSettings> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: PremiumChatSettingsCreateShape): PremiumChatSettings {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<PremiumChatSettings | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PremiumChatSettingsShape>): PremiumChatSettings {
        return new PremiumChatSettings([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PremiumChatUserPassShape {
    cid: number;
    uid: number;
    sid: string | null;
    isActive: boolean;
}

export interface PremiumChatUserPassCreateShape {
    sid?: string | null | undefined;
    isActive: boolean;
}

export class PremiumChatUserPass extends Entity<PremiumChatUserPassShape> {
    get cid(): number { return this._rawValue.cid; }
    get uid(): number { return this._rawValue.uid; }
    get sid(): string | null { return this._rawValue.sid; }
    set sid(value: string | null) {
        let normalized = this.descriptor.codec.fields.sid.normalize(value);
        if (this._rawValue.sid !== normalized) {
            this._rawValue.sid = normalized;
            this._updatedValues.sid = normalized;
            this.invalidate();
        }
    }
    get isActive(): boolean { return this._rawValue.isActive; }
    set isActive(value: boolean) {
        let normalized = this.descriptor.codec.fields.isActive.normalize(value);
        if (this._rawValue.isActive !== normalized) {
            this._rawValue.isActive = normalized;
            this._updatedValues.isActive = normalized;
            this.invalidate();
        }
    }
}

export class PremiumChatUserPassFactory extends EntityFactory<PremiumChatUserPassShape, PremiumChatUserPass> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('premiumChatUserPass');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'cid', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'sid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'isActive', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            cid: c.integer,
            uid: c.integer,
            sid: c.optional(c.string),
            isActive: c.boolean,
        });
        let descriptor: EntityDescriptor<PremiumChatUserPassShape> = {
            name: 'PremiumChatUserPass',
            storageKey: 'premiumChatUserPass',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PremiumChatUserPassFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PremiumChatUserPassShape>) {
        super(descriptor);
    }

    create(ctx: Context, cid: number, uid: number, src: PremiumChatUserPassCreateShape): Promise<PremiumChatUserPass> {
        return this._create(ctx, [cid, uid], this.descriptor.codec.normalize({ cid, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, cid: number, uid: number, src: PremiumChatUserPassCreateShape): PremiumChatUserPass {
        return this._create_UNSAFE(ctx, [cid, uid], this.descriptor.codec.normalize({ cid, uid, ...src }));
    }

    findById(ctx: Context, cid: number, uid: number): Promise<PremiumChatUserPass | null> {
        return this._findById(ctx, [cid, uid]);
    }

    watch(ctx: Context, cid: number, uid: number): Watch {
        return this._watch(ctx, [cid, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PremiumChatUserPassShape>): PremiumChatUserPass {
        return new PremiumChatUserPass([value.cid, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface RoomProfileShape {
    id: number;
    title: string;
    image: any | null;
    description: string | null;
    socialImage: any | null;
    pinnedMessage: number | null;
    pinnedMessageOwner: number | null;
    welcomeMessageIsOn: boolean | null;
    welcomeMessageSender: number | null;
    welcomeMessageText: string | null;
    activeMembersCount: number | null;
}

export interface RoomProfileCreateShape {
    title: string;
    image?: any | null | undefined;
    description?: string | null | undefined;
    socialImage?: any | null | undefined;
    pinnedMessage?: number | null | undefined;
    pinnedMessageOwner?: number | null | undefined;
    welcomeMessageIsOn?: boolean | null | undefined;
    welcomeMessageSender?: number | null | undefined;
    welcomeMessageText?: string | null | undefined;
    activeMembersCount?: number | null | undefined;
}

export class RoomProfile extends Entity<RoomProfileShape> {
    get id(): number { return this._rawValue.id; }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get image(): any | null { return this._rawValue.image; }
    set image(value: any | null) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get description(): string | null { return this._rawValue.description; }
    set description(value: string | null) {
        let normalized = this.descriptor.codec.fields.description.normalize(value);
        if (this._rawValue.description !== normalized) {
            this._rawValue.description = normalized;
            this._updatedValues.description = normalized;
            this.invalidate();
        }
    }
    get socialImage(): any | null { return this._rawValue.socialImage; }
    set socialImage(value: any | null) {
        let normalized = this.descriptor.codec.fields.socialImage.normalize(value);
        if (this._rawValue.socialImage !== normalized) {
            this._rawValue.socialImage = normalized;
            this._updatedValues.socialImage = normalized;
            this.invalidate();
        }
    }
    get pinnedMessage(): number | null { return this._rawValue.pinnedMessage; }
    set pinnedMessage(value: number | null) {
        let normalized = this.descriptor.codec.fields.pinnedMessage.normalize(value);
        if (this._rawValue.pinnedMessage !== normalized) {
            this._rawValue.pinnedMessage = normalized;
            this._updatedValues.pinnedMessage = normalized;
            this.invalidate();
        }
    }
    get pinnedMessageOwner(): number | null { return this._rawValue.pinnedMessageOwner; }
    set pinnedMessageOwner(value: number | null) {
        let normalized = this.descriptor.codec.fields.pinnedMessageOwner.normalize(value);
        if (this._rawValue.pinnedMessageOwner !== normalized) {
            this._rawValue.pinnedMessageOwner = normalized;
            this._updatedValues.pinnedMessageOwner = normalized;
            this.invalidate();
        }
    }
    get welcomeMessageIsOn(): boolean | null { return this._rawValue.welcomeMessageIsOn; }
    set welcomeMessageIsOn(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.welcomeMessageIsOn.normalize(value);
        if (this._rawValue.welcomeMessageIsOn !== normalized) {
            this._rawValue.welcomeMessageIsOn = normalized;
            this._updatedValues.welcomeMessageIsOn = normalized;
            this.invalidate();
        }
    }
    get welcomeMessageSender(): number | null { return this._rawValue.welcomeMessageSender; }
    set welcomeMessageSender(value: number | null) {
        let normalized = this.descriptor.codec.fields.welcomeMessageSender.normalize(value);
        if (this._rawValue.welcomeMessageSender !== normalized) {
            this._rawValue.welcomeMessageSender = normalized;
            this._updatedValues.welcomeMessageSender = normalized;
            this.invalidate();
        }
    }
    get welcomeMessageText(): string | null { return this._rawValue.welcomeMessageText; }
    set welcomeMessageText(value: string | null) {
        let normalized = this.descriptor.codec.fields.welcomeMessageText.normalize(value);
        if (this._rawValue.welcomeMessageText !== normalized) {
            this._rawValue.welcomeMessageText = normalized;
            this._updatedValues.welcomeMessageText = normalized;
            this.invalidate();
        }
    }
    get activeMembersCount(): number | null { return this._rawValue.activeMembersCount; }
    set activeMembersCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.activeMembersCount.normalize(value);
        if (this._rawValue.activeMembersCount !== normalized) {
            this._rawValue.activeMembersCount = normalized;
            this._updatedValues.activeMembersCount = normalized;
            this.invalidate();
        }
    }
}

export class RoomProfileFactory extends EntityFactory<RoomProfileShape, RoomProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('roomProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('roomProfile', 'updated'), condition: undefined });
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('roomProfile', 'created'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'image', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'description', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'socialImage', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'pinnedMessage', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'pinnedMessageOwner', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'welcomeMessageIsOn', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'welcomeMessageSender', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'welcomeMessageText', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'activeMembersCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            title: c.string,
            image: c.optional(c.any),
            description: c.optional(c.string),
            socialImage: c.optional(c.any),
            pinnedMessage: c.optional(c.integer),
            pinnedMessageOwner: c.optional(c.integer),
            welcomeMessageIsOn: c.optional(c.boolean),
            welcomeMessageSender: c.optional(c.integer),
            welcomeMessageText: c.optional(c.string),
            activeMembersCount: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<RoomProfileShape> = {
            name: 'RoomProfile',
            storageKey: 'roomProfile',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new RoomProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<RoomProfileShape>) {
        super(descriptor);
    }

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly created = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: number, src: RoomProfileCreateShape): Promise<RoomProfile> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: RoomProfileCreateShape): RoomProfile {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<RoomProfile | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<RoomProfileShape>): RoomProfile {
        return new RoomProfile([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface RoomParticipantShape {
    cid: number;
    uid: number;
    invitedBy: number;
    role: 'member' | 'admin' | 'owner';
    status: 'joined' | 'requested' | 'left' | 'kicked';
}

export interface RoomParticipantCreateShape {
    invitedBy: number;
    role: 'member' | 'admin' | 'owner';
    status: 'joined' | 'requested' | 'left' | 'kicked';
}

export class RoomParticipant extends Entity<RoomParticipantShape> {
    get cid(): number { return this._rawValue.cid; }
    get uid(): number { return this._rawValue.uid; }
    get invitedBy(): number { return this._rawValue.invitedBy; }
    set invitedBy(value: number) {
        let normalized = this.descriptor.codec.fields.invitedBy.normalize(value);
        if (this._rawValue.invitedBy !== normalized) {
            this._rawValue.invitedBy = normalized;
            this._updatedValues.invitedBy = normalized;
            this.invalidate();
        }
    }
    get role(): 'member' | 'admin' | 'owner' { return this._rawValue.role; }
    set role(value: 'member' | 'admin' | 'owner') {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get status(): 'joined' | 'requested' | 'left' | 'kicked' { return this._rawValue.status; }
    set status(value: 'joined' | 'requested' | 'left' | 'kicked') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class RoomParticipantFactory extends EntityFactory<RoomParticipantShape, RoomParticipant> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('roomParticipant');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('roomParticipant', 'active'), condition: (src) => src.status === 'joined' });
        secondaryIndexes.push({ name: 'requests', storageKey: 'requests', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('roomParticipant', 'requests'), condition: (src) => src.status === 'requested' });
        secondaryIndexes.push({ name: 'userActive', storageKey: 'userActive', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'cid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('roomParticipant', 'userActive'), condition: (src) => src.status === 'joined' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'cid', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'invitedBy', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'role', type: { type: 'enum', values: ['member', 'admin', 'owner'] }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['joined', 'requested', 'left', 'kicked'] }, secure: false });
        let codec = c.struct({
            cid: c.integer,
            uid: c.integer,
            invitedBy: c.integer,
            role: c.enum('member', 'admin', 'owner'),
            status: c.enum('joined', 'requested', 'left', 'kicked'),
        });
        let descriptor: EntityDescriptor<RoomParticipantShape> = {
            name: 'RoomParticipant',
            storageKey: 'roomParticipant',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new RoomParticipantFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<RoomParticipantShape>) {
        super(descriptor);
    }

    readonly active = Object.freeze({
        find: async (ctx: Context, cid: number, uid: number) => {
            return this._findFromUniqueIndex(ctx, [cid, uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly requests = Object.freeze({
        find: async (ctx: Context, cid: number, uid: number) => {
            return this._findFromUniqueIndex(ctx, [cid, uid], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly userActive = Object.freeze({
        find: async (ctx: Context, uid: number, cid: number) => {
            return this._findFromUniqueIndex(ctx, [uid, cid], this.descriptor.secondaryIndexes[2]);
        },
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, cid: number, uid: number, src: RoomParticipantCreateShape): Promise<RoomParticipant> {
        return this._create(ctx, [cid, uid], this.descriptor.codec.normalize({ cid, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, cid: number, uid: number, src: RoomParticipantCreateShape): RoomParticipant {
        return this._create_UNSAFE(ctx, [cid, uid], this.descriptor.codec.normalize({ cid, uid, ...src }));
    }

    findById(ctx: Context, cid: number, uid: number): Promise<RoomParticipant | null> {
        return this._findById(ctx, [cid, uid]);
    }

    watch(ctx: Context, cid: number, uid: number): Watch {
        return this._watch(ctx, [cid, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<RoomParticipantShape>): RoomParticipant {
        return new RoomParticipant([value.cid, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface MessageShape {
    id: number;
    cid: number;
    uid: number;
    seq: number | null;
    repeatKey: string | null;
    text: string | null;
    replyMessages: (number)[] | null;
    serviceMetadata: any | null;
    reactions: ({ userId: number, reaction: string })[] | null;
    edited: boolean | null;
    isMuted: boolean;
    isService: boolean;
    hiddenForUids: (number)[] | null;
    deleted: boolean | null;
    spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number } | { type: 'hash_tag', offset: number, length: number, tag: string })[] | null;
    attachmentsModern: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imagePreview: string | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'purchase_attachment', id: string, pid: string })[] | null;
    stickerId: string | null;
    overrideAvatar: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    overrideName: string | null;
    fileId: string | null;
    fileMetadata: { name: string, size: number, isStored: boolean | null, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null;
    filePreview: string | null;
    augmentation: any | null;
    mentions: any | null;
    attachments: any | null;
    buttons: any | null;
    type: string | null;
    title: string | null;
    postType: string | null;
    complexMentions: any | null;
}

export interface MessageCreateShape {
    cid: number;
    uid: number;
    seq?: number | null | undefined;
    repeatKey?: string | null | undefined;
    text?: string | null | undefined;
    replyMessages?: (number)[] | null | undefined;
    serviceMetadata?: any | null | undefined;
    reactions?: ({ userId: number, reaction: string })[] | null | undefined;
    edited?: boolean | null | undefined;
    isMuted: boolean;
    isService: boolean;
    hiddenForUids?: (number)[] | null | undefined;
    deleted?: boolean | null | undefined;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number } | { type: 'hash_tag', offset: number, length: number, tag: string })[] | null | undefined;
    attachmentsModern?: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null | undefined, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined } | { type: 'rich_attachment', id: string, title: string | null | undefined, subTitle: string | null | undefined, titleLink: string | null | undefined, text: string | null | undefined, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imagePreview: string | null | undefined, imageFallback: { photo: string, text: string } | null | undefined, titleLinkHostname: string | null | undefined, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null | undefined })[])[] } | null | undefined, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, socialImagePreview: string | null | undefined, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined } | { type: 'purchase_attachment', id: string, pid: string })[] | null | undefined;
    stickerId?: string | null | undefined;
    overrideAvatar?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    overrideName?: string | null | undefined;
    fileId?: string | null | undefined;
    fileMetadata?: { name: string, size: number, isStored: boolean | null | undefined, isImage: boolean | null | undefined, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined;
    filePreview?: string | null | undefined;
    augmentation?: any | null | undefined;
    mentions?: any | null | undefined;
    attachments?: any | null | undefined;
    buttons?: any | null | undefined;
    type?: string | null | undefined;
    title?: string | null | undefined;
    postType?: string | null | undefined;
    complexMentions?: any | null | undefined;
}

export class Message extends Entity<MessageShape> {
    get id(): number { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get seq(): number | null { return this._rawValue.seq; }
    set seq(value: number | null) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
    get repeatKey(): string | null { return this._rawValue.repeatKey; }
    set repeatKey(value: string | null) {
        let normalized = this.descriptor.codec.fields.repeatKey.normalize(value);
        if (this._rawValue.repeatKey !== normalized) {
            this._rawValue.repeatKey = normalized;
            this._updatedValues.repeatKey = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get replyMessages(): (number)[] | null { return this._rawValue.replyMessages; }
    set replyMessages(value: (number)[] | null) {
        let normalized = this.descriptor.codec.fields.replyMessages.normalize(value);
        if (this._rawValue.replyMessages !== normalized) {
            this._rawValue.replyMessages = normalized;
            this._updatedValues.replyMessages = normalized;
            this.invalidate();
        }
    }
    get serviceMetadata(): any | null { return this._rawValue.serviceMetadata; }
    set serviceMetadata(value: any | null) {
        let normalized = this.descriptor.codec.fields.serviceMetadata.normalize(value);
        if (this._rawValue.serviceMetadata !== normalized) {
            this._rawValue.serviceMetadata = normalized;
            this._updatedValues.serviceMetadata = normalized;
            this.invalidate();
        }
    }
    get reactions(): ({ userId: number, reaction: string })[] | null { return this._rawValue.reactions; }
    set reactions(value: ({ userId: number, reaction: string })[] | null) {
        let normalized = this.descriptor.codec.fields.reactions.normalize(value);
        if (this._rawValue.reactions !== normalized) {
            this._rawValue.reactions = normalized;
            this._updatedValues.reactions = normalized;
            this.invalidate();
        }
    }
    get edited(): boolean | null { return this._rawValue.edited; }
    set edited(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.edited.normalize(value);
        if (this._rawValue.edited !== normalized) {
            this._rawValue.edited = normalized;
            this._updatedValues.edited = normalized;
            this.invalidate();
        }
    }
    get isMuted(): boolean { return this._rawValue.isMuted; }
    set isMuted(value: boolean) {
        let normalized = this.descriptor.codec.fields.isMuted.normalize(value);
        if (this._rawValue.isMuted !== normalized) {
            this._rawValue.isMuted = normalized;
            this._updatedValues.isMuted = normalized;
            this.invalidate();
        }
    }
    get isService(): boolean { return this._rawValue.isService; }
    set isService(value: boolean) {
        let normalized = this.descriptor.codec.fields.isService.normalize(value);
        if (this._rawValue.isService !== normalized) {
            this._rawValue.isService = normalized;
            this._updatedValues.isService = normalized;
            this.invalidate();
        }
    }
    get hiddenForUids(): (number)[] | null { return this._rawValue.hiddenForUids; }
    set hiddenForUids(value: (number)[] | null) {
        let normalized = this.descriptor.codec.fields.hiddenForUids.normalize(value);
        if (this._rawValue.hiddenForUids !== normalized) {
            this._rawValue.hiddenForUids = normalized;
            this._updatedValues.hiddenForUids = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number } | { type: 'hash_tag', offset: number, length: number, tag: string })[] | null { return this._rawValue.spans; }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number } | { type: 'hash_tag', offset: number, length: number, tag: string })[] | null) {
        let normalized = this.descriptor.codec.fields.spans.normalize(value);
        if (this._rawValue.spans !== normalized) {
            this._rawValue.spans = normalized;
            this._updatedValues.spans = normalized;
            this.invalidate();
        }
    }
    get attachmentsModern(): ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imagePreview: string | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'purchase_attachment', id: string, pid: string })[] | null { return this._rawValue.attachmentsModern; }
    set attachmentsModern(value: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imagePreview: string | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'purchase_attachment', id: string, pid: string })[] | null) {
        let normalized = this.descriptor.codec.fields.attachmentsModern.normalize(value);
        if (this._rawValue.attachmentsModern !== normalized) {
            this._rawValue.attachmentsModern = normalized;
            this._updatedValues.attachmentsModern = normalized;
            this.invalidate();
        }
    }
    get stickerId(): string | null { return this._rawValue.stickerId; }
    set stickerId(value: string | null) {
        let normalized = this.descriptor.codec.fields.stickerId.normalize(value);
        if (this._rawValue.stickerId !== normalized) {
            this._rawValue.stickerId = normalized;
            this._updatedValues.stickerId = normalized;
            this.invalidate();
        }
    }
    get overrideAvatar(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.overrideAvatar; }
    set overrideAvatar(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.overrideAvatar.normalize(value);
        if (this._rawValue.overrideAvatar !== normalized) {
            this._rawValue.overrideAvatar = normalized;
            this._updatedValues.overrideAvatar = normalized;
            this.invalidate();
        }
    }
    get overrideName(): string | null { return this._rawValue.overrideName; }
    set overrideName(value: string | null) {
        let normalized = this.descriptor.codec.fields.overrideName.normalize(value);
        if (this._rawValue.overrideName !== normalized) {
            this._rawValue.overrideName = normalized;
            this._updatedValues.overrideName = normalized;
            this.invalidate();
        }
    }
    get fileId(): string | null { return this._rawValue.fileId; }
    set fileId(value: string | null) {
        let normalized = this.descriptor.codec.fields.fileId.normalize(value);
        if (this._rawValue.fileId !== normalized) {
            this._rawValue.fileId = normalized;
            this._updatedValues.fileId = normalized;
            this.invalidate();
        }
    }
    get fileMetadata(): { name: string, size: number, isStored: boolean | null, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null { return this._rawValue.fileMetadata; }
    set fileMetadata(value: { name: string, size: number, isStored: boolean | null, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null) {
        let normalized = this.descriptor.codec.fields.fileMetadata.normalize(value);
        if (this._rawValue.fileMetadata !== normalized) {
            this._rawValue.fileMetadata = normalized;
            this._updatedValues.fileMetadata = normalized;
            this.invalidate();
        }
    }
    get filePreview(): string | null { return this._rawValue.filePreview; }
    set filePreview(value: string | null) {
        let normalized = this.descriptor.codec.fields.filePreview.normalize(value);
        if (this._rawValue.filePreview !== normalized) {
            this._rawValue.filePreview = normalized;
            this._updatedValues.filePreview = normalized;
            this.invalidate();
        }
    }
    get augmentation(): any | null { return this._rawValue.augmentation; }
    set augmentation(value: any | null) {
        let normalized = this.descriptor.codec.fields.augmentation.normalize(value);
        if (this._rawValue.augmentation !== normalized) {
            this._rawValue.augmentation = normalized;
            this._updatedValues.augmentation = normalized;
            this.invalidate();
        }
    }
    get mentions(): any | null { return this._rawValue.mentions; }
    set mentions(value: any | null) {
        let normalized = this.descriptor.codec.fields.mentions.normalize(value);
        if (this._rawValue.mentions !== normalized) {
            this._rawValue.mentions = normalized;
            this._updatedValues.mentions = normalized;
            this.invalidate();
        }
    }
    get attachments(): any | null { return this._rawValue.attachments; }
    set attachments(value: any | null) {
        let normalized = this.descriptor.codec.fields.attachments.normalize(value);
        if (this._rawValue.attachments !== normalized) {
            this._rawValue.attachments = normalized;
            this._updatedValues.attachments = normalized;
            this.invalidate();
        }
    }
    get buttons(): any | null { return this._rawValue.buttons; }
    set buttons(value: any | null) {
        let normalized = this.descriptor.codec.fields.buttons.normalize(value);
        if (this._rawValue.buttons !== normalized) {
            this._rawValue.buttons = normalized;
            this._updatedValues.buttons = normalized;
            this.invalidate();
        }
    }
    get type(): string | null { return this._rawValue.type; }
    set type(value: string | null) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get title(): string | null { return this._rawValue.title; }
    set title(value: string | null) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get postType(): string | null { return this._rawValue.postType; }
    set postType(value: string | null) {
        let normalized = this.descriptor.codec.fields.postType.normalize(value);
        if (this._rawValue.postType !== normalized) {
            this._rawValue.postType = normalized;
            this._updatedValues.postType = normalized;
            this.invalidate();
        }
    }
    get complexMentions(): any | null { return this._rawValue.complexMentions; }
    set complexMentions(value: any | null) {
        let normalized = this.descriptor.codec.fields.complexMentions.normalize(value);
        if (this._rawValue.complexMentions !== normalized) {
            this._rawValue.complexMentions = normalized;
            this._updatedValues.complexMentions = normalized;
            this.invalidate();
        }
    }
}

export class MessageFactory extends EntityFactory<MessageShape, Message> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('message');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'chat', storageKey: 'chat', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'chat'), condition: (src) => !src.deleted });
        secondaryIndexes.push({ name: 'chatSeq', storageKey: 'chatSeq', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'seq', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'chatSeq'), condition: (src) => !src.deleted });
        secondaryIndexes.push({ name: 'fromSeq', storageKey: 'fromSeq', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'seq', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'fromSeq'), condition: undefined });
        secondaryIndexes.push({ name: 'hasImageAttachment', storageKey: 'hasImageAttachment', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'hasImageAttachment'), condition: (item) => {
            if (item.deleted) {
                return false;
            }
            if (item.fileId) {
                if (item.fileMetadata && item.fileMetadata.isImage) {
                    return true;
                }
            }
            if (item.attachments) {
                for (let attach of item.attachments) {
                    if (attach.fileMetadata && attach.fileMetadata.isImage) {
                        return true;
                    }
                }
            }
            if (item.attachmentsModern) {
                for (let attach of item.attachmentsModern) {
                    if (attach.type === 'file_attachment') {
                        if (attach.fileMetadata && attach.fileMetadata.isImage) {
                            return true;
                        }
                    }
                }
            }
            return false;
        } });
        secondaryIndexes.push({ name: 'hasLinkAttachment', storageKey: 'hasLinkAttachment', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'hasLinkAttachment'), condition: (item) => {
            if (item.deleted) {
                return false;
            }
            if (item.augmentation) {
                return true;
            }
            if (item.attachmentsModern) {
                for (let attach of item.attachmentsModern) {
                    if (attach.type === 'rich_attachment') {
                        return true;
                    }
                }
            }
            return false;
        } });
        secondaryIndexes.push({ name: 'hasVideoAttachment', storageKey: 'hasVideoAttachment', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'hasVideoAttachment'), condition: (item) => {
            if (item.deleted) {
                return false;
            }
            if (item.fileId && item.fileMetadata && item.fileMetadata.mimeType.startsWith('video/')) {
                return true;
            }
            if (item.attachments) {
                for (let attach of item.attachments) {
                    if (attach.fileMetadata && attach.fileMetadata.mimeType.startsWith('video/')) {
                        return true;
                    }
                }
            }
            if (item.attachmentsModern) {
                for (let attach of item.attachmentsModern) {
                    if (attach.type === 'file_attachment' && attach.fileMetadata && attach.fileMetadata.mimeType.startsWith('video/')) {
                        return true;
                    }
                }
            }
            return false;
        } });
        secondaryIndexes.push({ name: 'hasDocumentAttachment', storageKey: 'hasDocumentAttachment', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'hasDocumentAttachment'), condition: (item) => {
            if (item.deleted) {
                return false;
            }
            if (item.fileId) {
                if (item.fileMetadata && !item.fileMetadata.isImage && !item.fileMetadata.mimeType.startsWith('video/')) {
                    return true;
                }
            }
            if (item.attachments) {
                for (let attach of item.attachments) {
                    if (attach.fileMetadata && !attach.fileMetadata.isImage && !attach.fileMetadata.mimeType.startsWith('video/')) {
                        return true;
                    }
                }
            }
            if (item.attachmentsModern) {
                for (let attach of item.attachmentsModern) {
                    if (attach.type === 'file_attachment') {
                        if (attach.fileMetadata && !attach.fileMetadata.isImage && !attach.fileMetadata.mimeType.startsWith('video/')) {
                            return true;
                        }
                    }
                }
            }
            return false;
        } });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'updated'), condition: undefined });
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'created'), condition: undefined });
        secondaryIndexes.push({ name: 'repeat', storageKey: 'repeat', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'cid', type: 'integer' }, { name: 'repeatKey', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('message', 'repeat'), condition: (src) => !!src.repeatKey });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'seq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'repeatKey', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'replyMessages', type: { type: 'optional', inner: { type: 'array', inner: { type: 'integer' } } }, secure: false });
        fields.push({ name: 'serviceMetadata', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'reactions', type: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { userId: { type: 'integer' }, reaction: { type: 'string' } } } } }, secure: false });
        fields.push({ name: 'edited', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'isMuted', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'isService', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'hiddenForUids', type: { type: 'optional', inner: { type: 'array', inner: { type: 'integer' } } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'spans', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, user: { type: 'integer' } }, multi_user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, users: { type: 'array', inner: { type: 'integer' } } }, room_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, room: { type: 'integer' } }, organization_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, organization: { type: 'integer' } }, link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, date_text: { offset: { type: 'integer' }, length: { type: 'integer' }, date: { type: 'integer' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, inline_code_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, code_block_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, insane_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, loud_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, rotating_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, all_mention: { offset: { type: 'integer' }, length: { type: 'integer' } }, hash_tag: { offset: { type: 'integer' }, length: { type: 'integer' }, tag: { type: 'string' } } } } } }, secure: false });
        fields.push({ name: 'attachmentsModern', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { file_attachment: { id: { type: 'string' }, fileId: { type: 'string' }, filePreview: { type: 'optional', inner: { type: 'string' } }, fileMetadata: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } }, rich_attachment: { id: { type: 'string' }, title: { type: 'optional', inner: { type: 'string' } }, subTitle: { type: 'optional', inner: { type: 'string' } }, titleLink: { type: 'optional', inner: { type: 'string' } }, text: { type: 'optional', inner: { type: 'string' } }, icon: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, image: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, iconInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imagePreview: { type: 'optional', inner: { type: 'string' } }, imageFallback: { type: 'optional', inner: { type: 'struct', fields: { photo: { type: 'string' }, text: { type: 'string' } } } }, titleLinkHostname: { type: 'optional', inner: { type: 'string' } }, keyboard: { type: 'optional', inner: { type: 'struct', fields: { buttons: { type: 'array', inner: { type: 'array', inner: { type: 'struct', fields: { title: { type: 'string' }, style: { type: 'enum', values: ['DEFAULT', 'LIGHT', 'PAY'] }, url: { type: 'optional', inner: { type: 'string' } } } } } } } } }, socialImage: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, socialImagePreview: { type: 'optional', inner: { type: 'string' } }, socialImageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } }, purchase_attachment: { id: { type: 'string' }, pid: { type: 'string' } } } } } }, secure: false });
        fields.push({ name: 'stickerId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'overrideAvatar', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'overrideName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'fileId', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'fileMetadata', type: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isStored: { type: 'optional', inner: { type: 'boolean' } }, isImage: { type: 'optional', inner: { type: 'boolean' } }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, secure: true });
        fields.push({ name: 'filePreview', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'augmentation', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'mentions', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'attachments', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'buttons', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'type', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'title', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'postType', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'complexMentions', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            cid: c.integer,
            uid: c.integer,
            seq: c.optional(c.integer),
            repeatKey: c.optional(c.string),
            text: c.optional(c.string),
            replyMessages: c.optional(c.array(c.integer)),
            serviceMetadata: c.optional(c.any),
            reactions: c.optional(c.array(c.struct({ userId: c.integer, reaction: c.string }))),
            edited: c.optional(c.boolean),
            isMuted: c.boolean,
            isService: c.boolean,
            hiddenForUids: c.optional(c.array(c.integer)),
            deleted: c.optional(c.boolean),
            spans: c.optional(c.array(c.union({ user_mention: c.struct({ offset: c.integer, length: c.integer, user: c.integer }), multi_user_mention: c.struct({ offset: c.integer, length: c.integer, users: c.array(c.integer) }), room_mention: c.struct({ offset: c.integer, length: c.integer, room: c.integer }), organization_mention: c.struct({ offset: c.integer, length: c.integer, organization: c.integer }), link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), date_text: c.struct({ offset: c.integer, length: c.integer, date: c.integer }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }), inline_code_text: c.struct({ offset: c.integer, length: c.integer }), code_block_text: c.struct({ offset: c.integer, length: c.integer }), insane_text: c.struct({ offset: c.integer, length: c.integer }), loud_text: c.struct({ offset: c.integer, length: c.integer }), rotating_text: c.struct({ offset: c.integer, length: c.integer }), all_mention: c.struct({ offset: c.integer, length: c.integer }), hash_tag: c.struct({ offset: c.integer, length: c.integer, tag: c.string }) }))),
            attachmentsModern: c.optional(c.array(c.union({ file_attachment: c.struct({ id: c.string, fileId: c.string, filePreview: c.optional(c.string), fileMetadata: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }), rich_attachment: c.struct({ id: c.string, title: c.optional(c.string), subTitle: c.optional(c.string), titleLink: c.optional(c.string), text: c.optional(c.string), icon: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), iconInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imagePreview: c.optional(c.string), imageFallback: c.optional(c.struct({ photo: c.string, text: c.string })), titleLinkHostname: c.optional(c.string), keyboard: c.optional(c.struct({ buttons: c.array(c.array(c.struct({ title: c.string, style: c.enum('DEFAULT', 'LIGHT', 'PAY'), url: c.optional(c.string) }))) })), socialImage: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), socialImagePreview: c.optional(c.string), socialImageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }), purchase_attachment: c.struct({ id: c.string, pid: c.string }) }))),
            stickerId: c.optional(c.string),
            overrideAvatar: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            overrideName: c.optional(c.string),
            fileId: c.optional(c.string),
            fileMetadata: c.optional(c.struct({ name: c.string, size: c.integer, isStored: c.optional(c.boolean), isImage: c.optional(c.boolean), imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })),
            filePreview: c.optional(c.string),
            augmentation: c.optional(c.any),
            mentions: c.optional(c.any),
            attachments: c.optional(c.any),
            buttons: c.optional(c.any),
            type: c.optional(c.string),
            title: c.optional(c.string),
            postType: c.optional(c.string),
            complexMentions: c.optional(c.any),
        });
        let descriptor: EntityDescriptor<MessageShape> = {
            name: 'Message',
            storageKey: 'message',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new MessageFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<MessageShape>) {
        super(descriptor);
    }

    readonly chat = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    readonly chatSeq = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [cid], opts);
        },
    });

    readonly fromSeq = Object.freeze({
        find: async (ctx: Context, cid: number, seq: number | null) => {
            return this._findFromUniqueIndex(ctx, [cid, seq], this.descriptor.secondaryIndexes[2]);
        },
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly hasImageAttachment = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [cid], opts);
        },
    });

    readonly hasLinkAttachment = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[4], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[4], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[4], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[4], [cid], opts);
        },
    });

    readonly hasVideoAttachment = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[5], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[5], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[5], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[5], [cid], opts);
        },
    });

    readonly hasDocumentAttachment = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[6], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[6], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[6], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[6], [cid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[7], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[7], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[7], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[7], [], opts);
        },
    });

    readonly created = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[8], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[8], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[8], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[8], [], opts);
        },
    });

    readonly repeat = Object.freeze({
        find: async (ctx: Context, uid: number, cid: number, repeatKey: string | null) => {
            return this._findFromUniqueIndex(ctx, [uid, cid, repeatKey], this.descriptor.secondaryIndexes[9]);
        },
        findAll: async (ctx: Context, uid: number, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[9], [uid, cid])).items;
        },
        query: (ctx: Context, uid: number, cid: number, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[9], [uid, cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: MessageCreateShape): Promise<Message> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: MessageCreateShape): Message {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Message | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<MessageShape>): Message {
        return new Message([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentShape {
    id: number;
    peerId: number;
    peerType: 'message' | 'feed_item' | 'discussion';
    parentCommentId: number | null;
    uid: number;
    repeatKey: string | null;
    text: string | null;
    stickerId: string | null;
    reactions: ({ userId: number, reaction: string })[] | null;
    spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null;
    attachments: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, imagePreview: string | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null;
    overrideAvatar: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    overrideName: string | null;
    deleted: boolean | null;
    edited: boolean | null;
    visible: boolean | null;
}

export interface CommentCreateShape {
    peerId: number;
    peerType: 'message' | 'feed_item' | 'discussion';
    parentCommentId?: number | null | undefined;
    uid: number;
    repeatKey?: string | null | undefined;
    text?: string | null | undefined;
    stickerId?: string | null | undefined;
    reactions?: ({ userId: number, reaction: string })[] | null | undefined;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null | undefined;
    attachments?: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null | undefined, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined } | { type: 'rich_attachment', id: string, title: string | null | undefined, subTitle: string | null | undefined, titleLink: string | null | undefined, text: string | null | undefined, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, imagePreview: string | null | undefined, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imageFallback: { photo: string, text: string } | null | undefined, titleLinkHostname: string | null | undefined, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null | undefined })[])[] } | null | undefined, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, socialImagePreview: string | null | undefined, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined })[] | null | undefined;
    overrideAvatar?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    overrideName?: string | null | undefined;
    deleted?: boolean | null | undefined;
    edited?: boolean | null | undefined;
    visible?: boolean | null | undefined;
}

export class Comment extends Entity<CommentShape> {
    get id(): number { return this._rawValue.id; }
    get peerId(): number { return this._rawValue.peerId; }
    set peerId(value: number) {
        let normalized = this.descriptor.codec.fields.peerId.normalize(value);
        if (this._rawValue.peerId !== normalized) {
            this._rawValue.peerId = normalized;
            this._updatedValues.peerId = normalized;
            this.invalidate();
        }
    }
    get peerType(): 'message' | 'feed_item' | 'discussion' { return this._rawValue.peerType; }
    set peerType(value: 'message' | 'feed_item' | 'discussion') {
        let normalized = this.descriptor.codec.fields.peerType.normalize(value);
        if (this._rawValue.peerType !== normalized) {
            this._rawValue.peerType = normalized;
            this._updatedValues.peerType = normalized;
            this.invalidate();
        }
    }
    get parentCommentId(): number | null { return this._rawValue.parentCommentId; }
    set parentCommentId(value: number | null) {
        let normalized = this.descriptor.codec.fields.parentCommentId.normalize(value);
        if (this._rawValue.parentCommentId !== normalized) {
            this._rawValue.parentCommentId = normalized;
            this._updatedValues.parentCommentId = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get repeatKey(): string | null { return this._rawValue.repeatKey; }
    set repeatKey(value: string | null) {
        let normalized = this.descriptor.codec.fields.repeatKey.normalize(value);
        if (this._rawValue.repeatKey !== normalized) {
            this._rawValue.repeatKey = normalized;
            this._updatedValues.repeatKey = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get stickerId(): string | null { return this._rawValue.stickerId; }
    set stickerId(value: string | null) {
        let normalized = this.descriptor.codec.fields.stickerId.normalize(value);
        if (this._rawValue.stickerId !== normalized) {
            this._rawValue.stickerId = normalized;
            this._updatedValues.stickerId = normalized;
            this.invalidate();
        }
    }
    get reactions(): ({ userId: number, reaction: string })[] | null { return this._rawValue.reactions; }
    set reactions(value: ({ userId: number, reaction: string })[] | null) {
        let normalized = this.descriptor.codec.fields.reactions.normalize(value);
        if (this._rawValue.reactions !== normalized) {
            this._rawValue.reactions = normalized;
            this._updatedValues.reactions = normalized;
            this.invalidate();
        }
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null { return this._rawValue.spans; }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null) {
        let normalized = this.descriptor.codec.fields.spans.normalize(value);
        if (this._rawValue.spans !== normalized) {
            this._rawValue.spans = normalized;
            this._updatedValues.spans = normalized;
            this.invalidate();
        }
    }
    get attachments(): ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, imagePreview: string | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null { return this._rawValue.attachments; }
    set attachments(value: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, imagePreview: string | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null) {
        let normalized = this.descriptor.codec.fields.attachments.normalize(value);
        if (this._rawValue.attachments !== normalized) {
            this._rawValue.attachments = normalized;
            this._updatedValues.attachments = normalized;
            this.invalidate();
        }
    }
    get overrideAvatar(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.overrideAvatar; }
    set overrideAvatar(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.overrideAvatar.normalize(value);
        if (this._rawValue.overrideAvatar !== normalized) {
            this._rawValue.overrideAvatar = normalized;
            this._updatedValues.overrideAvatar = normalized;
            this.invalidate();
        }
    }
    get overrideName(): string | null { return this._rawValue.overrideName; }
    set overrideName(value: string | null) {
        let normalized = this.descriptor.codec.fields.overrideName.normalize(value);
        if (this._rawValue.overrideName !== normalized) {
            this._rawValue.overrideName = normalized;
            this._updatedValues.overrideName = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get edited(): boolean | null { return this._rawValue.edited; }
    set edited(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.edited.normalize(value);
        if (this._rawValue.edited !== normalized) {
            this._rawValue.edited = normalized;
            this._updatedValues.edited = normalized;
            this.invalidate();
        }
    }
    get visible(): boolean | null { return this._rawValue.visible; }
    set visible(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.visible.normalize(value);
        if (this._rawValue.visible !== normalized) {
            this._rawValue.visible = normalized;
            this._updatedValues.visible = normalized;
            this.invalidate();
        }
    }
}

export class CommentFactory extends EntityFactory<CommentShape, Comment> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('comment');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'peer', storageKey: 'peer', type: { type: 'range', fields: [{ name: 'peerType', type: 'string' }, { name: 'peerId', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('comment', 'peer'), condition: undefined });
        secondaryIndexes.push({ name: 'child', storageKey: 'child', type: { type: 'range', fields: [{ name: 'parentCommentId', type: 'opt_integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('comment', 'child'), condition: undefined });
        secondaryIndexes.push({ name: 'repeat', storageKey: 'repeat', type: { type: 'unique', fields: [{ name: 'peerType', type: 'string' }, { name: 'peerId', type: 'integer' }, { name: 'repeatKey', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('comment', 'repeat'), condition: (src) => !!src.repeatKey });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'peerId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'peerType', type: { type: 'enum', values: ['message', 'feed_item', 'discussion'] }, secure: false });
        fields.push({ name: 'parentCommentId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'repeatKey', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'stickerId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'reactions', type: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { userId: { type: 'integer' }, reaction: { type: 'string' } } } } }, secure: false });
        fields.push({ name: 'spans', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, user: { type: 'integer' } }, multi_user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, users: { type: 'array', inner: { type: 'integer' } } }, room_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, room: { type: 'integer' } }, organization_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, organization: { type: 'integer' } }, link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, date_text: { offset: { type: 'integer' }, length: { type: 'integer' }, date: { type: 'integer' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, inline_code_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, code_block_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, insane_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, loud_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, rotating_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, all_mention: { offset: { type: 'integer' }, length: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'attachments', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { file_attachment: { id: { type: 'string' }, fileId: { type: 'string' }, filePreview: { type: 'optional', inner: { type: 'string' } }, fileMetadata: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } }, rich_attachment: { id: { type: 'string' }, title: { type: 'optional', inner: { type: 'string' } }, subTitle: { type: 'optional', inner: { type: 'string' } }, titleLink: { type: 'optional', inner: { type: 'string' } }, text: { type: 'optional', inner: { type: 'string' } }, icon: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, image: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, imagePreview: { type: 'optional', inner: { type: 'string' } }, iconInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imageFallback: { type: 'optional', inner: { type: 'struct', fields: { photo: { type: 'string' }, text: { type: 'string' } } } }, titleLinkHostname: { type: 'optional', inner: { type: 'string' } }, keyboard: { type: 'optional', inner: { type: 'struct', fields: { buttons: { type: 'array', inner: { type: 'array', inner: { type: 'struct', fields: { title: { type: 'string' }, style: { type: 'enum', values: ['DEFAULT', 'LIGHT', 'PAY'] }, url: { type: 'optional', inner: { type: 'string' } } } } } } } } }, socialImage: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, socialImagePreview: { type: 'optional', inner: { type: 'string' } }, socialImageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } } } } } }, secure: false });
        fields.push({ name: 'overrideAvatar', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'overrideName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'edited', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'visible', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            peerId: c.integer,
            peerType: c.enum('message', 'feed_item', 'discussion'),
            parentCommentId: c.optional(c.integer),
            uid: c.integer,
            repeatKey: c.optional(c.string),
            text: c.optional(c.string),
            stickerId: c.optional(c.string),
            reactions: c.optional(c.array(c.struct({ userId: c.integer, reaction: c.string }))),
            spans: c.optional(c.array(c.union({ user_mention: c.struct({ offset: c.integer, length: c.integer, user: c.integer }), multi_user_mention: c.struct({ offset: c.integer, length: c.integer, users: c.array(c.integer) }), room_mention: c.struct({ offset: c.integer, length: c.integer, room: c.integer }), organization_mention: c.struct({ offset: c.integer, length: c.integer, organization: c.integer }), link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), date_text: c.struct({ offset: c.integer, length: c.integer, date: c.integer }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }), inline_code_text: c.struct({ offset: c.integer, length: c.integer }), code_block_text: c.struct({ offset: c.integer, length: c.integer }), insane_text: c.struct({ offset: c.integer, length: c.integer }), loud_text: c.struct({ offset: c.integer, length: c.integer }), rotating_text: c.struct({ offset: c.integer, length: c.integer }), all_mention: c.struct({ offset: c.integer, length: c.integer }) }))),
            attachments: c.optional(c.array(c.union({ file_attachment: c.struct({ id: c.string, fileId: c.string, filePreview: c.optional(c.string), fileMetadata: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }), rich_attachment: c.struct({ id: c.string, title: c.optional(c.string), subTitle: c.optional(c.string), titleLink: c.optional(c.string), text: c.optional(c.string), icon: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), imagePreview: c.optional(c.string), iconInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imageFallback: c.optional(c.struct({ photo: c.string, text: c.string })), titleLinkHostname: c.optional(c.string), keyboard: c.optional(c.struct({ buttons: c.array(c.array(c.struct({ title: c.string, style: c.enum('DEFAULT', 'LIGHT', 'PAY'), url: c.optional(c.string) }))) })), socialImage: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), socialImagePreview: c.optional(c.string), socialImageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }) }))),
            overrideAvatar: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            overrideName: c.optional(c.string),
            deleted: c.optional(c.boolean),
            edited: c.optional(c.boolean),
            visible: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<CommentShape> = {
            name: 'Comment',
            storageKey: 'comment',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentShape>) {
        super(descriptor);
    }

    readonly peer = Object.freeze({
        findAll: async (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId])).items;
        },
        query: (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (peerType: 'message' | 'feed_item' | 'discussion', peerId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
        liveStream: (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
    });

    readonly child = Object.freeze({
        findAll: async (ctx: Context, parentCommentId: number | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [parentCommentId])).items;
        },
        query: (ctx: Context, parentCommentId: number | null, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [parentCommentId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (parentCommentId: number | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [parentCommentId], opts);
        },
        liveStream: (ctx: Context, parentCommentId: number | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [parentCommentId], opts);
        },
    });

    readonly repeat = Object.freeze({
        find: async (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number, repeatKey: string | null) => {
            return this._findFromUniqueIndex(ctx, [peerType, peerId, repeatKey], this.descriptor.secondaryIndexes[2]);
        },
        findAll: async (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [peerType, peerId])).items;
        },
        query: (ctx: Context, peerType: 'message' | 'feed_item' | 'discussion', peerId: number, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [peerType, peerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: CommentCreateShape): Promise<Comment> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: CommentCreateShape): Comment {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Comment | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentShape>): Comment {
        return new Comment([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface RichMessageShape {
    id: number;
    uid: number;
    oid: number | null;
    text: string | null;
    reactions: ({ userId: number, reaction: string })[] | null;
    spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null;
    attachments: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, imagePreview: string | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null;
    slides: ({ type: 'text', id: string, text: string, spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null, cover: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } | null, coverAlign: 'top' | 'bottom' | 'cover' | null, attachments: ({ type: 'user', userId: number } | { type: 'room', roomId: number } | { type: 'organization', orgId: number })[] | null })[] | null;
    overrideAvatar: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    overrideName: string | null;
    edited: boolean | null;
    deleted: boolean | null;
}

export interface RichMessageCreateShape {
    uid: number;
    oid?: number | null | undefined;
    text?: string | null | undefined;
    reactions?: ({ userId: number, reaction: string })[] | null | undefined;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null | undefined;
    attachments?: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null | undefined, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined } | { type: 'rich_attachment', id: string, title: string | null | undefined, subTitle: string | null | undefined, titleLink: string | null | undefined, text: string | null | undefined, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined, imageFallback: { photo: string, text: string } | null | undefined, imagePreview: string | null | undefined, titleLinkHostname: string | null | undefined, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null | undefined })[])[] } | null | undefined, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined, socialImagePreview: string | null | undefined, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } | null | undefined })[] | null | undefined;
    slides?: ({ type: 'text', id: string, text: string, spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null | undefined, cover: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } } | null | undefined, coverAlign: 'top' | 'bottom' | 'cover' | null | undefined, attachments: ({ type: 'user', userId: number } | { type: 'room', roomId: number } | { type: 'organization', orgId: number })[] | null | undefined })[] | null | undefined;
    overrideAvatar?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    overrideName?: string | null | undefined;
    edited?: boolean | null | undefined;
    deleted?: boolean | null | undefined;
}

export class RichMessage extends Entity<RichMessageShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get oid(): number | null { return this._rawValue.oid; }
    set oid(value: number | null) {
        let normalized = this.descriptor.codec.fields.oid.normalize(value);
        if (this._rawValue.oid !== normalized) {
            this._rawValue.oid = normalized;
            this._updatedValues.oid = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get reactions(): ({ userId: number, reaction: string })[] | null { return this._rawValue.reactions; }
    set reactions(value: ({ userId: number, reaction: string })[] | null) {
        let normalized = this.descriptor.codec.fields.reactions.normalize(value);
        if (this._rawValue.reactions !== normalized) {
            this._rawValue.reactions = normalized;
            this._updatedValues.reactions = normalized;
            this.invalidate();
        }
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null { return this._rawValue.spans; }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'organization_mention', offset: number, length: number, organization: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null) {
        let normalized = this.descriptor.codec.fields.spans.normalize(value);
        if (this._rawValue.spans !== normalized) {
            this._rawValue.spans = normalized;
            this._updatedValues.spans = normalized;
            this.invalidate();
        }
    }
    get attachments(): ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, imagePreview: string | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null { return this._rawValue.attachments; }
    set attachments(value: ({ type: 'file_attachment', id: string, fileId: string, filePreview: string | null, fileMetadata: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null } | { type: 'rich_attachment', id: string, title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, iconInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null, imageFallback: { photo: string, text: string } | null, imagePreview: string | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT' | 'PAY', url: string | null })[])[] } | null, socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null, socialImagePreview: string | null, socialImageInfo: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } | null })[] | null) {
        let normalized = this.descriptor.codec.fields.attachments.normalize(value);
        if (this._rawValue.attachments !== normalized) {
            this._rawValue.attachments = normalized;
            this._updatedValues.attachments = normalized;
            this.invalidate();
        }
    }
    get slides(): ({ type: 'text', id: string, text: string, spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null, cover: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } | null, coverAlign: 'top' | 'bottom' | 'cover' | null, attachments: ({ type: 'user', userId: number } | { type: 'room', roomId: number } | { type: 'organization', orgId: number })[] | null })[] | null { return this._rawValue.slides; }
    set slides(value: ({ type: 'text', id: string, text: string, spans: ({ type: 'user_mention', offset: number, length: number, user: number } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[] } | { type: 'room_mention', offset: number, length: number, room: number } | { type: 'link', offset: number, length: number, url: string } | { type: 'date_text', offset: number, length: number, date: number } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number } | { type: 'inline_code_text', offset: number, length: number } | { type: 'code_block_text', offset: number, length: number } | { type: 'insane_text', offset: number, length: number } | { type: 'loud_text', offset: number, length: number } | { type: 'rotating_text', offset: number, length: number } | { type: 'all_mention', offset: number, length: number })[] | null, cover: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } | null, coverAlign: 'top' | 'bottom' | 'cover' | null, attachments: ({ type: 'user', userId: number } | { type: 'room', roomId: number } | { type: 'organization', orgId: number })[] | null })[] | null) {
        let normalized = this.descriptor.codec.fields.slides.normalize(value);
        if (this._rawValue.slides !== normalized) {
            this._rawValue.slides = normalized;
            this._updatedValues.slides = normalized;
            this.invalidate();
        }
    }
    get overrideAvatar(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.overrideAvatar; }
    set overrideAvatar(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.overrideAvatar.normalize(value);
        if (this._rawValue.overrideAvatar !== normalized) {
            this._rawValue.overrideAvatar = normalized;
            this._updatedValues.overrideAvatar = normalized;
            this.invalidate();
        }
    }
    get overrideName(): string | null { return this._rawValue.overrideName; }
    set overrideName(value: string | null) {
        let normalized = this.descriptor.codec.fields.overrideName.normalize(value);
        if (this._rawValue.overrideName !== normalized) {
            this._rawValue.overrideName = normalized;
            this._updatedValues.overrideName = normalized;
            this.invalidate();
        }
    }
    get edited(): boolean | null { return this._rawValue.edited; }
    set edited(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.edited.normalize(value);
        if (this._rawValue.edited !== normalized) {
            this._rawValue.edited = normalized;
            this._updatedValues.edited = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class RichMessageFactory extends EntityFactory<RichMessageShape, RichMessage> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('richMessage');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('richMessage', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'oid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'reactions', type: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { userId: { type: 'integer' }, reaction: { type: 'string' } } } } }, secure: false });
        fields.push({ name: 'spans', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, user: { type: 'integer' } }, multi_user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, users: { type: 'array', inner: { type: 'integer' } } }, room_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, room: { type: 'integer' } }, organization_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, organization: { type: 'integer' } }, link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, date_text: { offset: { type: 'integer' }, length: { type: 'integer' }, date: { type: 'integer' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, inline_code_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, code_block_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, insane_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, loud_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, rotating_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, all_mention: { offset: { type: 'integer' }, length: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'attachments', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { file_attachment: { id: { type: 'string' }, fileId: { type: 'string' }, filePreview: { type: 'optional', inner: { type: 'string' } }, fileMetadata: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } }, rich_attachment: { id: { type: 'string' }, title: { type: 'optional', inner: { type: 'string' } }, subTitle: { type: 'optional', inner: { type: 'string' } }, titleLink: { type: 'optional', inner: { type: 'string' } }, text: { type: 'optional', inner: { type: 'string' } }, icon: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, image: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, iconInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } }, imageFallback: { type: 'optional', inner: { type: 'struct', fields: { photo: { type: 'string' }, text: { type: 'string' } } } }, imagePreview: { type: 'optional', inner: { type: 'string' } }, titleLinkHostname: { type: 'optional', inner: { type: 'string' } }, keyboard: { type: 'optional', inner: { type: 'struct', fields: { buttons: { type: 'array', inner: { type: 'array', inner: { type: 'struct', fields: { title: { type: 'string' }, style: { type: 'enum', values: ['DEFAULT', 'LIGHT', 'PAY'] }, url: { type: 'optional', inner: { type: 'string' } } } } } } } } }, socialImage: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, socialImagePreview: { type: 'optional', inner: { type: 'string' } }, socialImageInfo: { type: 'optional', inner: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } } } } } }, secure: false });
        fields.push({ name: 'slides', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { text: { id: { type: 'string' }, text: { type: 'string' }, spans: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, user: { type: 'integer' } }, multi_user_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, users: { type: 'array', inner: { type: 'integer' } } }, room_mention: { offset: { type: 'integer' }, length: { type: 'integer' }, room: { type: 'integer' } }, link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, date_text: { offset: { type: 'integer' }, length: { type: 'integer' }, date: { type: 'integer' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, inline_code_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, code_block_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, insane_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, loud_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, rotating_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, all_mention: { offset: { type: 'integer' }, length: { type: 'integer' } } } } } }, cover: { type: 'optional', inner: { type: 'struct', fields: { image: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, info: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } } }, coverAlign: { type: 'optional', inner: { type: 'enum', values: ['top', 'bottom', 'cover'] } }, attachments: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { user: { userId: { type: 'integer' } }, room: { roomId: { type: 'integer' } }, organization: { orgId: { type: 'integer' } } } } } } } } } } }, secure: false });
        fields.push({ name: 'overrideAvatar', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'overrideName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'edited', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
            oid: c.optional(c.integer),
            text: c.optional(c.string),
            reactions: c.optional(c.array(c.struct({ userId: c.integer, reaction: c.string }))),
            spans: c.optional(c.array(c.union({ user_mention: c.struct({ offset: c.integer, length: c.integer, user: c.integer }), multi_user_mention: c.struct({ offset: c.integer, length: c.integer, users: c.array(c.integer) }), room_mention: c.struct({ offset: c.integer, length: c.integer, room: c.integer }), organization_mention: c.struct({ offset: c.integer, length: c.integer, organization: c.integer }), link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), date_text: c.struct({ offset: c.integer, length: c.integer, date: c.integer }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }), inline_code_text: c.struct({ offset: c.integer, length: c.integer }), code_block_text: c.struct({ offset: c.integer, length: c.integer }), insane_text: c.struct({ offset: c.integer, length: c.integer }), loud_text: c.struct({ offset: c.integer, length: c.integer }), rotating_text: c.struct({ offset: c.integer, length: c.integer }), all_mention: c.struct({ offset: c.integer, length: c.integer }) }))),
            attachments: c.optional(c.array(c.union({ file_attachment: c.struct({ id: c.string, fileId: c.string, filePreview: c.optional(c.string), fileMetadata: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }), rich_attachment: c.struct({ id: c.string, title: c.optional(c.string), subTitle: c.optional(c.string), titleLink: c.optional(c.string), text: c.optional(c.string), icon: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), iconInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })), imageFallback: c.optional(c.struct({ photo: c.string, text: c.string })), imagePreview: c.optional(c.string), titleLinkHostname: c.optional(c.string), keyboard: c.optional(c.struct({ buttons: c.array(c.array(c.struct({ title: c.string, style: c.enum('DEFAULT', 'LIGHT', 'PAY'), url: c.optional(c.string) }))) })), socialImage: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })), socialImagePreview: c.optional(c.string), socialImageInfo: c.optional(c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string })) }) }))),
            slides: c.optional(c.array(c.union({ text: c.struct({ id: c.string, text: c.string, spans: c.optional(c.array(c.union({ user_mention: c.struct({ offset: c.integer, length: c.integer, user: c.integer }), multi_user_mention: c.struct({ offset: c.integer, length: c.integer, users: c.array(c.integer) }), room_mention: c.struct({ offset: c.integer, length: c.integer, room: c.integer }), link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), date_text: c.struct({ offset: c.integer, length: c.integer, date: c.integer }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }), inline_code_text: c.struct({ offset: c.integer, length: c.integer }), code_block_text: c.struct({ offset: c.integer, length: c.integer }), insane_text: c.struct({ offset: c.integer, length: c.integer }), loud_text: c.struct({ offset: c.integer, length: c.integer }), rotating_text: c.struct({ offset: c.integer, length: c.integer }), all_mention: c.struct({ offset: c.integer, length: c.integer }) }))), cover: c.optional(c.struct({ image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }), info: c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string }) })), coverAlign: c.optional(c.enum('top', 'bottom', 'cover')), attachments: c.optional(c.array(c.union({ user: c.struct({ userId: c.integer }), room: c.struct({ roomId: c.integer }), organization: c.struct({ orgId: c.integer }) }))) }) }))),
            overrideAvatar: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            overrideName: c.optional(c.string),
            edited: c.optional(c.boolean),
            deleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<RichMessageShape> = {
            name: 'RichMessage',
            storageKey: 'richMessage',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new RichMessageFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<RichMessageShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, id: number, src: RichMessageCreateShape): Promise<RichMessage> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: RichMessageCreateShape): RichMessage {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<RichMessage | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<RichMessageShape>): RichMessage {
        return new RichMessage([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface MessageDraftShape {
    uid: number;
    cid: number;
    contents: string | null;
}

export interface MessageDraftCreateShape {
    contents?: string | null | undefined;
}

export class MessageDraft extends Entity<MessageDraftShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get contents(): string | null { return this._rawValue.contents; }
    set contents(value: string | null) {
        let normalized = this.descriptor.codec.fields.contents.normalize(value);
        if (this._rawValue.contents !== normalized) {
            this._rawValue.contents = normalized;
            this._updatedValues.contents = normalized;
            this.invalidate();
        }
    }
}

export class MessageDraftFactory extends EntityFactory<MessageDraftShape, MessageDraft> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('messageDraft');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'contents', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            contents: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<MessageDraftShape> = {
            name: 'MessageDraft',
            storageKey: 'messageDraft',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new MessageDraftFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<MessageDraftShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, cid: number, src: MessageDraftCreateShape): Promise<MessageDraft> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, src: MessageDraftCreateShape): MessageDraft {
        return this._create_UNSAFE(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<MessageDraft | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<MessageDraftShape>): MessageDraft {
        return new MessageDraft([value.uid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationSeqShape {
    cid: number;
    seq: number;
}

export interface ConversationSeqCreateShape {
    seq: number;
}

export class ConversationSeq extends Entity<ConversationSeqShape> {
    get cid(): number { return this._rawValue.cid; }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
}

export class ConversationSeqFactory extends EntityFactory<ConversationSeqShape, ConversationSeq> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversationSeq');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            cid: c.integer,
            seq: c.integer,
        });
        let descriptor: EntityDescriptor<ConversationSeqShape> = {
            name: 'ConversationSeq',
            storageKey: 'conversationSeq',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationSeqFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationSeqShape>) {
        super(descriptor);
    }

    create(ctx: Context, cid: number, src: ConversationSeqCreateShape): Promise<ConversationSeq> {
        return this._create(ctx, [cid], this.descriptor.codec.normalize({ cid, ...src }));
    }

    create_UNSAFE(ctx: Context, cid: number, src: ConversationSeqCreateShape): ConversationSeq {
        return this._create_UNSAFE(ctx, [cid], this.descriptor.codec.normalize({ cid, ...src }));
    }

    findById(ctx: Context, cid: number): Promise<ConversationSeq | null> {
        return this._findById(ctx, [cid]);
    }

    watch(ctx: Context, cid: number): Watch {
        return this._watch(ctx, [cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationSeqShape>): ConversationSeq {
        return new ConversationSeq([value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConversationEventShape {
    cid: number;
    seq: number;
    uid: number | null;
    mid: number | null;
    kind: 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted';
}

export interface ConversationEventCreateShape {
    uid?: number | null | undefined;
    mid?: number | null | undefined;
    kind: 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted';
}

export class ConversationEvent extends Entity<ConversationEventShape> {
    get cid(): number { return this._rawValue.cid; }
    get seq(): number { return this._rawValue.seq; }
    get uid(): number | null { return this._rawValue.uid; }
    set uid(value: number | null) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get mid(): number | null { return this._rawValue.mid; }
    set mid(value: number | null) {
        let normalized = this.descriptor.codec.fields.mid.normalize(value);
        if (this._rawValue.mid !== normalized) {
            this._rawValue.mid = normalized;
            this._updatedValues.mid = normalized;
            this.invalidate();
        }
    }
    get kind(): 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted' { return this._rawValue.kind; }
    set kind(value: 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class ConversationEventFactory extends EntityFactory<ConversationEventShape, ConversationEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conversationEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conversationEvent', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'cid', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'mid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['chat_updated', 'message_received', 'message_updated', 'message_deleted'] }, secure: false });
        let codec = c.struct({
            cid: c.integer,
            seq: c.integer,
            uid: c.optional(c.integer),
            mid: c.optional(c.integer),
            kind: c.enum('chat_updated', 'message_received', 'message_updated', 'message_deleted'),
        });
        let descriptor: EntityDescriptor<ConversationEventShape> = {
            name: 'ConversationEvent',
            storageKey: 'conversationEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConversationEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConversationEventShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, cid: number, seq: number, src: ConversationEventCreateShape): Promise<ConversationEvent> {
        return this._create(ctx, [cid, seq], this.descriptor.codec.normalize({ cid, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, cid: number, seq: number, src: ConversationEventCreateShape): ConversationEvent {
        return this._create_UNSAFE(ctx, [cid, seq], this.descriptor.codec.normalize({ cid, seq, ...src }));
    }

    findById(ctx: Context, cid: number, seq: number): Promise<ConversationEvent | null> {
        return this._findById(ctx, [cid, seq]);
    }

    watch(ctx: Context, cid: number, seq: number): Watch {
        return this._watch(ctx, [cid, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConversationEventShape>): ConversationEvent {
        return new ConversationEvent([value.cid, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserDialogShape {
    uid: number;
    cid: number;
    unread: number;
    readMessageId: number | null;
    date: number | null;
    haveMention: boolean | null;
    title: string | null;
    photo: any | null;
}

export interface UserDialogCreateShape {
    unread: number;
    readMessageId?: number | null | undefined;
    date?: number | null | undefined;
    haveMention?: boolean | null | undefined;
    title?: string | null | undefined;
    photo?: any | null | undefined;
}

export class UserDialog extends Entity<UserDialogShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get unread(): number { return this._rawValue.unread; }
    set unread(value: number) {
        let normalized = this.descriptor.codec.fields.unread.normalize(value);
        if (this._rawValue.unread !== normalized) {
            this._rawValue.unread = normalized;
            this._updatedValues.unread = normalized;
            this.invalidate();
        }
    }
    get readMessageId(): number | null { return this._rawValue.readMessageId; }
    set readMessageId(value: number | null) {
        let normalized = this.descriptor.codec.fields.readMessageId.normalize(value);
        if (this._rawValue.readMessageId !== normalized) {
            this._rawValue.readMessageId = normalized;
            this._updatedValues.readMessageId = normalized;
            this.invalidate();
        }
    }
    get date(): number | null { return this._rawValue.date; }
    set date(value: number | null) {
        let normalized = this.descriptor.codec.fields.date.normalize(value);
        if (this._rawValue.date !== normalized) {
            this._rawValue.date = normalized;
            this._updatedValues.date = normalized;
            this.invalidate();
        }
    }
    get haveMention(): boolean | null { return this._rawValue.haveMention; }
    set haveMention(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.haveMention.normalize(value);
        if (this._rawValue.haveMention !== normalized) {
            this._rawValue.haveMention = normalized;
            this._updatedValues.haveMention = normalized;
            this.invalidate();
        }
    }
    get title(): string | null { return this._rawValue.title; }
    set title(value: string | null) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get photo(): any | null { return this._rawValue.photo; }
    set photo(value: any | null) {
        let normalized = this.descriptor.codec.fields.photo.normalize(value);
        if (this._rawValue.photo !== normalized) {
            this._rawValue.photo = normalized;
            this._updatedValues.photo = normalized;
            this.invalidate();
        }
    }
}

export class UserDialogFactory extends EntityFactory<UserDialogShape, UserDialog> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userDialog');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'date', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userDialog', 'user'), condition: (src) => !!src.date });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userDialog', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'unread', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'readMessageId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'date', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'haveMention', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'title', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'photo', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            unread: c.integer,
            readMessageId: c.optional(c.integer),
            date: c.optional(c.integer),
            haveMention: c.optional(c.boolean),
            title: c.optional(c.string),
            photo: c.optional(c.any),
        });
        let descriptor: EntityDescriptor<UserDialogShape> = {
            name: 'UserDialog',
            storageKey: 'userDialog',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserDialogFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserDialogShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, uid: number, cid: number, src: UserDialogCreateShape): Promise<UserDialog> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, src: UserDialogCreateShape): UserDialog {
        return this._create_UNSAFE(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<UserDialog | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserDialogShape>): UserDialog {
        return new UserDialog([value.uid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserDialogHandledMessageShape {
    uid: number;
    cid: number;
    mid: number;
}

export interface UserDialogHandledMessageCreateShape {
}

export class UserDialogHandledMessage extends Entity<UserDialogHandledMessageShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get mid(): number { return this._rawValue.mid; }
}

export class UserDialogHandledMessageFactory extends EntityFactory<UserDialogHandledMessageShape, UserDialogHandledMessage> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userDialogHandledMessage');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        primaryKeys.push({ name: 'mid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            mid: c.integer,
        });
        let descriptor: EntityDescriptor<UserDialogHandledMessageShape> = {
            name: 'UserDialogHandledMessage',
            storageKey: 'userDialogHandledMessage',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserDialogHandledMessageFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserDialogHandledMessageShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, cid: number, mid: number, src: UserDialogHandledMessageCreateShape): Promise<UserDialogHandledMessage> {
        return this._create(ctx, [uid, cid, mid], this.descriptor.codec.normalize({ uid, cid, mid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, mid: number, src: UserDialogHandledMessageCreateShape): UserDialogHandledMessage {
        return this._create_UNSAFE(ctx, [uid, cid, mid], this.descriptor.codec.normalize({ uid, cid, mid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number, mid: number): Promise<UserDialogHandledMessage | null> {
        return this._findById(ctx, [uid, cid, mid]);
    }

    watch(ctx: Context, uid: number, cid: number, mid: number): Watch {
        return this._watch(ctx, [uid, cid, mid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserDialogHandledMessageShape>): UserDialogHandledMessage {
        return new UserDialogHandledMessage([value.uid, value.cid, value.mid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserDialogSettingsShape {
    uid: number;
    cid: number;
    mute: boolean;
}

export interface UserDialogSettingsCreateShape {
    mute: boolean;
}

export class UserDialogSettings extends Entity<UserDialogSettingsShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get mute(): boolean { return this._rawValue.mute; }
    set mute(value: boolean) {
        let normalized = this.descriptor.codec.fields.mute.normalize(value);
        if (this._rawValue.mute !== normalized) {
            this._rawValue.mute = normalized;
            this._updatedValues.mute = normalized;
            this.invalidate();
        }
    }
}

export class UserDialogSettingsFactory extends EntityFactory<UserDialogSettingsShape, UserDialogSettings> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userDialogSettings');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'mute', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            mute: c.boolean,
        });
        let descriptor: EntityDescriptor<UserDialogSettingsShape> = {
            name: 'UserDialogSettings',
            storageKey: 'userDialogSettings',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserDialogSettingsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserDialogSettingsShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, cid: number, src: UserDialogSettingsCreateShape): Promise<UserDialogSettings> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, src: UserDialogSettingsCreateShape): UserDialogSettings {
        return this._create_UNSAFE(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<UserDialogSettings | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserDialogSettingsShape>): UserDialogSettings {
        return new UserDialogSettings([value.uid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserDialogEventShape {
    uid: number;
    seq: number;
    cid: number | null;
    mid: number | null;
    allUnread: number | null;
    unread: number | null;
    title: string | null;
    photo: any | null;
    mute: boolean | null;
    haveMention: boolean | null;
    kind: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed';
}

export interface UserDialogEventCreateShape {
    cid?: number | null | undefined;
    mid?: number | null | undefined;
    allUnread?: number | null | undefined;
    unread?: number | null | undefined;
    title?: string | null | undefined;
    photo?: any | null | undefined;
    mute?: boolean | null | undefined;
    haveMention?: boolean | null | undefined;
    kind: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed';
}

export class UserDialogEvent extends Entity<UserDialogEventShape> {
    get uid(): number { return this._rawValue.uid; }
    get seq(): number { return this._rawValue.seq; }
    get cid(): number | null { return this._rawValue.cid; }
    set cid(value: number | null) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get mid(): number | null { return this._rawValue.mid; }
    set mid(value: number | null) {
        let normalized = this.descriptor.codec.fields.mid.normalize(value);
        if (this._rawValue.mid !== normalized) {
            this._rawValue.mid = normalized;
            this._updatedValues.mid = normalized;
            this.invalidate();
        }
    }
    get allUnread(): number | null { return this._rawValue.allUnread; }
    set allUnread(value: number | null) {
        let normalized = this.descriptor.codec.fields.allUnread.normalize(value);
        if (this._rawValue.allUnread !== normalized) {
            this._rawValue.allUnread = normalized;
            this._updatedValues.allUnread = normalized;
            this.invalidate();
        }
    }
    get unread(): number | null { return this._rawValue.unread; }
    set unread(value: number | null) {
        let normalized = this.descriptor.codec.fields.unread.normalize(value);
        if (this._rawValue.unread !== normalized) {
            this._rawValue.unread = normalized;
            this._updatedValues.unread = normalized;
            this.invalidate();
        }
    }
    get title(): string | null { return this._rawValue.title; }
    set title(value: string | null) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get photo(): any | null { return this._rawValue.photo; }
    set photo(value: any | null) {
        let normalized = this.descriptor.codec.fields.photo.normalize(value);
        if (this._rawValue.photo !== normalized) {
            this._rawValue.photo = normalized;
            this._updatedValues.photo = normalized;
            this.invalidate();
        }
    }
    get mute(): boolean | null { return this._rawValue.mute; }
    set mute(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.mute.normalize(value);
        if (this._rawValue.mute !== normalized) {
            this._rawValue.mute = normalized;
            this._updatedValues.mute = normalized;
            this.invalidate();
        }
    }
    get haveMention(): boolean | null { return this._rawValue.haveMention; }
    set haveMention(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.haveMention.normalize(value);
        if (this._rawValue.haveMention !== normalized) {
            this._rawValue.haveMention = normalized;
            this._updatedValues.haveMention = normalized;
            this.invalidate();
        }
    }
    get kind(): 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed' { return this._rawValue.kind; }
    set kind(value: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class UserDialogEventFactory extends EntityFactory<UserDialogEventShape, UserDialogEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userDialogEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userDialogEvent', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'mid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'allUnread', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'unread', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'title', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'photo', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'mute', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'haveMention', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated', 'dialog_deleted', 'dialog_bump', 'photo_updated', 'dialog_mute_changed', 'dialog_mentioned_changed'] }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            seq: c.integer,
            cid: c.optional(c.integer),
            mid: c.optional(c.integer),
            allUnread: c.optional(c.integer),
            unread: c.optional(c.integer),
            title: c.optional(c.string),
            photo: c.optional(c.any),
            mute: c.optional(c.boolean),
            haveMention: c.optional(c.boolean),
            kind: c.enum('message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated', 'dialog_deleted', 'dialog_bump', 'photo_updated', 'dialog_mute_changed', 'dialog_mentioned_changed'),
        });
        let descriptor: EntityDescriptor<UserDialogEventShape> = {
            name: 'UserDialogEvent',
            storageKey: 'userDialogEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserDialogEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserDialogEventShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, seq: number, src: UserDialogEventCreateShape): Promise<UserDialogEvent> {
        return this._create(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, seq: number, src: UserDialogEventCreateShape): UserDialogEvent {
        return this._create_UNSAFE(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    findById(ctx: Context, uid: number, seq: number): Promise<UserDialogEvent | null> {
        return this._findById(ctx, [uid, seq]);
    }

    watch(ctx: Context, uid: number, seq: number): Watch {
        return this._watch(ctx, [uid, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserDialogEventShape>): UserDialogEvent {
        return new UserDialogEvent([value.uid, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentStateShape {
    peerType: string;
    peerId: number;
    commentsCount: number;
}

export interface CommentStateCreateShape {
    commentsCount: number;
}

export class CommentState extends Entity<CommentStateShape> {
    get peerType(): string { return this._rawValue.peerType; }
    get peerId(): number { return this._rawValue.peerId; }
    get commentsCount(): number { return this._rawValue.commentsCount; }
    set commentsCount(value: number) {
        let normalized = this.descriptor.codec.fields.commentsCount.normalize(value);
        if (this._rawValue.commentsCount !== normalized) {
            this._rawValue.commentsCount = normalized;
            this._updatedValues.commentsCount = normalized;
            this.invalidate();
        }
    }
}

export class CommentStateFactory extends EntityFactory<CommentStateShape, CommentState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('commentState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'commentsCount', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            peerType: c.string,
            peerId: c.integer,
            commentsCount: c.integer,
        });
        let descriptor: EntityDescriptor<CommentStateShape> = {
            name: 'CommentState',
            storageKey: 'commentState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, peerType: string, peerId: number, src: CommentStateCreateShape): Promise<CommentState> {
        return this._create(ctx, [peerType, peerId], this.descriptor.codec.normalize({ peerType, peerId, ...src }));
    }

    create_UNSAFE(ctx: Context, peerType: string, peerId: number, src: CommentStateCreateShape): CommentState {
        return this._create_UNSAFE(ctx, [peerType, peerId], this.descriptor.codec.normalize({ peerType, peerId, ...src }));
    }

    findById(ctx: Context, peerType: string, peerId: number): Promise<CommentState | null> {
        return this._findById(ctx, [peerType, peerId]);
    }

    watch(ctx: Context, peerType: string, peerId: number): Watch {
        return this._watch(ctx, [peerType, peerId]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentStateShape>): CommentState {
        return new CommentState([value.peerType, value.peerId], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentSeqShape {
    peerType: string;
    peerId: number;
    seq: number;
}

export interface CommentSeqCreateShape {
    seq: number;
}

export class CommentSeq extends Entity<CommentSeqShape> {
    get peerType(): string { return this._rawValue.peerType; }
    get peerId(): number { return this._rawValue.peerId; }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
}

export class CommentSeqFactory extends EntityFactory<CommentSeqShape, CommentSeq> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('commentSeq');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            peerType: c.string,
            peerId: c.integer,
            seq: c.integer,
        });
        let descriptor: EntityDescriptor<CommentSeqShape> = {
            name: 'CommentSeq',
            storageKey: 'commentSeq',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentSeqFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentSeqShape>) {
        super(descriptor);
    }

    create(ctx: Context, peerType: string, peerId: number, src: CommentSeqCreateShape): Promise<CommentSeq> {
        return this._create(ctx, [peerType, peerId], this.descriptor.codec.normalize({ peerType, peerId, ...src }));
    }

    create_UNSAFE(ctx: Context, peerType: string, peerId: number, src: CommentSeqCreateShape): CommentSeq {
        return this._create_UNSAFE(ctx, [peerType, peerId], this.descriptor.codec.normalize({ peerType, peerId, ...src }));
    }

    findById(ctx: Context, peerType: string, peerId: number): Promise<CommentSeq | null> {
        return this._findById(ctx, [peerType, peerId]);
    }

    watch(ctx: Context, peerType: string, peerId: number): Watch {
        return this._watch(ctx, [peerType, peerId]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentSeqShape>): CommentSeq {
        return new CommentSeq([value.peerType, value.peerId], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentEventShape {
    peerType: string;
    peerId: number;
    seq: number;
    uid: number | null;
    commentId: number | null;
    kind: 'comment_received' | 'comment_updated';
}

export interface CommentEventCreateShape {
    uid?: number | null | undefined;
    commentId?: number | null | undefined;
    kind: 'comment_received' | 'comment_updated';
}

export class CommentEvent extends Entity<CommentEventShape> {
    get peerType(): string { return this._rawValue.peerType; }
    get peerId(): number { return this._rawValue.peerId; }
    get seq(): number { return this._rawValue.seq; }
    get uid(): number | null { return this._rawValue.uid; }
    set uid(value: number | null) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get commentId(): number | null { return this._rawValue.commentId; }
    set commentId(value: number | null) {
        let normalized = this.descriptor.codec.fields.commentId.normalize(value);
        if (this._rawValue.commentId !== normalized) {
            this._rawValue.commentId = normalized;
            this._updatedValues.commentId = normalized;
            this.invalidate();
        }
    }
    get kind(): 'comment_received' | 'comment_updated' { return this._rawValue.kind; }
    set kind(value: 'comment_received' | 'comment_updated') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class CommentEventFactory extends EntityFactory<CommentEventShape, CommentEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('commentEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'peerType', type: 'string' }, { name: 'peerId', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('commentEvent', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'commentId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['comment_received', 'comment_updated'] }, secure: false });
        let codec = c.struct({
            peerType: c.string,
            peerId: c.integer,
            seq: c.integer,
            uid: c.optional(c.integer),
            commentId: c.optional(c.integer),
            kind: c.enum('comment_received', 'comment_updated'),
        });
        let descriptor: EntityDescriptor<CommentEventShape> = {
            name: 'CommentEvent',
            storageKey: 'commentEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentEventShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, peerType: string, peerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId])).items;
        },
        query: (ctx: Context, peerType: string, peerId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
        liveStream: (ctx: Context, peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
    });

    create(ctx: Context, peerType: string, peerId: number, seq: number, src: CommentEventCreateShape): Promise<CommentEvent> {
        return this._create(ctx, [peerType, peerId, seq], this.descriptor.codec.normalize({ peerType, peerId, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, peerType: string, peerId: number, seq: number, src: CommentEventCreateShape): CommentEvent {
        return this._create_UNSAFE(ctx, [peerType, peerId, seq], this.descriptor.codec.normalize({ peerType, peerId, seq, ...src }));
    }

    findById(ctx: Context, peerType: string, peerId: number, seq: number): Promise<CommentEvent | null> {
        return this._findById(ctx, [peerType, peerId, seq]);
    }

    watch(ctx: Context, peerType: string, peerId: number, seq: number): Watch {
        return this._watch(ctx, [peerType, peerId, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentEventShape>): CommentEvent {
        return new CommentEvent([value.peerType, value.peerId, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentsSubscriptionShape {
    peerType: string;
    peerId: number;
    uid: number;
    kind: 'all' | 'direct';
    status: 'active' | 'disabled';
}

export interface CommentsSubscriptionCreateShape {
    kind: 'all' | 'direct';
    status: 'active' | 'disabled';
}

export class CommentsSubscription extends Entity<CommentsSubscriptionShape> {
    get peerType(): string { return this._rawValue.peerType; }
    get peerId(): number { return this._rawValue.peerId; }
    get uid(): number { return this._rawValue.uid; }
    get kind(): 'all' | 'direct' { return this._rawValue.kind; }
    set kind(value: 'all' | 'direct') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get status(): 'active' | 'disabled' { return this._rawValue.status; }
    set status(value: 'active' | 'disabled') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class CommentsSubscriptionFactory extends EntityFactory<CommentsSubscriptionShape, CommentsSubscription> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('commentsSubscription');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'peer', storageKey: 'peer', type: { type: 'range', fields: [{ name: 'peerType', type: 'string' }, { name: 'peerId', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('commentsSubscription', 'peer'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'kind', type: { type: 'enum', values: ['all', 'direct'] }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['active', 'disabled'] }, secure: false });
        let codec = c.struct({
            peerType: c.string,
            peerId: c.integer,
            uid: c.integer,
            kind: c.enum('all', 'direct'),
            status: c.enum('active', 'disabled'),
        });
        let descriptor: EntityDescriptor<CommentsSubscriptionShape> = {
            name: 'CommentsSubscription',
            storageKey: 'commentsSubscription',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentsSubscriptionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentsSubscriptionShape>) {
        super(descriptor);
    }

    readonly peer = Object.freeze({
        findAll: async (ctx: Context, peerType: string, peerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId])).items;
        },
        query: (ctx: Context, peerType: string, peerId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
        liveStream: (ctx: Context, peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
    });

    create(ctx: Context, peerType: string, peerId: number, uid: number, src: CommentsSubscriptionCreateShape): Promise<CommentsSubscription> {
        return this._create(ctx, [peerType, peerId, uid], this.descriptor.codec.normalize({ peerType, peerId, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, peerType: string, peerId: number, uid: number, src: CommentsSubscriptionCreateShape): CommentsSubscription {
        return this._create_UNSAFE(ctx, [peerType, peerId, uid], this.descriptor.codec.normalize({ peerType, peerId, uid, ...src }));
    }

    findById(ctx: Context, peerType: string, peerId: number, uid: number): Promise<CommentsSubscription | null> {
        return this._findById(ctx, [peerType, peerId, uid]);
    }

    watch(ctx: Context, peerType: string, peerId: number, uid: number): Watch {
        return this._watch(ctx, [peerType, peerId, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentsSubscriptionShape>): CommentsSubscription {
        return new CommentsSubscription([value.peerType, value.peerId, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface CommentEventGlobalShape {
    uid: number;
    seq: number;
    peerType: string | null;
    peerId: number | null;
    kind: 'comments_peer_updated';
}

export interface CommentEventGlobalCreateShape {
    peerType?: string | null | undefined;
    peerId?: number | null | undefined;
    kind: 'comments_peer_updated';
}

export class CommentEventGlobal extends Entity<CommentEventGlobalShape> {
    get uid(): number { return this._rawValue.uid; }
    get seq(): number { return this._rawValue.seq; }
    get peerType(): string | null { return this._rawValue.peerType; }
    set peerType(value: string | null) {
        let normalized = this.descriptor.codec.fields.peerType.normalize(value);
        if (this._rawValue.peerType !== normalized) {
            this._rawValue.peerType = normalized;
            this._updatedValues.peerType = normalized;
            this.invalidate();
        }
    }
    get peerId(): number | null { return this._rawValue.peerId; }
    set peerId(value: number | null) {
        let normalized = this.descriptor.codec.fields.peerId.normalize(value);
        if (this._rawValue.peerId !== normalized) {
            this._rawValue.peerId = normalized;
            this._updatedValues.peerId = normalized;
            this.invalidate();
        }
    }
    get kind(): 'comments_peer_updated' { return this._rawValue.kind; }
    set kind(value: 'comments_peer_updated') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class CommentEventGlobalFactory extends EntityFactory<CommentEventGlobalShape, CommentEventGlobal> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('commentEventGlobal');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('commentEventGlobal', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'peerType', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'peerId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['comments_peer_updated'] }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            seq: c.integer,
            peerType: c.optional(c.string),
            peerId: c.optional(c.integer),
            kind: c.enum('comments_peer_updated'),
        });
        let descriptor: EntityDescriptor<CommentEventGlobalShape> = {
            name: 'CommentEventGlobal',
            storageKey: 'commentEventGlobal',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new CommentEventGlobalFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<CommentEventGlobalShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, seq: number, src: CommentEventGlobalCreateShape): Promise<CommentEventGlobal> {
        return this._create(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, seq: number, src: CommentEventGlobalCreateShape): CommentEventGlobal {
        return this._create_UNSAFE(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    findById(ctx: Context, uid: number, seq: number): Promise<CommentEventGlobal | null> {
        return this._findById(ctx, [uid, seq]);
    }

    watch(ctx: Context, uid: number, seq: number): Watch {
        return this._watch(ctx, [uid, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<CommentEventGlobalShape>): CommentEventGlobal {
        return new CommentEventGlobal([value.uid, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceRoomShape {
    id: number;
    scheduler: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null;
    currentScheduler: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null;
    startTime: number | null;
    kind: 'conference' | 'stream' | null;
    screenSharingPeerId: number | null;
    streamerId: number | null;
    active: boolean | null;
}

export interface ConferenceRoomCreateShape {
    scheduler?: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null | undefined;
    currentScheduler?: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null | undefined;
    startTime?: number | null | undefined;
    kind?: 'conference' | 'stream' | null | undefined;
    screenSharingPeerId?: number | null | undefined;
    streamerId?: number | null | undefined;
    active?: boolean | null | undefined;
}

export class ConferenceRoom extends Entity<ConferenceRoomShape> {
    get id(): number { return this._rawValue.id; }
    get scheduler(): 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null { return this._rawValue.scheduler; }
    set scheduler(value: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null) {
        let normalized = this.descriptor.codec.fields.scheduler.normalize(value);
        if (this._rawValue.scheduler !== normalized) {
            this._rawValue.scheduler = normalized;
            this._updatedValues.scheduler = normalized;
            this.invalidate();
        }
    }
    get currentScheduler(): 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null { return this._rawValue.currentScheduler; }
    set currentScheduler(value: 'mesh' | 'mesh-no-relay' | 'basic-sfu' | null) {
        let normalized = this.descriptor.codec.fields.currentScheduler.normalize(value);
        if (this._rawValue.currentScheduler !== normalized) {
            this._rawValue.currentScheduler = normalized;
            this._updatedValues.currentScheduler = normalized;
            this.invalidate();
        }
    }
    get startTime(): number | null { return this._rawValue.startTime; }
    set startTime(value: number | null) {
        let normalized = this.descriptor.codec.fields.startTime.normalize(value);
        if (this._rawValue.startTime !== normalized) {
            this._rawValue.startTime = normalized;
            this._updatedValues.startTime = normalized;
            this.invalidate();
        }
    }
    get kind(): 'conference' | 'stream' | null { return this._rawValue.kind; }
    set kind(value: 'conference' | 'stream' | null) {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get screenSharingPeerId(): number | null { return this._rawValue.screenSharingPeerId; }
    set screenSharingPeerId(value: number | null) {
        let normalized = this.descriptor.codec.fields.screenSharingPeerId.normalize(value);
        if (this._rawValue.screenSharingPeerId !== normalized) {
            this._rawValue.screenSharingPeerId = normalized;
            this._updatedValues.screenSharingPeerId = normalized;
            this.invalidate();
        }
    }
    get streamerId(): number | null { return this._rawValue.streamerId; }
    set streamerId(value: number | null) {
        let normalized = this.descriptor.codec.fields.streamerId.normalize(value);
        if (this._rawValue.streamerId !== normalized) {
            this._rawValue.streamerId = normalized;
            this._updatedValues.streamerId = normalized;
            this.invalidate();
        }
    }
    get active(): boolean | null { return this._rawValue.active; }
    set active(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceRoomFactory extends EntityFactory<ConferenceRoomShape, ConferenceRoom> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceRoom');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'scheduler', type: { type: 'optional', inner: { type: 'enum', values: ['mesh', 'mesh-no-relay', 'basic-sfu'] } }, secure: false });
        fields.push({ name: 'currentScheduler', type: { type: 'optional', inner: { type: 'enum', values: ['mesh', 'mesh-no-relay', 'basic-sfu'] } }, secure: false });
        fields.push({ name: 'startTime', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'optional', inner: { type: 'enum', values: ['conference', 'stream'] } }, secure: false });
        fields.push({ name: 'screenSharingPeerId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'streamerId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'active', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            scheduler: c.optional(c.enum('mesh', 'mesh-no-relay', 'basic-sfu')),
            currentScheduler: c.optional(c.enum('mesh', 'mesh-no-relay', 'basic-sfu')),
            startTime: c.optional(c.integer),
            kind: c.optional(c.enum('conference', 'stream')),
            screenSharingPeerId: c.optional(c.integer),
            streamerId: c.optional(c.integer),
            active: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<ConferenceRoomShape> = {
            name: 'ConferenceRoom',
            storageKey: 'conferenceRoom',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceRoomFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceRoomShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: ConferenceRoomCreateShape): Promise<ConferenceRoom> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConferenceRoomCreateShape): ConferenceRoom {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConferenceRoom | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceRoomShape>): ConferenceRoom {
        return new ConferenceRoom([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferencePeerShape {
    id: number;
    cid: number;
    uid: number;
    tid: string;
    keepAliveTimeout: number;
    enabled: boolean;
    videoPaused: boolean | null;
    audioPaused: boolean | null;
}

export interface ConferencePeerCreateShape {
    cid: number;
    uid: number;
    tid: string;
    keepAliveTimeout: number;
    enabled: boolean;
    videoPaused?: boolean | null | undefined;
    audioPaused?: boolean | null | undefined;
}

export class ConferencePeer extends Entity<ConferencePeerShape> {
    get id(): number { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get keepAliveTimeout(): number { return this._rawValue.keepAliveTimeout; }
    set keepAliveTimeout(value: number) {
        let normalized = this.descriptor.codec.fields.keepAliveTimeout.normalize(value);
        if (this._rawValue.keepAliveTimeout !== normalized) {
            this._rawValue.keepAliveTimeout = normalized;
            this._updatedValues.keepAliveTimeout = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get videoPaused(): boolean | null { return this._rawValue.videoPaused; }
    set videoPaused(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.videoPaused.normalize(value);
        if (this._rawValue.videoPaused !== normalized) {
            this._rawValue.videoPaused = normalized;
            this._updatedValues.videoPaused = normalized;
            this.invalidate();
        }
    }
    get audioPaused(): boolean | null { return this._rawValue.audioPaused; }
    set audioPaused(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.audioPaused.normalize(value);
        if (this._rawValue.audioPaused !== normalized) {
            this._rawValue.audioPaused = normalized;
            this._updatedValues.audioPaused = normalized;
            this.invalidate();
        }
    }
}

export class ConferencePeerFactory extends EntityFactory<ConferencePeerShape, ConferencePeer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferencePeer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'auth', storageKey: 'auth', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'uid', type: 'integer' }, { name: 'tid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'auth'), condition: (src) => src.enabled });
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'keepAliveTimeout', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'conference'), condition: (src) => src.enabled });
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'range', fields: [{ name: 'keepAliveTimeout', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferencePeer', 'active'), condition: (src) => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'keepAliveTimeout', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'videoPaused', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'audioPaused', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            cid: c.integer,
            uid: c.integer,
            tid: c.string,
            keepAliveTimeout: c.integer,
            enabled: c.boolean,
            videoPaused: c.optional(c.boolean),
            audioPaused: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<ConferencePeerShape> = {
            name: 'ConferencePeer',
            storageKey: 'conferencePeer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferencePeerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferencePeerShape>) {
        super(descriptor);
    }

    readonly auth = Object.freeze({
        find: async (ctx: Context, cid: number, uid: number, tid: string) => {
            return this._findFromUniqueIndex(ctx, [cid, uid, tid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, cid: number, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid, uid])).items;
        },
        query: (ctx: Context, cid: number, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid, uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [cid], opts);
        },
    });

    readonly active = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    create(ctx: Context, id: number, src: ConferencePeerCreateShape): Promise<ConferencePeer> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ConferencePeerCreateShape): ConferencePeer {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ConferencePeer | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferencePeerShape>): ConferencePeer {
        return new ConferencePeer([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceEndStreamShape {
    id: string;
    pid: number;
    seq: number;
    state: 'need-offer' | 'wait-offer' | 'need-answer' | 'wait-answer' | 'online' | 'completed';
    localStreams: ({ type: 'audio', codec: 'default' | 'opus', mid: string | null } | { type: 'video', codec: 'default' | 'h264', source: 'default' | 'screen', mid: string | null })[];
    remoteStreams: ({ pid: number, media: { type: 'audio', mid: string | null } | { type: 'video', source: 'default' | 'screen', mid: string | null } })[];
    iceTransportPolicy: 'all' | 'relay' | 'none';
    localSdp: string | null;
    remoteSdp: string | null;
    localCandidates: (string)[];
    remoteCandidates: (string)[];
}

export interface ConferenceEndStreamCreateShape {
    pid: number;
    seq: number;
    state: 'need-offer' | 'wait-offer' | 'need-answer' | 'wait-answer' | 'online' | 'completed';
    localStreams: ({ type: 'audio', codec: 'default' | 'opus', mid: string | null | undefined } | { type: 'video', codec: 'default' | 'h264', source: 'default' | 'screen', mid: string | null | undefined })[];
    remoteStreams: ({ pid: number, media: { type: 'audio', mid: string | null | undefined } | { type: 'video', source: 'default' | 'screen', mid: string | null | undefined } })[];
    iceTransportPolicy: 'all' | 'relay' | 'none';
    localSdp?: string | null | undefined;
    remoteSdp?: string | null | undefined;
    localCandidates: (string)[];
    remoteCandidates: (string)[];
}

export class ConferenceEndStream extends Entity<ConferenceEndStreamShape> {
    get id(): string { return this._rawValue.id; }
    get pid(): number { return this._rawValue.pid; }
    set pid(value: number) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
    get state(): 'need-offer' | 'wait-offer' | 'need-answer' | 'wait-answer' | 'online' | 'completed' { return this._rawValue.state; }
    set state(value: 'need-offer' | 'wait-offer' | 'need-answer' | 'wait-answer' | 'online' | 'completed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get localStreams(): ({ type: 'audio', codec: 'default' | 'opus', mid: string | null } | { type: 'video', codec: 'default' | 'h264', source: 'default' | 'screen', mid: string | null })[] { return this._rawValue.localStreams; }
    set localStreams(value: ({ type: 'audio', codec: 'default' | 'opus', mid: string | null } | { type: 'video', codec: 'default' | 'h264', source: 'default' | 'screen', mid: string | null })[]) {
        let normalized = this.descriptor.codec.fields.localStreams.normalize(value);
        if (this._rawValue.localStreams !== normalized) {
            this._rawValue.localStreams = normalized;
            this._updatedValues.localStreams = normalized;
            this.invalidate();
        }
    }
    get remoteStreams(): ({ pid: number, media: { type: 'audio', mid: string | null } | { type: 'video', source: 'default' | 'screen', mid: string | null } })[] { return this._rawValue.remoteStreams; }
    set remoteStreams(value: ({ pid: number, media: { type: 'audio', mid: string | null } | { type: 'video', source: 'default' | 'screen', mid: string | null } })[]) {
        let normalized = this.descriptor.codec.fields.remoteStreams.normalize(value);
        if (this._rawValue.remoteStreams !== normalized) {
            this._rawValue.remoteStreams = normalized;
            this._updatedValues.remoteStreams = normalized;
            this.invalidate();
        }
    }
    get iceTransportPolicy(): 'all' | 'relay' | 'none' { return this._rawValue.iceTransportPolicy; }
    set iceTransportPolicy(value: 'all' | 'relay' | 'none') {
        let normalized = this.descriptor.codec.fields.iceTransportPolicy.normalize(value);
        if (this._rawValue.iceTransportPolicy !== normalized) {
            this._rawValue.iceTransportPolicy = normalized;
            this._updatedValues.iceTransportPolicy = normalized;
            this.invalidate();
        }
    }
    get localSdp(): string | null { return this._rawValue.localSdp; }
    set localSdp(value: string | null) {
        let normalized = this.descriptor.codec.fields.localSdp.normalize(value);
        if (this._rawValue.localSdp !== normalized) {
            this._rawValue.localSdp = normalized;
            this._updatedValues.localSdp = normalized;
            this.invalidate();
        }
    }
    get remoteSdp(): string | null { return this._rawValue.remoteSdp; }
    set remoteSdp(value: string | null) {
        let normalized = this.descriptor.codec.fields.remoteSdp.normalize(value);
        if (this._rawValue.remoteSdp !== normalized) {
            this._rawValue.remoteSdp = normalized;
            this._updatedValues.remoteSdp = normalized;
            this.invalidate();
        }
    }
    get localCandidates(): (string)[] { return this._rawValue.localCandidates; }
    set localCandidates(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.localCandidates.normalize(value);
        if (this._rawValue.localCandidates !== normalized) {
            this._rawValue.localCandidates = normalized;
            this._updatedValues.localCandidates = normalized;
            this.invalidate();
        }
    }
    get remoteCandidates(): (string)[] { return this._rawValue.remoteCandidates; }
    set remoteCandidates(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.remoteCandidates.normalize(value);
        if (this._rawValue.remoteCandidates !== normalized) {
            this._rawValue.remoteCandidates = normalized;
            this._updatedValues.remoteCandidates = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceEndStreamFactory extends EntityFactory<ConferenceEndStreamShape, ConferenceEndStream> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceEndStream');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'peer', storageKey: 'peer', type: { type: 'range', fields: [{ name: 'pid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceEndStream', 'peer'), condition: (s) => s.state !== 'completed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['need-offer', 'wait-offer', 'need-answer', 'wait-answer', 'online', 'completed'] }, secure: false });
        fields.push({ name: 'localStreams', type: { type: 'array', inner: { type: 'union', types: { audio: { codec: { type: 'enum', values: ['default', 'opus'] }, mid: { type: 'optional', inner: { type: 'string' } } }, video: { codec: { type: 'enum', values: ['default', 'h264'] }, source: { type: 'enum', values: ['default', 'screen'] }, mid: { type: 'optional', inner: { type: 'string' } } } } } }, secure: false });
        fields.push({ name: 'remoteStreams', type: { type: 'array', inner: { type: 'struct', fields: { pid: { type: 'integer' }, media: { type: 'union', types: { audio: { mid: { type: 'optional', inner: { type: 'string' } } }, video: { source: { type: 'enum', values: ['default', 'screen'] }, mid: { type: 'optional', inner: { type: 'string' } } } } } } } }, secure: false });
        fields.push({ name: 'iceTransportPolicy', type: { type: 'enum', values: ['all', 'relay', 'none'] }, secure: false });
        fields.push({ name: 'localSdp', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'remoteSdp', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'localCandidates', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'remoteCandidates', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            pid: c.integer,
            seq: c.integer,
            state: c.enum('need-offer', 'wait-offer', 'need-answer', 'wait-answer', 'online', 'completed'),
            localStreams: c.array(c.union({ audio: c.struct({ codec: c.enum('default', 'opus'), mid: c.optional(c.string) }), video: c.struct({ codec: c.enum('default', 'h264'), source: c.enum('default', 'screen'), mid: c.optional(c.string) }) })),
            remoteStreams: c.array(c.struct({ pid: c.integer, media: c.union({ audio: c.struct({ mid: c.optional(c.string) }), video: c.struct({ source: c.enum('default', 'screen'), mid: c.optional(c.string) }) }) })),
            iceTransportPolicy: c.enum('all', 'relay', 'none'),
            localSdp: c.optional(c.string),
            remoteSdp: c.optional(c.string),
            localCandidates: c.array(c.string),
            remoteCandidates: c.array(c.string),
        });
        let descriptor: EntityDescriptor<ConferenceEndStreamShape> = {
            name: 'ConferenceEndStream',
            storageKey: 'conferenceEndStream',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceEndStreamFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceEndStreamShape>) {
        super(descriptor);
    }

    readonly peer = Object.freeze({
        findAll: async (ctx: Context, pid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [pid])).items;
        },
        query: (ctx: Context, pid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [pid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (pid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [pid], opts);
        },
        liveStream: (ctx: Context, pid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [pid], opts);
        },
    });

    create(ctx: Context, id: string, src: ConferenceEndStreamCreateShape): Promise<ConferenceEndStream> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ConferenceEndStreamCreateShape): ConferenceEndStream {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ConferenceEndStream | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceEndStreamShape>): ConferenceEndStream {
        return new ConferenceEndStream([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceMeshPeerShape {
    cid: number;
    pid: number;
    sources: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean };
    active: boolean;
}

export interface ConferenceMeshPeerCreateShape {
    sources: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean };
    active: boolean;
}

export class ConferenceMeshPeer extends Entity<ConferenceMeshPeerShape> {
    get cid(): number { return this._rawValue.cid; }
    get pid(): number { return this._rawValue.pid; }
    get sources(): { audioStream: boolean, videoStream: boolean, screenCastStream: boolean } { return this._rawValue.sources; }
    set sources(value: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean }) {
        let normalized = this.descriptor.codec.fields.sources.normalize(value);
        if (this._rawValue.sources !== normalized) {
            this._rawValue.sources = normalized;
            this._updatedValues.sources = normalized;
            this.invalidate();
        }
    }
    get active(): boolean { return this._rawValue.active; }
    set active(value: boolean) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceMeshPeerFactory extends EntityFactory<ConferenceMeshPeerShape, ConferenceMeshPeer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceMeshPeer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceMeshPeer', 'conference'), condition: (src) => src.active });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'cid', type: 'integer' });
        primaryKeys.push({ name: 'pid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'sources', type: { type: 'struct', fields: { audioStream: { type: 'boolean' }, videoStream: { type: 'boolean' }, screenCastStream: { type: 'boolean' } } }, secure: false });
        fields.push({ name: 'active', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            cid: c.integer,
            pid: c.integer,
            sources: c.struct({ audioStream: c.boolean, videoStream: c.boolean, screenCastStream: c.boolean }),
            active: c.boolean,
        });
        let descriptor: EntityDescriptor<ConferenceMeshPeerShape> = {
            name: 'ConferenceMeshPeer',
            storageKey: 'conferenceMeshPeer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceMeshPeerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceMeshPeerShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, cid: number, pid: number, src: ConferenceMeshPeerCreateShape): Promise<ConferenceMeshPeer> {
        return this._create(ctx, [cid, pid], this.descriptor.codec.normalize({ cid, pid, ...src }));
    }

    create_UNSAFE(ctx: Context, cid: number, pid: number, src: ConferenceMeshPeerCreateShape): ConferenceMeshPeer {
        return this._create_UNSAFE(ctx, [cid, pid], this.descriptor.codec.normalize({ cid, pid, ...src }));
    }

    findById(ctx: Context, cid: number, pid: number): Promise<ConferenceMeshPeer | null> {
        return this._findById(ctx, [cid, pid]);
    }

    watch(ctx: Context, cid: number, pid: number): Watch {
        return this._watch(ctx, [cid, pid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceMeshPeerShape>): ConferenceMeshPeer {
        return new ConferenceMeshPeer([value.cid, value.pid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceMeshLinkShape {
    id: string;
    cid: number;
    kind: string;
    leader: number;
    pid1: number;
    pid2: number;
    esid1: string;
    esid2: string;
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
}

export interface ConferenceMeshLinkCreateShape {
    cid: number;
    kind: string;
    leader: number;
    pid1: number;
    pid2: number;
    esid1: string;
    esid2: string;
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
}

export class ConferenceMeshLink extends Entity<ConferenceMeshLinkShape> {
    get id(): string { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get kind(): string { return this._rawValue.kind; }
    set kind(value: string) {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
    get leader(): number { return this._rawValue.leader; }
    set leader(value: number) {
        let normalized = this.descriptor.codec.fields.leader.normalize(value);
        if (this._rawValue.leader !== normalized) {
            this._rawValue.leader = normalized;
            this._updatedValues.leader = normalized;
            this.invalidate();
        }
    }
    get pid1(): number { return this._rawValue.pid1; }
    set pid1(value: number) {
        let normalized = this.descriptor.codec.fields.pid1.normalize(value);
        if (this._rawValue.pid1 !== normalized) {
            this._rawValue.pid1 = normalized;
            this._updatedValues.pid1 = normalized;
            this.invalidate();
        }
    }
    get pid2(): number { return this._rawValue.pid2; }
    set pid2(value: number) {
        let normalized = this.descriptor.codec.fields.pid2.normalize(value);
        if (this._rawValue.pid2 !== normalized) {
            this._rawValue.pid2 = normalized;
            this._updatedValues.pid2 = normalized;
            this.invalidate();
        }
    }
    get esid1(): string { return this._rawValue.esid1; }
    set esid1(value: string) {
        let normalized = this.descriptor.codec.fields.esid1.normalize(value);
        if (this._rawValue.esid1 !== normalized) {
            this._rawValue.esid1 = normalized;
            this._updatedValues.esid1 = normalized;
            this.invalidate();
        }
    }
    get esid2(): string { return this._rawValue.esid2; }
    set esid2(value: string) {
        let normalized = this.descriptor.codec.fields.esid2.normalize(value);
        if (this._rawValue.esid2 !== normalized) {
            this._rawValue.esid2 = normalized;
            this._updatedValues.esid2 = normalized;
            this.invalidate();
        }
    }
    get state(): 'wait-offer' | 'wait-answer' | 'online' | 'completed' { return this._rawValue.state; }
    set state(value: 'wait-offer' | 'wait-answer' | 'online' | 'completed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceMeshLinkFactory extends EntityFactory<ConferenceMeshLinkShape, ConferenceMeshLink> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceMeshLink');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceMeshLink', 'conference'), condition: (src) => src.state !== 'completed' });
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }, { name: 'pid1', type: 'integer' }, { name: 'pid2', type: 'integer' }, { name: 'kind', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceMeshLink', 'active'), condition: (src) => src.state !== 'completed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'kind', type: { type: 'string' }, secure: false });
        fields.push({ name: 'leader', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'pid1', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'pid2', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'esid1', type: { type: 'string' }, secure: false });
        fields.push({ name: 'esid2', type: { type: 'string' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['wait-offer', 'wait-answer', 'online', 'completed'] }, secure: false });
        let codec = c.struct({
            id: c.string,
            cid: c.integer,
            kind: c.string,
            leader: c.integer,
            pid1: c.integer,
            pid2: c.integer,
            esid1: c.string,
            esid2: c.string,
            state: c.enum('wait-offer', 'wait-answer', 'online', 'completed'),
        });
        let descriptor: EntityDescriptor<ConferenceMeshLinkShape> = {
            name: 'ConferenceMeshLink',
            storageKey: 'conferenceMeshLink',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceMeshLinkFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceMeshLinkShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    readonly active = Object.freeze({
        find: async (ctx: Context, cid: number, pid1: number, pid2: number, kind: string) => {
            return this._findFromUniqueIndex(ctx, [cid, pid1, pid2, kind], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context, cid: number, pid1: number, pid2: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid, pid1, pid2])).items;
        },
        query: (ctx: Context, cid: number, pid1: number, pid2: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid, pid1, pid2], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: ConferenceMeshLinkCreateShape): Promise<ConferenceMeshLink> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ConferenceMeshLinkCreateShape): ConferenceMeshLink {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ConferenceMeshLink | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceMeshLinkShape>): ConferenceMeshLink {
        return new ConferenceMeshLink([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceKitchenRouterShape {
    id: string;
    cid: number;
    deleted: boolean;
}

export interface ConferenceKitchenRouterCreateShape {
    cid: number;
    deleted: boolean;
}

export class ConferenceKitchenRouter extends Entity<ConferenceKitchenRouterShape> {
    get id(): string { return this._rawValue.id; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceKitchenRouterFactory extends EntityFactory<ConferenceKitchenRouterShape, ConferenceKitchenRouter> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceKitchenRouter');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'unique', fields: [{ name: 'cid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceKitchenRouter', 'conference'), condition: (s) => !s.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            cid: c.integer,
            deleted: c.boolean,
        });
        let descriptor: EntityDescriptor<ConferenceKitchenRouterShape> = {
            name: 'ConferenceKitchenRouter',
            storageKey: 'conferenceKitchenRouter',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceKitchenRouterFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceKitchenRouterShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        find: async (ctx: Context, cid: number) => {
            return this._findFromUniqueIndex(ctx, [cid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: ConferenceKitchenRouterCreateShape): Promise<ConferenceKitchenRouter> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ConferenceKitchenRouterCreateShape): ConferenceKitchenRouter {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ConferenceKitchenRouter | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceKitchenRouterShape>): ConferenceKitchenRouter {
        return new ConferenceKitchenRouter([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceKitchenPeerShape {
    pid: number;
    cid: number;
    active: boolean;
    capabilities: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null;
    producerTransport: string | null;
    consumerTransport: string | null;
}

export interface ConferenceKitchenPeerCreateShape {
    cid: number;
    active: boolean;
    capabilities?: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null | undefined, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null | undefined })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null | undefined;
    producerTransport?: string | null | undefined;
    consumerTransport?: string | null | undefined;
}

export class ConferenceKitchenPeer extends Entity<ConferenceKitchenPeerShape> {
    get pid(): number { return this._rawValue.pid; }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get active(): boolean { return this._rawValue.active; }
    set active(value: boolean) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
    get capabilities(): { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null { return this._rawValue.capabilities; }
    set capabilities(value: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null) {
        let normalized = this.descriptor.codec.fields.capabilities.normalize(value);
        if (this._rawValue.capabilities !== normalized) {
            this._rawValue.capabilities = normalized;
            this._updatedValues.capabilities = normalized;
            this.invalidate();
        }
    }
    get producerTransport(): string | null { return this._rawValue.producerTransport; }
    set producerTransport(value: string | null) {
        let normalized = this.descriptor.codec.fields.producerTransport.normalize(value);
        if (this._rawValue.producerTransport !== normalized) {
            this._rawValue.producerTransport = normalized;
            this._updatedValues.producerTransport = normalized;
            this.invalidate();
        }
    }
    get consumerTransport(): string | null { return this._rawValue.consumerTransport; }
    set consumerTransport(value: string | null) {
        let normalized = this.descriptor.codec.fields.consumerTransport.normalize(value);
        if (this._rawValue.consumerTransport !== normalized) {
            this._rawValue.consumerTransport = normalized;
            this._updatedValues.consumerTransport = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceKitchenPeerFactory extends EntityFactory<ConferenceKitchenPeerShape, ConferenceKitchenPeer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceKitchenPeer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'conference', storageKey: 'conference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceKitchenPeer', 'conference'), condition: (src) => src.active });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'pid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'active', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'capabilities', type: { type: 'optional', inner: { type: 'struct', fields: { codecs: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, mimeType: { type: 'string' }, preferredPayloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'array', inner: { type: 'struct', fields: { key: { type: 'string' }, value: { type: 'string' } } } }, rtcpFeedback: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, value: { type: 'optional', inner: { type: 'string' } } } } } } } }, headerExtensions: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, uri: { type: 'string' }, preferredId: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'producerTransport', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'consumerTransport', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            pid: c.integer,
            cid: c.integer,
            active: c.boolean,
            capabilities: c.optional(c.struct({ codecs: c.array(c.struct({ kind: c.string, mimeType: c.string, preferredPayloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.array(c.struct({ key: c.string, value: c.string })), rtcpFeedback: c.array(c.struct({ type: c.string, value: c.optional(c.string) })) })), headerExtensions: c.array(c.struct({ kind: c.string, uri: c.string, preferredId: c.integer })) })),
            producerTransport: c.optional(c.string),
            consumerTransport: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<ConferenceKitchenPeerShape> = {
            name: 'ConferenceKitchenPeer',
            storageKey: 'conferenceKitchenPeer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceKitchenPeerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceKitchenPeerShape>) {
        super(descriptor);
    }

    readonly conference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, pid: number, src: ConferenceKitchenPeerCreateShape): Promise<ConferenceKitchenPeer> {
        return this._create(ctx, [pid], this.descriptor.codec.normalize({ pid, ...src }));
    }

    create_UNSAFE(ctx: Context, pid: number, src: ConferenceKitchenPeerCreateShape): ConferenceKitchenPeer {
        return this._create_UNSAFE(ctx, [pid], this.descriptor.codec.normalize({ pid, ...src }));
    }

    findById(ctx: Context, pid: number): Promise<ConferenceKitchenPeer | null> {
        return this._findById(ctx, [pid]);
    }

    watch(ctx: Context, pid: number): Watch {
        return this._watch(ctx, [pid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceKitchenPeerShape>): ConferenceKitchenPeer {
        return new ConferenceKitchenPeer([value.pid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceKitchenProducerTransportShape {
    id: string;
    pid: number;
    cid: number;
    capabilities: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null;
    state: 'negotiation-need-offer' | 'negotiation-wait-answer' | 'ready' | 'closed';
    produces: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean };
    audioProducer: string | null;
    audioProducerMid: string | null;
    videoProducer: string | null;
    videoProducerMid: string | null;
    screencastProducer: string | null;
    screencastProducerMid: string | null;
}

export interface ConferenceKitchenProducerTransportCreateShape {
    pid: number;
    cid: number;
    capabilities?: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null | undefined, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null | undefined })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null | undefined;
    state: 'negotiation-need-offer' | 'negotiation-wait-answer' | 'ready' | 'closed';
    produces: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean };
    audioProducer?: string | null | undefined;
    audioProducerMid?: string | null | undefined;
    videoProducer?: string | null | undefined;
    videoProducerMid?: string | null | undefined;
    screencastProducer?: string | null | undefined;
    screencastProducerMid?: string | null | undefined;
}

export class ConferenceKitchenProducerTransport extends Entity<ConferenceKitchenProducerTransportShape> {
    get id(): string { return this._rawValue.id; }
    get pid(): number { return this._rawValue.pid; }
    set pid(value: number) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get capabilities(): { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null { return this._rawValue.capabilities; }
    set capabilities(value: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null) {
        let normalized = this.descriptor.codec.fields.capabilities.normalize(value);
        if (this._rawValue.capabilities !== normalized) {
            this._rawValue.capabilities = normalized;
            this._updatedValues.capabilities = normalized;
            this.invalidate();
        }
    }
    get state(): 'negotiation-need-offer' | 'negotiation-wait-answer' | 'ready' | 'closed' { return this._rawValue.state; }
    set state(value: 'negotiation-need-offer' | 'negotiation-wait-answer' | 'ready' | 'closed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get produces(): { audioStream: boolean, videoStream: boolean, screenCastStream: boolean } { return this._rawValue.produces; }
    set produces(value: { audioStream: boolean, videoStream: boolean, screenCastStream: boolean }) {
        let normalized = this.descriptor.codec.fields.produces.normalize(value);
        if (this._rawValue.produces !== normalized) {
            this._rawValue.produces = normalized;
            this._updatedValues.produces = normalized;
            this.invalidate();
        }
    }
    get audioProducer(): string | null { return this._rawValue.audioProducer; }
    set audioProducer(value: string | null) {
        let normalized = this.descriptor.codec.fields.audioProducer.normalize(value);
        if (this._rawValue.audioProducer !== normalized) {
            this._rawValue.audioProducer = normalized;
            this._updatedValues.audioProducer = normalized;
            this.invalidate();
        }
    }
    get audioProducerMid(): string | null { return this._rawValue.audioProducerMid; }
    set audioProducerMid(value: string | null) {
        let normalized = this.descriptor.codec.fields.audioProducerMid.normalize(value);
        if (this._rawValue.audioProducerMid !== normalized) {
            this._rawValue.audioProducerMid = normalized;
            this._updatedValues.audioProducerMid = normalized;
            this.invalidate();
        }
    }
    get videoProducer(): string | null { return this._rawValue.videoProducer; }
    set videoProducer(value: string | null) {
        let normalized = this.descriptor.codec.fields.videoProducer.normalize(value);
        if (this._rawValue.videoProducer !== normalized) {
            this._rawValue.videoProducer = normalized;
            this._updatedValues.videoProducer = normalized;
            this.invalidate();
        }
    }
    get videoProducerMid(): string | null { return this._rawValue.videoProducerMid; }
    set videoProducerMid(value: string | null) {
        let normalized = this.descriptor.codec.fields.videoProducerMid.normalize(value);
        if (this._rawValue.videoProducerMid !== normalized) {
            this._rawValue.videoProducerMid = normalized;
            this._updatedValues.videoProducerMid = normalized;
            this.invalidate();
        }
    }
    get screencastProducer(): string | null { return this._rawValue.screencastProducer; }
    set screencastProducer(value: string | null) {
        let normalized = this.descriptor.codec.fields.screencastProducer.normalize(value);
        if (this._rawValue.screencastProducer !== normalized) {
            this._rawValue.screencastProducer = normalized;
            this._updatedValues.screencastProducer = normalized;
            this.invalidate();
        }
    }
    get screencastProducerMid(): string | null { return this._rawValue.screencastProducerMid; }
    set screencastProducerMid(value: string | null) {
        let normalized = this.descriptor.codec.fields.screencastProducerMid.normalize(value);
        if (this._rawValue.screencastProducerMid !== normalized) {
            this._rawValue.screencastProducerMid = normalized;
            this._updatedValues.screencastProducerMid = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceKitchenProducerTransportFactory extends EntityFactory<ConferenceKitchenProducerTransportShape, ConferenceKitchenProducerTransport> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceKitchenProducerTransport');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromConference', storageKey: 'fromConference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceKitchenProducerTransport', 'fromConference'), condition: (src) => src.state !== 'closed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'capabilities', type: { type: 'optional', inner: { type: 'struct', fields: { codecs: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, mimeType: { type: 'string' }, preferredPayloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'array', inner: { type: 'struct', fields: { key: { type: 'string' }, value: { type: 'string' } } } }, rtcpFeedback: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, value: { type: 'optional', inner: { type: 'string' } } } } } } } }, headerExtensions: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, uri: { type: 'string' }, preferredId: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['negotiation-need-offer', 'negotiation-wait-answer', 'ready', 'closed'] }, secure: false });
        fields.push({ name: 'produces', type: { type: 'struct', fields: { audioStream: { type: 'boolean' }, videoStream: { type: 'boolean' }, screenCastStream: { type: 'boolean' } } }, secure: false });
        fields.push({ name: 'audioProducer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'audioProducerMid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'videoProducer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'videoProducerMid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'screencastProducer', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'screencastProducerMid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            pid: c.integer,
            cid: c.integer,
            capabilities: c.optional(c.struct({ codecs: c.array(c.struct({ kind: c.string, mimeType: c.string, preferredPayloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.array(c.struct({ key: c.string, value: c.string })), rtcpFeedback: c.array(c.struct({ type: c.string, value: c.optional(c.string) })) })), headerExtensions: c.array(c.struct({ kind: c.string, uri: c.string, preferredId: c.integer })) })),
            state: c.enum('negotiation-need-offer', 'negotiation-wait-answer', 'ready', 'closed'),
            produces: c.struct({ audioStream: c.boolean, videoStream: c.boolean, screenCastStream: c.boolean }),
            audioProducer: c.optional(c.string),
            audioProducerMid: c.optional(c.string),
            videoProducer: c.optional(c.string),
            videoProducerMid: c.optional(c.string),
            screencastProducer: c.optional(c.string),
            screencastProducerMid: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<ConferenceKitchenProducerTransportShape> = {
            name: 'ConferenceKitchenProducerTransport',
            storageKey: 'conferenceKitchenProducerTransport',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceKitchenProducerTransportFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceKitchenProducerTransportShape>) {
        super(descriptor);
    }

    readonly fromConference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, id: string, src: ConferenceKitchenProducerTransportCreateShape): Promise<ConferenceKitchenProducerTransport> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ConferenceKitchenProducerTransportCreateShape): ConferenceKitchenProducerTransport {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ConferenceKitchenProducerTransport | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceKitchenProducerTransportShape>): ConferenceKitchenProducerTransport {
        return new ConferenceKitchenProducerTransport([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ConferenceKitchenConsumerTransportShape {
    id: string;
    pid: number;
    cid: number;
    capabilities: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null;
    state: 'negotiation-wait-offer' | 'negotiation-need-answer' | 'ready' | 'closed';
    consumes: (string)[];
    consumers: ({ pid: number, transport: string, consumer: string, media: { type: 'audio',  } | { type: 'video', source: 'default' | 'screen' }, active: boolean })[];
}

export interface ConferenceKitchenConsumerTransportCreateShape {
    pid: number;
    cid: number;
    capabilities?: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null | undefined, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null | undefined })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null | undefined;
    state: 'negotiation-wait-offer' | 'negotiation-need-answer' | 'ready' | 'closed';
    consumes: (string)[];
    consumers: ({ pid: number, transport: string, consumer: string, media: { type: 'audio',  } | { type: 'video', source: 'default' | 'screen' }, active: boolean })[];
}

export class ConferenceKitchenConsumerTransport extends Entity<ConferenceKitchenConsumerTransportShape> {
    get id(): string { return this._rawValue.id; }
    get pid(): number { return this._rawValue.pid; }
    set pid(value: number) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get capabilities(): { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null { return this._rawValue.capabilities; }
    set capabilities(value: { codecs: ({ kind: string, mimeType: string, preferredPayloadType: number, clockRate: number, channels: number | null, parameters: ({ key: string, value: string })[], rtcpFeedback: ({ type: string, value: string | null })[] })[], headerExtensions: ({ kind: string, uri: string, preferredId: number })[] } | null) {
        let normalized = this.descriptor.codec.fields.capabilities.normalize(value);
        if (this._rawValue.capabilities !== normalized) {
            this._rawValue.capabilities = normalized;
            this._updatedValues.capabilities = normalized;
            this.invalidate();
        }
    }
    get state(): 'negotiation-wait-offer' | 'negotiation-need-answer' | 'ready' | 'closed' { return this._rawValue.state; }
    set state(value: 'negotiation-wait-offer' | 'negotiation-need-answer' | 'ready' | 'closed') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get consumes(): (string)[] { return this._rawValue.consumes; }
    set consumes(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.consumes.normalize(value);
        if (this._rawValue.consumes !== normalized) {
            this._rawValue.consumes = normalized;
            this._updatedValues.consumes = normalized;
            this.invalidate();
        }
    }
    get consumers(): ({ pid: number, transport: string, consumer: string, media: { type: 'audio',  } | { type: 'video', source: 'default' | 'screen' }, active: boolean })[] { return this._rawValue.consumers; }
    set consumers(value: ({ pid: number, transport: string, consumer: string, media: { type: 'audio',  } | { type: 'video', source: 'default' | 'screen' }, active: boolean })[]) {
        let normalized = this.descriptor.codec.fields.consumers.normalize(value);
        if (this._rawValue.consumers !== normalized) {
            this._rawValue.consumers = normalized;
            this._updatedValues.consumers = normalized;
            this.invalidate();
        }
    }
}

export class ConferenceKitchenConsumerTransportFactory extends EntityFactory<ConferenceKitchenConsumerTransportShape, ConferenceKitchenConsumerTransport> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('conferenceKitchenConsumerTransport');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromConference', storageKey: 'fromConference', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('conferenceKitchenConsumerTransport', 'fromConference'), condition: (src) => src.state !== 'closed' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'capabilities', type: { type: 'optional', inner: { type: 'struct', fields: { codecs: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, mimeType: { type: 'string' }, preferredPayloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'array', inner: { type: 'struct', fields: { key: { type: 'string' }, value: { type: 'string' } } } }, rtcpFeedback: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, value: { type: 'optional', inner: { type: 'string' } } } } } } } }, headerExtensions: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'string' }, uri: { type: 'string' }, preferredId: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['negotiation-wait-offer', 'negotiation-need-answer', 'ready', 'closed'] }, secure: false });
        fields.push({ name: 'consumes', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'consumers', type: { type: 'array', inner: { type: 'struct', fields: { pid: { type: 'integer' }, transport: { type: 'string' }, consumer: { type: 'string' }, media: { type: 'union', types: { audio: {  }, video: { source: { type: 'enum', values: ['default', 'screen'] } } } }, active: { type: 'boolean' } } } }, secure: false });
        let codec = c.struct({
            id: c.string,
            pid: c.integer,
            cid: c.integer,
            capabilities: c.optional(c.struct({ codecs: c.array(c.struct({ kind: c.string, mimeType: c.string, preferredPayloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.array(c.struct({ key: c.string, value: c.string })), rtcpFeedback: c.array(c.struct({ type: c.string, value: c.optional(c.string) })) })), headerExtensions: c.array(c.struct({ kind: c.string, uri: c.string, preferredId: c.integer })) })),
            state: c.enum('negotiation-wait-offer', 'negotiation-need-answer', 'ready', 'closed'),
            consumes: c.array(c.string),
            consumers: c.array(c.struct({ pid: c.integer, transport: c.string, consumer: c.string, media: c.union({ audio: c.struct({  }), video: c.struct({ source: c.enum('default', 'screen') }) }), active: c.boolean })),
        });
        let descriptor: EntityDescriptor<ConferenceKitchenConsumerTransportShape> = {
            name: 'ConferenceKitchenConsumerTransport',
            storageKey: 'conferenceKitchenConsumerTransport',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ConferenceKitchenConsumerTransportFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ConferenceKitchenConsumerTransportShape>) {
        super(descriptor);
    }

    readonly fromConference = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    create(ctx: Context, id: string, src: ConferenceKitchenConsumerTransportCreateShape): Promise<ConferenceKitchenConsumerTransport> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ConferenceKitchenConsumerTransportCreateShape): ConferenceKitchenConsumerTransport {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ConferenceKitchenConsumerTransport | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ConferenceKitchenConsumerTransportShape>): ConferenceKitchenConsumerTransport {
        return new ConferenceKitchenConsumerTransport([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface KitchenWorkerShape {
    id: string;
    appData: any | null;
    deleted: boolean;
}

export interface KitchenWorkerCreateShape {
    appData?: any | null | undefined;
    deleted: boolean;
}

export class KitchenWorker extends Entity<KitchenWorkerShape> {
    get id(): string { return this._rawValue.id; }
    get appData(): any | null { return this._rawValue.appData; }
    set appData(value: any | null) {
        let normalized = this.descriptor.codec.fields.appData.normalize(value);
        if (this._rawValue.appData !== normalized) {
            this._rawValue.appData = normalized;
            this._updatedValues.appData = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class KitchenWorkerFactory extends EntityFactory<KitchenWorkerShape, KitchenWorker> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('kitchenWorker');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'range', fields: [{ name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenWorker', 'active'), condition: (s) => !s.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'appData', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            appData: c.optional(c.any),
            deleted: c.boolean,
        });
        let descriptor: EntityDescriptor<KitchenWorkerShape> = {
            name: 'KitchenWorker',
            storageKey: 'kitchenWorker',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new KitchenWorkerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<KitchenWorkerShape>) {
        super(descriptor);
    }

    readonly active = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: string, src: KitchenWorkerCreateShape): Promise<KitchenWorker> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: KitchenWorkerCreateShape): KitchenWorker {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<KitchenWorker | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<KitchenWorkerShape>): KitchenWorker {
        return new KitchenWorker([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface KitchenRouterShape {
    id: string;
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    workerId: string | null;
}

export interface KitchenRouterCreateShape {
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    workerId?: string | null | undefined;
}

export class KitchenRouter extends Entity<KitchenRouterShape> {
    get id(): string { return this._rawValue.id; }
    get state(): 'creating' | 'created' | 'deleting' | 'deleted' { return this._rawValue.state; }
    set state(value: 'creating' | 'created' | 'deleting' | 'deleted') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get workerId(): string | null { return this._rawValue.workerId; }
    set workerId(value: string | null) {
        let normalized = this.descriptor.codec.fields.workerId.normalize(value);
        if (this._rawValue.workerId !== normalized) {
            this._rawValue.workerId = normalized;
            this._updatedValues.workerId = normalized;
            this.invalidate();
        }
    }
}

export class KitchenRouterFactory extends EntityFactory<KitchenRouterShape, KitchenRouter> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('kitchenRouter');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'workerActive', storageKey: 'workerActive', type: { type: 'range', fields: [{ name: 'workerId', type: 'opt_string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenRouter', 'workerActive'), condition: (s) => !!s.workerId && s.state !== 'deleted' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'state', type: { type: 'enum', values: ['creating', 'created', 'deleting', 'deleted'] }, secure: false });
        fields.push({ name: 'workerId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            state: c.enum('creating', 'created', 'deleting', 'deleted'),
            workerId: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<KitchenRouterShape> = {
            name: 'KitchenRouter',
            storageKey: 'kitchenRouter',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new KitchenRouterFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<KitchenRouterShape>) {
        super(descriptor);
    }

    readonly workerActive = Object.freeze({
        findAll: async (ctx: Context, workerId: string | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [workerId])).items;
        },
        query: (ctx: Context, workerId: string | null, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [workerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (workerId: string | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [workerId], opts);
        },
        liveStream: (ctx: Context, workerId: string | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [workerId], opts);
        },
    });

    create(ctx: Context, id: string, src: KitchenRouterCreateShape): Promise<KitchenRouter> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: KitchenRouterCreateShape): KitchenRouter {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<KitchenRouter | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<KitchenRouterShape>): KitchenRouter {
        return new KitchenRouter([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface KitchenTransportShape {
    id: string;
    routerId: string;
    state: 'creating' | 'created' | 'connecting' | 'connected' | 'deleting' | 'deleted';
    serverParameters: { fingerprints: ({ algorithm: string, value: string })[], iceParameters: { usernameFragment: string, password: string }, iceCandidates: ({ type: string, foundation: string, priority: number, ip: string, protocol: 'tcp' | 'udp', port: number })[] } | null;
    clientParameters: { dtlsRole: 'server' | 'client' | null, fingerprints: ({ algorithm: string, value: string })[] } | null;
}

export interface KitchenTransportCreateShape {
    routerId: string;
    state: 'creating' | 'created' | 'connecting' | 'connected' | 'deleting' | 'deleted';
    serverParameters?: { fingerprints: ({ algorithm: string, value: string })[], iceParameters: { usernameFragment: string, password: string }, iceCandidates: ({ type: string, foundation: string, priority: number, ip: string, protocol: 'tcp' | 'udp', port: number })[] } | null | undefined;
    clientParameters?: { dtlsRole: 'server' | 'client' | null | undefined, fingerprints: ({ algorithm: string, value: string })[] } | null | undefined;
}

export class KitchenTransport extends Entity<KitchenTransportShape> {
    get id(): string { return this._rawValue.id; }
    get routerId(): string { return this._rawValue.routerId; }
    set routerId(value: string) {
        let normalized = this.descriptor.codec.fields.routerId.normalize(value);
        if (this._rawValue.routerId !== normalized) {
            this._rawValue.routerId = normalized;
            this._updatedValues.routerId = normalized;
            this.invalidate();
        }
    }
    get state(): 'creating' | 'created' | 'connecting' | 'connected' | 'deleting' | 'deleted' { return this._rawValue.state; }
    set state(value: 'creating' | 'created' | 'connecting' | 'connected' | 'deleting' | 'deleted') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get serverParameters(): { fingerprints: ({ algorithm: string, value: string })[], iceParameters: { usernameFragment: string, password: string }, iceCandidates: ({ type: string, foundation: string, priority: number, ip: string, protocol: 'tcp' | 'udp', port: number })[] } | null { return this._rawValue.serverParameters; }
    set serverParameters(value: { fingerprints: ({ algorithm: string, value: string })[], iceParameters: { usernameFragment: string, password: string }, iceCandidates: ({ type: string, foundation: string, priority: number, ip: string, protocol: 'tcp' | 'udp', port: number })[] } | null) {
        let normalized = this.descriptor.codec.fields.serverParameters.normalize(value);
        if (this._rawValue.serverParameters !== normalized) {
            this._rawValue.serverParameters = normalized;
            this._updatedValues.serverParameters = normalized;
            this.invalidate();
        }
    }
    get clientParameters(): { dtlsRole: 'server' | 'client' | null, fingerprints: ({ algorithm: string, value: string })[] } | null { return this._rawValue.clientParameters; }
    set clientParameters(value: { dtlsRole: 'server' | 'client' | null, fingerprints: ({ algorithm: string, value: string })[] } | null) {
        let normalized = this.descriptor.codec.fields.clientParameters.normalize(value);
        if (this._rawValue.clientParameters !== normalized) {
            this._rawValue.clientParameters = normalized;
            this._updatedValues.clientParameters = normalized;
            this.invalidate();
        }
    }
}

export class KitchenTransportFactory extends EntityFactory<KitchenTransportShape, KitchenTransport> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('kitchenTransport');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'routerActive', storageKey: 'routerActive', type: { type: 'range', fields: [{ name: 'routerId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenTransport', 'routerActive'), condition: (s) => s.state !== 'deleted' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'routerId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['creating', 'created', 'connecting', 'connected', 'deleting', 'deleted'] }, secure: false });
        fields.push({ name: 'serverParameters', type: { type: 'optional', inner: { type: 'struct', fields: { fingerprints: { type: 'array', inner: { type: 'struct', fields: { algorithm: { type: 'string' }, value: { type: 'string' } } } }, iceParameters: { type: 'struct', fields: { usernameFragment: { type: 'string' }, password: { type: 'string' } } }, iceCandidates: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, foundation: { type: 'string' }, priority: { type: 'integer' }, ip: { type: 'string' }, protocol: { type: 'enum', values: ['tcp', 'udp'] }, port: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'clientParameters', type: { type: 'optional', inner: { type: 'struct', fields: { dtlsRole: { type: 'optional', inner: { type: 'enum', values: ['server', 'client'] } }, fingerprints: { type: 'array', inner: { type: 'struct', fields: { algorithm: { type: 'string' }, value: { type: 'string' } } } } } } }, secure: false });
        let codec = c.struct({
            id: c.string,
            routerId: c.string,
            state: c.enum('creating', 'created', 'connecting', 'connected', 'deleting', 'deleted'),
            serverParameters: c.optional(c.struct({ fingerprints: c.array(c.struct({ algorithm: c.string, value: c.string })), iceParameters: c.struct({ usernameFragment: c.string, password: c.string }), iceCandidates: c.array(c.struct({ type: c.string, foundation: c.string, priority: c.integer, ip: c.string, protocol: c.enum('tcp', 'udp'), port: c.integer })) })),
            clientParameters: c.optional(c.struct({ dtlsRole: c.optional(c.enum('server', 'client')), fingerprints: c.array(c.struct({ algorithm: c.string, value: c.string })) })),
        });
        let descriptor: EntityDescriptor<KitchenTransportShape> = {
            name: 'KitchenTransport',
            storageKey: 'kitchenTransport',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new KitchenTransportFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<KitchenTransportShape>) {
        super(descriptor);
    }

    readonly routerActive = Object.freeze({
        findAll: async (ctx: Context, routerId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId])).items;
        },
        query: (ctx: Context, routerId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (routerId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
        liveStream: (ctx: Context, routerId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
    });

    create(ctx: Context, id: string, src: KitchenTransportCreateShape): Promise<KitchenTransport> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: KitchenTransportCreateShape): KitchenTransport {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<KitchenTransport | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<KitchenTransportShape>): KitchenTransport {
        return new KitchenTransport([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface KitchenProducerShape {
    id: string;
    routerId: string;
    transportId: string;
    rawId: string | null;
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    parameters: { kind: 'audio' | 'video', rtpParameters: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null }, keyFrameRequestDelay: number | null, paused: boolean | null };
    rtpParameters: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null;
    paused: boolean;
}

export interface KitchenProducerCreateShape {
    routerId: string;
    transportId: string;
    rawId?: string | null | undefined;
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    parameters: { kind: 'audio' | 'video', rtpParameters: { mid: string | null | undefined, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null | undefined, parameters: any | null | undefined, rtcpFeedback: ({ type: string, parameter: string | null | undefined })[] | null | undefined })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null | undefined, parameters: any })[] | null | undefined, encodings: ({ ssrc: number | null | undefined, rid: string | null | undefined, codecPayloadType: number | null | undefined, rtx: { ssrc: number } | null | undefined, dtx: boolean | null | undefined, scalabilityMode: string | null | undefined })[] | null | undefined, rtcp: { cname: string | null | undefined, reducedSize: boolean | null | undefined, mux: boolean | null | undefined } | null | undefined }, keyFrameRequestDelay: number | null | undefined, paused: boolean | null | undefined };
    rtpParameters?: { mid: string | null | undefined, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null | undefined, parameters: any | null | undefined, rtcpFeedback: ({ type: string, parameter: string | null | undefined })[] | null | undefined })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null | undefined, parameters: any })[] | null | undefined, encodings: ({ ssrc: number | null | undefined, rid: string | null | undefined, codecPayloadType: number | null | undefined, rtx: { ssrc: number } | null | undefined, dtx: boolean | null | undefined, scalabilityMode: string | null | undefined })[] | null | undefined, rtcp: { cname: string | null | undefined, reducedSize: boolean | null | undefined, mux: boolean | null | undefined } | null | undefined } | null | undefined;
    paused: boolean;
}

export class KitchenProducer extends Entity<KitchenProducerShape> {
    get id(): string { return this._rawValue.id; }
    get routerId(): string { return this._rawValue.routerId; }
    set routerId(value: string) {
        let normalized = this.descriptor.codec.fields.routerId.normalize(value);
        if (this._rawValue.routerId !== normalized) {
            this._rawValue.routerId = normalized;
            this._updatedValues.routerId = normalized;
            this.invalidate();
        }
    }
    get transportId(): string { return this._rawValue.transportId; }
    set transportId(value: string) {
        let normalized = this.descriptor.codec.fields.transportId.normalize(value);
        if (this._rawValue.transportId !== normalized) {
            this._rawValue.transportId = normalized;
            this._updatedValues.transportId = normalized;
            this.invalidate();
        }
    }
    get rawId(): string | null { return this._rawValue.rawId; }
    set rawId(value: string | null) {
        let normalized = this.descriptor.codec.fields.rawId.normalize(value);
        if (this._rawValue.rawId !== normalized) {
            this._rawValue.rawId = normalized;
            this._updatedValues.rawId = normalized;
            this.invalidate();
        }
    }
    get state(): 'creating' | 'created' | 'deleting' | 'deleted' { return this._rawValue.state; }
    set state(value: 'creating' | 'created' | 'deleting' | 'deleted') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get parameters(): { kind: 'audio' | 'video', rtpParameters: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null }, keyFrameRequestDelay: number | null, paused: boolean | null } { return this._rawValue.parameters; }
    set parameters(value: { kind: 'audio' | 'video', rtpParameters: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null }, keyFrameRequestDelay: number | null, paused: boolean | null }) {
        let normalized = this.descriptor.codec.fields.parameters.normalize(value);
        if (this._rawValue.parameters !== normalized) {
            this._rawValue.parameters = normalized;
            this._updatedValues.parameters = normalized;
            this.invalidate();
        }
    }
    get rtpParameters(): { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null { return this._rawValue.rtpParameters; }
    set rtpParameters(value: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null) {
        let normalized = this.descriptor.codec.fields.rtpParameters.normalize(value);
        if (this._rawValue.rtpParameters !== normalized) {
            this._rawValue.rtpParameters = normalized;
            this._updatedValues.rtpParameters = normalized;
            this.invalidate();
        }
    }
    get paused(): boolean { return this._rawValue.paused; }
    set paused(value: boolean) {
        let normalized = this.descriptor.codec.fields.paused.normalize(value);
        if (this._rawValue.paused !== normalized) {
            this._rawValue.paused = normalized;
            this._updatedValues.paused = normalized;
            this.invalidate();
        }
    }
}

export class KitchenProducerFactory extends EntityFactory<KitchenProducerShape, KitchenProducer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('kitchenProducer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'routerActive', storageKey: 'routerActive', type: { type: 'range', fields: [{ name: 'routerId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenProducer', 'routerActive'), condition: (s) => s.state !== 'deleted' });
        secondaryIndexes.push({ name: 'transportActive', storageKey: 'transportActive', type: { type: 'range', fields: [{ name: 'transportId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenProducer', 'transportActive'), condition: (s) => s.state !== 'deleted' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'routerId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'transportId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'rawId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['creating', 'created', 'deleting', 'deleted'] }, secure: false });
        fields.push({ name: 'parameters', type: { type: 'struct', fields: { kind: { type: 'enum', values: ['audio', 'video'] }, rtpParameters: { type: 'struct', fields: { mid: { type: 'optional', inner: { type: 'string' } }, codecs: { type: 'array', inner: { type: 'struct', fields: { mimeType: { type: 'string' }, payloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'optional', inner: { type: 'json' } }, rtcpFeedback: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, parameter: { type: 'optional', inner: { type: 'string' } } } } } } } } }, headerExtensions: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { uri: { type: 'string' }, id: { type: 'integer' }, encrypt: { type: 'optional', inner: { type: 'boolean' } }, parameters: { type: 'json' } } } } }, encodings: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { ssrc: { type: 'optional', inner: { type: 'integer' } }, rid: { type: 'optional', inner: { type: 'string' } }, codecPayloadType: { type: 'optional', inner: { type: 'integer' } }, rtx: { type: 'optional', inner: { type: 'struct', fields: { ssrc: { type: 'integer' } } } }, dtx: { type: 'optional', inner: { type: 'boolean' } }, scalabilityMode: { type: 'optional', inner: { type: 'string' } } } } } }, rtcp: { type: 'optional', inner: { type: 'struct', fields: { cname: { type: 'optional', inner: { type: 'string' } }, reducedSize: { type: 'optional', inner: { type: 'boolean' } }, mux: { type: 'optional', inner: { type: 'boolean' } } } } } } }, keyFrameRequestDelay: { type: 'optional', inner: { type: 'integer' } }, paused: { type: 'optional', inner: { type: 'boolean' } } } }, secure: false });
        fields.push({ name: 'rtpParameters', type: { type: 'optional', inner: { type: 'struct', fields: { mid: { type: 'optional', inner: { type: 'string' } }, codecs: { type: 'array', inner: { type: 'struct', fields: { mimeType: { type: 'string' }, payloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'optional', inner: { type: 'json' } }, rtcpFeedback: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, parameter: { type: 'optional', inner: { type: 'string' } } } } } } } } }, headerExtensions: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { uri: { type: 'string' }, id: { type: 'integer' }, encrypt: { type: 'optional', inner: { type: 'boolean' } }, parameters: { type: 'json' } } } } }, encodings: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { ssrc: { type: 'optional', inner: { type: 'integer' } }, rid: { type: 'optional', inner: { type: 'string' } }, codecPayloadType: { type: 'optional', inner: { type: 'integer' } }, rtx: { type: 'optional', inner: { type: 'struct', fields: { ssrc: { type: 'integer' } } } }, dtx: { type: 'optional', inner: { type: 'boolean' } }, scalabilityMode: { type: 'optional', inner: { type: 'string' } } } } } }, rtcp: { type: 'optional', inner: { type: 'struct', fields: { cname: { type: 'optional', inner: { type: 'string' } }, reducedSize: { type: 'optional', inner: { type: 'boolean' } }, mux: { type: 'optional', inner: { type: 'boolean' } } } } } } } }, secure: false });
        fields.push({ name: 'paused', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            routerId: c.string,
            transportId: c.string,
            rawId: c.optional(c.string),
            state: c.enum('creating', 'created', 'deleting', 'deleted'),
            parameters: c.struct({ kind: c.enum('audio', 'video'), rtpParameters: c.struct({ mid: c.optional(c.string), codecs: c.array(c.struct({ mimeType: c.string, payloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.optional(c.any), rtcpFeedback: c.optional(c.array(c.struct({ type: c.string, parameter: c.optional(c.string) }))) })), headerExtensions: c.optional(c.array(c.struct({ uri: c.string, id: c.integer, encrypt: c.optional(c.boolean), parameters: c.any }))), encodings: c.optional(c.array(c.struct({ ssrc: c.optional(c.integer), rid: c.optional(c.string), codecPayloadType: c.optional(c.integer), rtx: c.optional(c.struct({ ssrc: c.integer })), dtx: c.optional(c.boolean), scalabilityMode: c.optional(c.string) }))), rtcp: c.optional(c.struct({ cname: c.optional(c.string), reducedSize: c.optional(c.boolean), mux: c.optional(c.boolean) })) }), keyFrameRequestDelay: c.optional(c.integer), paused: c.optional(c.boolean) }),
            rtpParameters: c.optional(c.struct({ mid: c.optional(c.string), codecs: c.array(c.struct({ mimeType: c.string, payloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.optional(c.any), rtcpFeedback: c.optional(c.array(c.struct({ type: c.string, parameter: c.optional(c.string) }))) })), headerExtensions: c.optional(c.array(c.struct({ uri: c.string, id: c.integer, encrypt: c.optional(c.boolean), parameters: c.any }))), encodings: c.optional(c.array(c.struct({ ssrc: c.optional(c.integer), rid: c.optional(c.string), codecPayloadType: c.optional(c.integer), rtx: c.optional(c.struct({ ssrc: c.integer })), dtx: c.optional(c.boolean), scalabilityMode: c.optional(c.string) }))), rtcp: c.optional(c.struct({ cname: c.optional(c.string), reducedSize: c.optional(c.boolean), mux: c.optional(c.boolean) })) })),
            paused: c.boolean,
        });
        let descriptor: EntityDescriptor<KitchenProducerShape> = {
            name: 'KitchenProducer',
            storageKey: 'kitchenProducer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new KitchenProducerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<KitchenProducerShape>) {
        super(descriptor);
    }

    readonly routerActive = Object.freeze({
        findAll: async (ctx: Context, routerId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId])).items;
        },
        query: (ctx: Context, routerId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (routerId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
        liveStream: (ctx: Context, routerId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
    });

    readonly transportActive = Object.freeze({
        findAll: async (ctx: Context, transportId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [transportId])).items;
        },
        query: (ctx: Context, transportId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [transportId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (transportId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [transportId], opts);
        },
        liveStream: (ctx: Context, transportId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [transportId], opts);
        },
    });

    create(ctx: Context, id: string, src: KitchenProducerCreateShape): Promise<KitchenProducer> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: KitchenProducerCreateShape): KitchenProducer {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<KitchenProducer | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<KitchenProducerShape>): KitchenProducer {
        return new KitchenProducer([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface KitchenConsumerShape {
    id: string;
    routerId: string;
    transportId: string;
    producerId: string;
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    parameters: { rtpCapabilities: { codecs: ({ kind: 'audio' | 'video', mimeType: string, clockRate: number, channels: number | null, parameters: any, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[] | null, headerExtensions: ({ uri: string, preferredId: number, kind: '' | 'audio' | 'video' | null, preferredEncrypt: boolean | null, direction: 'sendrecv' | 'sendonly' | 'recvonly' | 'inactive' | null })[] | null, fecMechanisms: (string)[] | null } | null, preferredLayers: { spatialLayer: number, temporalLayer: number | null } | null, paused: boolean | null };
    rtpParameters: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null;
    paused: boolean;
}

export interface KitchenConsumerCreateShape {
    routerId: string;
    transportId: string;
    producerId: string;
    state: 'creating' | 'created' | 'deleting' | 'deleted';
    parameters: { rtpCapabilities: { codecs: ({ kind: 'audio' | 'video', mimeType: string, clockRate: number, channels: number | null | undefined, parameters: any, rtcpFeedback: ({ type: string, parameter: string | null | undefined })[] | null | undefined })[] | null | undefined, headerExtensions: ({ uri: string, preferredId: number, kind: '' | 'audio' | 'video' | null | undefined, preferredEncrypt: boolean | null | undefined, direction: 'sendrecv' | 'sendonly' | 'recvonly' | 'inactive' | null | undefined })[] | null | undefined, fecMechanisms: (string)[] | null | undefined } | null | undefined, preferredLayers: { spatialLayer: number, temporalLayer: number | null | undefined } | null | undefined, paused: boolean | null | undefined };
    rtpParameters?: { mid: string | null | undefined, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null | undefined, parameters: any | null | undefined, rtcpFeedback: ({ type: string, parameter: string | null | undefined })[] | null | undefined })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null | undefined, parameters: any })[] | null | undefined, encodings: ({ ssrc: number | null | undefined, rid: string | null | undefined, codecPayloadType: number | null | undefined, rtx: { ssrc: number } | null | undefined, dtx: boolean | null | undefined, scalabilityMode: string | null | undefined })[] | null | undefined, rtcp: { cname: string | null | undefined, reducedSize: boolean | null | undefined, mux: boolean | null | undefined } | null | undefined } | null | undefined;
    paused: boolean;
}

export class KitchenConsumer extends Entity<KitchenConsumerShape> {
    get id(): string { return this._rawValue.id; }
    get routerId(): string { return this._rawValue.routerId; }
    set routerId(value: string) {
        let normalized = this.descriptor.codec.fields.routerId.normalize(value);
        if (this._rawValue.routerId !== normalized) {
            this._rawValue.routerId = normalized;
            this._updatedValues.routerId = normalized;
            this.invalidate();
        }
    }
    get transportId(): string { return this._rawValue.transportId; }
    set transportId(value: string) {
        let normalized = this.descriptor.codec.fields.transportId.normalize(value);
        if (this._rawValue.transportId !== normalized) {
            this._rawValue.transportId = normalized;
            this._updatedValues.transportId = normalized;
            this.invalidate();
        }
    }
    get producerId(): string { return this._rawValue.producerId; }
    set producerId(value: string) {
        let normalized = this.descriptor.codec.fields.producerId.normalize(value);
        if (this._rawValue.producerId !== normalized) {
            this._rawValue.producerId = normalized;
            this._updatedValues.producerId = normalized;
            this.invalidate();
        }
    }
    get state(): 'creating' | 'created' | 'deleting' | 'deleted' { return this._rawValue.state; }
    set state(value: 'creating' | 'created' | 'deleting' | 'deleted') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get parameters(): { rtpCapabilities: { codecs: ({ kind: 'audio' | 'video', mimeType: string, clockRate: number, channels: number | null, parameters: any, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[] | null, headerExtensions: ({ uri: string, preferredId: number, kind: '' | 'audio' | 'video' | null, preferredEncrypt: boolean | null, direction: 'sendrecv' | 'sendonly' | 'recvonly' | 'inactive' | null })[] | null, fecMechanisms: (string)[] | null } | null, preferredLayers: { spatialLayer: number, temporalLayer: number | null } | null, paused: boolean | null } { return this._rawValue.parameters; }
    set parameters(value: { rtpCapabilities: { codecs: ({ kind: 'audio' | 'video', mimeType: string, clockRate: number, channels: number | null, parameters: any, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[] | null, headerExtensions: ({ uri: string, preferredId: number, kind: '' | 'audio' | 'video' | null, preferredEncrypt: boolean | null, direction: 'sendrecv' | 'sendonly' | 'recvonly' | 'inactive' | null })[] | null, fecMechanisms: (string)[] | null } | null, preferredLayers: { spatialLayer: number, temporalLayer: number | null } | null, paused: boolean | null }) {
        let normalized = this.descriptor.codec.fields.parameters.normalize(value);
        if (this._rawValue.parameters !== normalized) {
            this._rawValue.parameters = normalized;
            this._updatedValues.parameters = normalized;
            this.invalidate();
        }
    }
    get rtpParameters(): { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null { return this._rawValue.rtpParameters; }
    set rtpParameters(value: { mid: string | null, codecs: ({ mimeType: string, payloadType: number, clockRate: number, channels: number | null, parameters: any | null, rtcpFeedback: ({ type: string, parameter: string | null })[] | null })[], headerExtensions: ({ uri: string, id: number, encrypt: boolean | null, parameters: any })[] | null, encodings: ({ ssrc: number | null, rid: string | null, codecPayloadType: number | null, rtx: { ssrc: number } | null, dtx: boolean | null, scalabilityMode: string | null })[] | null, rtcp: { cname: string | null, reducedSize: boolean | null, mux: boolean | null } | null } | null) {
        let normalized = this.descriptor.codec.fields.rtpParameters.normalize(value);
        if (this._rawValue.rtpParameters !== normalized) {
            this._rawValue.rtpParameters = normalized;
            this._updatedValues.rtpParameters = normalized;
            this.invalidate();
        }
    }
    get paused(): boolean { return this._rawValue.paused; }
    set paused(value: boolean) {
        let normalized = this.descriptor.codec.fields.paused.normalize(value);
        if (this._rawValue.paused !== normalized) {
            this._rawValue.paused = normalized;
            this._updatedValues.paused = normalized;
            this.invalidate();
        }
    }
}

export class KitchenConsumerFactory extends EntityFactory<KitchenConsumerShape, KitchenConsumer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('kitchenConsumer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'routerActive', storageKey: 'routerActive', type: { type: 'range', fields: [{ name: 'routerId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenConsumer', 'routerActive'), condition: (s) => s.state !== 'deleted' });
        secondaryIndexes.push({ name: 'transportActive', storageKey: 'transportActive', type: { type: 'range', fields: [{ name: 'transportId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenConsumer', 'transportActive'), condition: (s) => s.state !== 'deleted' });
        secondaryIndexes.push({ name: 'producerActive', storageKey: 'producerActive', type: { type: 'range', fields: [{ name: 'producerId', type: 'string' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('kitchenConsumer', 'producerActive'), condition: (s) => s.state !== 'deleted' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'routerId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'transportId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'producerId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['creating', 'created', 'deleting', 'deleted'] }, secure: false });
        fields.push({ name: 'parameters', type: { type: 'struct', fields: { rtpCapabilities: { type: 'optional', inner: { type: 'struct', fields: { codecs: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { kind: { type: 'enum', values: ['audio', 'video'] }, mimeType: { type: 'string' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'json' }, rtcpFeedback: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, parameter: { type: 'optional', inner: { type: 'string' } } } } } } } } } }, headerExtensions: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { uri: { type: 'string' }, preferredId: { type: 'integer' }, kind: { type: 'optional', inner: { type: 'enum', values: ['', 'audio', 'video'] } }, preferredEncrypt: { type: 'optional', inner: { type: 'boolean' } }, direction: { type: 'optional', inner: { type: 'enum', values: ['sendrecv', 'sendonly', 'recvonly', 'inactive'] } } } } } }, fecMechanisms: { type: 'optional', inner: { type: 'array', inner: { type: 'string' } } } } } }, preferredLayers: { type: 'optional', inner: { type: 'struct', fields: { spatialLayer: { type: 'integer' }, temporalLayer: { type: 'optional', inner: { type: 'integer' } } } } }, paused: { type: 'optional', inner: { type: 'boolean' } } } }, secure: false });
        fields.push({ name: 'rtpParameters', type: { type: 'optional', inner: { type: 'struct', fields: { mid: { type: 'optional', inner: { type: 'string' } }, codecs: { type: 'array', inner: { type: 'struct', fields: { mimeType: { type: 'string' }, payloadType: { type: 'integer' }, clockRate: { type: 'integer' }, channels: { type: 'optional', inner: { type: 'integer' } }, parameters: { type: 'optional', inner: { type: 'json' } }, rtcpFeedback: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { type: { type: 'string' }, parameter: { type: 'optional', inner: { type: 'string' } } } } } } } } }, headerExtensions: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { uri: { type: 'string' }, id: { type: 'integer' }, encrypt: { type: 'optional', inner: { type: 'boolean' } }, parameters: { type: 'json' } } } } }, encodings: { type: 'optional', inner: { type: 'array', inner: { type: 'struct', fields: { ssrc: { type: 'optional', inner: { type: 'integer' } }, rid: { type: 'optional', inner: { type: 'string' } }, codecPayloadType: { type: 'optional', inner: { type: 'integer' } }, rtx: { type: 'optional', inner: { type: 'struct', fields: { ssrc: { type: 'integer' } } } }, dtx: { type: 'optional', inner: { type: 'boolean' } }, scalabilityMode: { type: 'optional', inner: { type: 'string' } } } } } }, rtcp: { type: 'optional', inner: { type: 'struct', fields: { cname: { type: 'optional', inner: { type: 'string' } }, reducedSize: { type: 'optional', inner: { type: 'boolean' } }, mux: { type: 'optional', inner: { type: 'boolean' } } } } } } } }, secure: false });
        fields.push({ name: 'paused', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            routerId: c.string,
            transportId: c.string,
            producerId: c.string,
            state: c.enum('creating', 'created', 'deleting', 'deleted'),
            parameters: c.struct({ rtpCapabilities: c.optional(c.struct({ codecs: c.optional(c.array(c.struct({ kind: c.enum('audio', 'video'), mimeType: c.string, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.any, rtcpFeedback: c.optional(c.array(c.struct({ type: c.string, parameter: c.optional(c.string) }))) }))), headerExtensions: c.optional(c.array(c.struct({ uri: c.string, preferredId: c.integer, kind: c.optional(c.enum('', 'audio', 'video')), preferredEncrypt: c.optional(c.boolean), direction: c.optional(c.enum('sendrecv', 'sendonly', 'recvonly', 'inactive')) }))), fecMechanisms: c.optional(c.array(c.string)) })), preferredLayers: c.optional(c.struct({ spatialLayer: c.integer, temporalLayer: c.optional(c.integer) })), paused: c.optional(c.boolean) }),
            rtpParameters: c.optional(c.struct({ mid: c.optional(c.string), codecs: c.array(c.struct({ mimeType: c.string, payloadType: c.integer, clockRate: c.integer, channels: c.optional(c.integer), parameters: c.optional(c.any), rtcpFeedback: c.optional(c.array(c.struct({ type: c.string, parameter: c.optional(c.string) }))) })), headerExtensions: c.optional(c.array(c.struct({ uri: c.string, id: c.integer, encrypt: c.optional(c.boolean), parameters: c.any }))), encodings: c.optional(c.array(c.struct({ ssrc: c.optional(c.integer), rid: c.optional(c.string), codecPayloadType: c.optional(c.integer), rtx: c.optional(c.struct({ ssrc: c.integer })), dtx: c.optional(c.boolean), scalabilityMode: c.optional(c.string) }))), rtcp: c.optional(c.struct({ cname: c.optional(c.string), reducedSize: c.optional(c.boolean), mux: c.optional(c.boolean) })) })),
            paused: c.boolean,
        });
        let descriptor: EntityDescriptor<KitchenConsumerShape> = {
            name: 'KitchenConsumer',
            storageKey: 'kitchenConsumer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new KitchenConsumerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<KitchenConsumerShape>) {
        super(descriptor);
    }

    readonly routerActive = Object.freeze({
        findAll: async (ctx: Context, routerId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId])).items;
        },
        query: (ctx: Context, routerId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [routerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (routerId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
        liveStream: (ctx: Context, routerId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [routerId], opts);
        },
    });

    readonly transportActive = Object.freeze({
        findAll: async (ctx: Context, transportId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [transportId])).items;
        },
        query: (ctx: Context, transportId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [transportId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (transportId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [transportId], opts);
        },
        liveStream: (ctx: Context, transportId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [transportId], opts);
        },
    });

    readonly producerActive = Object.freeze({
        findAll: async (ctx: Context, producerId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [producerId])).items;
        },
        query: (ctx: Context, producerId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [producerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (producerId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [producerId], opts);
        },
        liveStream: (ctx: Context, producerId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [producerId], opts);
        },
    });

    create(ctx: Context, id: string, src: KitchenConsumerCreateShape): Promise<KitchenConsumer> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: KitchenConsumerCreateShape): KitchenConsumer {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<KitchenConsumer | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<KitchenConsumerShape>): KitchenConsumer {
        return new KitchenConsumer([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserEdgeShape {
    uid1: number;
    uid2: number;
    weight: number | null;
}

export interface UserEdgeCreateShape {
    weight?: number | null | undefined;
}

export class UserEdge extends Entity<UserEdgeShape> {
    get uid1(): number { return this._rawValue.uid1; }
    get uid2(): number { return this._rawValue.uid2; }
    get weight(): number | null { return this._rawValue.weight; }
    set weight(value: number | null) {
        let normalized = this.descriptor.codec.fields.weight.normalize(value);
        if (this._rawValue.weight !== normalized) {
            this._rawValue.weight = normalized;
            this._updatedValues.weight = normalized;
            this.invalidate();
        }
    }
}

export class UserEdgeFactory extends EntityFactory<UserEdgeShape, UserEdge> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userEdge');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'forward', storageKey: 'forward', type: { type: 'range', fields: [{ name: 'uid1', type: 'integer' }, { name: 'uid2', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'forward'), condition: undefined });
        secondaryIndexes.push({ name: 'reverse', storageKey: 'reverse', type: { type: 'range', fields: [{ name: 'uid2', type: 'integer' }, { name: 'uid1', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'reverse'), condition: undefined });
        secondaryIndexes.push({ name: 'forwardWeight', storageKey: 'forwardWeight', type: { type: 'range', fields: [{ name: 'uid1', type: 'integer' }, { name: 'weight', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'forwardWeight'), condition: undefined });
        secondaryIndexes.push({ name: 'reverseWeight', storageKey: 'reverseWeight', type: { type: 'range', fields: [{ name: 'uid2', type: 'integer' }, { name: 'weight', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userEdge', 'reverseWeight'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid1', type: 'integer' });
        primaryKeys.push({ name: 'uid2', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'weight', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            uid1: c.integer,
            uid2: c.integer,
            weight: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<UserEdgeShape> = {
            name: 'UserEdge',
            storageKey: 'userEdge',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserEdgeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserEdgeShape>) {
        super(descriptor);
    }

    readonly forward = Object.freeze({
        findAll: async (ctx: Context, uid1: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1])).items;
        },
        query: (ctx: Context, uid1: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid1], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid1: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid1], opts);
        },
        liveStream: (ctx: Context, uid1: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid1], opts);
        },
    });

    readonly reverse = Object.freeze({
        findAll: async (ctx: Context, uid2: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2])).items;
        },
        query: (ctx: Context, uid2: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid2], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid2: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid2], opts);
        },
        liveStream: (ctx: Context, uid2: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid2], opts);
        },
    });

    readonly forwardWeight = Object.freeze({
        findAll: async (ctx: Context, uid1: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [uid1])).items;
        },
        query: (ctx: Context, uid1: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [uid1], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid1: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [uid1], opts);
        },
        liveStream: (ctx: Context, uid1: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [uid1], opts);
        },
    });

    readonly reverseWeight = Object.freeze({
        findAll: async (ctx: Context, uid2: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [uid2])).items;
        },
        query: (ctx: Context, uid2: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [uid2], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid2: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [uid2], opts);
        },
        liveStream: (ctx: Context, uid2: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [uid2], opts);
        },
    });

    create(ctx: Context, uid1: number, uid2: number, src: UserEdgeCreateShape): Promise<UserEdge> {
        return this._create(ctx, [uid1, uid2], this.descriptor.codec.normalize({ uid1, uid2, ...src }));
    }

    create_UNSAFE(ctx: Context, uid1: number, uid2: number, src: UserEdgeCreateShape): UserEdge {
        return this._create_UNSAFE(ctx, [uid1, uid2], this.descriptor.codec.normalize({ uid1, uid2, ...src }));
    }

    findById(ctx: Context, uid1: number, uid2: number): Promise<UserEdge | null> {
        return this._findById(ctx, [uid1, uid2]);
    }

    watch(ctx: Context, uid1: number, uid2: number): Watch {
        return this._watch(ctx, [uid1, uid2]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserEdgeShape>): UserEdge {
        return new UserEdge([value.uid1, value.uid2], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserGroupEdgeShape {
    uid: number;
    cid: number;
    weight: number | null;
}

export interface UserGroupEdgeCreateShape {
    weight?: number | null | undefined;
}

export class UserGroupEdge extends Entity<UserGroupEdgeShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get weight(): number | null { return this._rawValue.weight; }
    set weight(value: number | null) {
        let normalized = this.descriptor.codec.fields.weight.normalize(value);
        if (this._rawValue.weight !== normalized) {
            this._rawValue.weight = normalized;
            this._updatedValues.weight = normalized;
            this.invalidate();
        }
    }
}

export class UserGroupEdgeFactory extends EntityFactory<UserGroupEdgeShape, UserGroupEdge> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userGroupEdge');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'weight', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userGroupEdge', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'weight', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            weight: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<UserGroupEdgeShape> = {
            name: 'UserGroupEdge',
            storageKey: 'userGroupEdge',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserGroupEdgeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserGroupEdgeShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, cid: number, src: UserGroupEdgeCreateShape): Promise<UserGroupEdge> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, src: UserGroupEdgeCreateShape): UserGroupEdge {
        return this._create_UNSAFE(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<UserGroupEdge | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserGroupEdgeShape>): UserGroupEdge {
        return new UserGroupEdge([value.uid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserInfluencerUserIndexShape {
    uid: number;
    value: number;
}

export interface UserInfluencerUserIndexCreateShape {
    value: number;
}

export class UserInfluencerUserIndex extends Entity<UserInfluencerUserIndexShape> {
    get uid(): number { return this._rawValue.uid; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserInfluencerUserIndexFactory extends EntityFactory<UserInfluencerUserIndexShape, UserInfluencerUserIndex> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userInfluencerUserIndex');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<UserInfluencerUserIndexShape> = {
            name: 'UserInfluencerUserIndex',
            storageKey: 'userInfluencerUserIndex',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserInfluencerUserIndexFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserInfluencerUserIndexShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserInfluencerUserIndexCreateShape): Promise<UserInfluencerUserIndex> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserInfluencerUserIndexCreateShape): UserInfluencerUserIndex {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserInfluencerUserIndex | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserInfluencerUserIndexShape>): UserInfluencerUserIndex {
        return new UserInfluencerUserIndex([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserInfluencerIndexShape {
    uid: number;
    value: number;
}

export interface UserInfluencerIndexCreateShape {
    value: number;
}

export class UserInfluencerIndex extends Entity<UserInfluencerIndexShape> {
    get uid(): number { return this._rawValue.uid; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserInfluencerIndexFactory extends EntityFactory<UserInfluencerIndexShape, UserInfluencerIndex> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userInfluencerIndex');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<UserInfluencerIndexShape> = {
            name: 'UserInfluencerIndex',
            storageKey: 'userInfluencerIndex',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserInfluencerIndexFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserInfluencerIndexShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserInfluencerIndexCreateShape): Promise<UserInfluencerIndex> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserInfluencerIndexCreateShape): UserInfluencerIndex {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserInfluencerIndex | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserInfluencerIndexShape>): UserInfluencerIndex {
        return new UserInfluencerIndex([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserBadgeShape {
    id: number;
    uid: number;
    name: string;
    verifiedBy: number | null;
    deleted: boolean | null;
}

export interface UserBadgeCreateShape {
    uid: number;
    name: string;
    verifiedBy?: number | null | undefined;
    deleted?: boolean | null | undefined;
}

export class UserBadge extends Entity<UserBadgeShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get name(): string { return this._rawValue.name; }
    set name(value: string) {
        let normalized = this.descriptor.codec.fields.name.normalize(value);
        if (this._rawValue.name !== normalized) {
            this._rawValue.name = normalized;
            this._updatedValues.name = normalized;
            this.invalidate();
        }
    }
    get verifiedBy(): number | null { return this._rawValue.verifiedBy; }
    set verifiedBy(value: number | null) {
        let normalized = this.descriptor.codec.fields.verifiedBy.normalize(value);
        if (this._rawValue.verifiedBy !== normalized) {
            this._rawValue.verifiedBy = normalized;
            this._updatedValues.verifiedBy = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class UserBadgeFactory extends EntityFactory<UserBadgeShape, UserBadge> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userBadge');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userBadge', 'user'), condition: (src) => !src.deleted });
        secondaryIndexes.push({ name: 'name', storageKey: 'name', type: { type: 'range', fields: [{ name: 'name', type: 'string' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userBadge', 'name'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'name', type: { type: 'string' }, secure: false });
        fields.push({ name: 'verifiedBy', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
            name: c.string,
            verifiedBy: c.optional(c.integer),
            deleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<UserBadgeShape> = {
            name: 'UserBadge',
            storageKey: 'userBadge',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserBadgeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserBadgeShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly name = Object.freeze({
        findAll: async (ctx: Context, name: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [name])).items;
        },
        query: (ctx: Context, name: string, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [name], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (name: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [name], opts);
        },
        liveStream: (ctx: Context, name: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [name], opts);
        },
    });

    create(ctx: Context, id: number, src: UserBadgeCreateShape): Promise<UserBadge> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserBadgeCreateShape): UserBadge {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserBadge | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserBadgeShape>): UserBadge {
        return new UserBadge([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserRoomBadgeShape {
    uid: number;
    cid: number;
    bid: number | null;
}

export interface UserRoomBadgeCreateShape {
    bid?: number | null | undefined;
}

export class UserRoomBadge extends Entity<UserRoomBadgeShape> {
    get uid(): number { return this._rawValue.uid; }
    get cid(): number { return this._rawValue.cid; }
    get bid(): number | null { return this._rawValue.bid; }
    set bid(value: number | null) {
        let normalized = this.descriptor.codec.fields.bid.normalize(value);
        if (this._rawValue.bid !== normalized) {
            this._rawValue.bid = normalized;
            this._updatedValues.bid = normalized;
            this.invalidate();
        }
    }
}

export class UserRoomBadgeFactory extends EntityFactory<UserRoomBadgeShape, UserRoomBadge> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userRoomBadge');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'chat', storageKey: 'chat', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userRoomBadge', 'chat'), condition: (src) => !!src.bid });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'cid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userRoomBadge', 'user'), condition: (src) => !!src.bid });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'bid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            cid: c.integer,
            bid: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<UserRoomBadgeShape> = {
            name: 'UserRoomBadge',
            storageKey: 'userRoomBadge',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserRoomBadgeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserRoomBadgeShape>) {
        super(descriptor);
    }

    readonly chat = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [cid], opts);
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, cid: number, src: UserRoomBadgeCreateShape): Promise<UserRoomBadge> {
        return this._create(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, cid: number, src: UserRoomBadgeCreateShape): UserRoomBadge {
        return this._create_UNSAFE(ctx, [uid, cid], this.descriptor.codec.normalize({ uid, cid, ...src }));
    }

    findById(ctx: Context, uid: number, cid: number): Promise<UserRoomBadge | null> {
        return this._findById(ctx, [uid, cid]);
    }

    watch(ctx: Context, uid: number, cid: number): Watch {
        return this._watch(ctx, [uid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserRoomBadgeShape>): UserRoomBadge {
        return new UserRoomBadge([value.uid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ShortnameReservationShape {
    shortname: string;
    ownerType: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub';
    ownerId: number;
    enabled: boolean;
}

export interface ShortnameReservationCreateShape {
    ownerType: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub';
    ownerId: number;
    enabled: boolean;
}

export class ShortnameReservation extends Entity<ShortnameReservationShape> {
    get shortname(): string { return this._rawValue.shortname; }
    get ownerType(): 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub' { return this._rawValue.ownerType; }
    set ownerType(value: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub') {
        let normalized = this.descriptor.codec.fields.ownerType.normalize(value);
        if (this._rawValue.ownerType !== normalized) {
            this._rawValue.ownerType = normalized;
            this._updatedValues.ownerType = normalized;
            this.invalidate();
        }
    }
    get ownerId(): number { return this._rawValue.ownerId; }
    set ownerId(value: number) {
        let normalized = this.descriptor.codec.fields.ownerId.normalize(value);
        if (this._rawValue.ownerId !== normalized) {
            this._rawValue.ownerId = normalized;
            this._updatedValues.ownerId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class ShortnameReservationFactory extends EntityFactory<ShortnameReservationShape, ShortnameReservation> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('shortnameReservation');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'unique', fields: [{ name: 'ownerId', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('shortnameReservation', 'user'), condition: (src) => src.ownerType === 'user' && src.enabled });
        secondaryIndexes.push({ name: 'org', storageKey: 'org', type: { type: 'unique', fields: [{ name: 'ownerId', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('shortnameReservation', 'org'), condition: (src) => src.ownerType === 'org' && src.enabled });
        secondaryIndexes.push({ name: 'fromOwner', storageKey: 'fromOwner', type: { type: 'unique', fields: [{ name: 'ownerType', type: 'string' }, { name: 'ownerId', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('shortnameReservation', 'fromOwner'), condition: (src) => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'shortname', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ownerType', type: { type: 'enum', values: ['org', 'user', 'feed_channel', 'room', 'collection', 'hub'] }, secure: false });
        fields.push({ name: 'ownerId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            shortname: c.string,
            ownerType: c.enum('org', 'user', 'feed_channel', 'room', 'collection', 'hub'),
            ownerId: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<ShortnameReservationShape> = {
            name: 'ShortnameReservation',
            storageKey: 'shortnameReservation',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ShortnameReservationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ShortnameReservationShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        find: async (ctx: Context, ownerId: number) => {
            return this._findFromUniqueIndex(ctx, [ownerId], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly org = Object.freeze({
        find: async (ctx: Context, ownerId: number) => {
            return this._findFromUniqueIndex(ctx, [ownerId], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly fromOwner = Object.freeze({
        find: async (ctx: Context, ownerType: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub', ownerId: number) => {
            return this._findFromUniqueIndex(ctx, [ownerType, ownerId], this.descriptor.secondaryIndexes[2]);
        },
        findAll: async (ctx: Context, ownerType: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub') => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [ownerType])).items;
        },
        query: (ctx: Context, ownerType: 'org' | 'user' | 'feed_channel' | 'room' | 'collection' | 'hub', opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [ownerType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, shortname: string, src: ShortnameReservationCreateShape): Promise<ShortnameReservation> {
        return this._create(ctx, [shortname], this.descriptor.codec.normalize({ shortname, ...src }));
    }

    create_UNSAFE(ctx: Context, shortname: string, src: ShortnameReservationCreateShape): ShortnameReservation {
        return this._create_UNSAFE(ctx, [shortname], this.descriptor.codec.normalize({ shortname, ...src }));
    }

    findById(ctx: Context, shortname: string): Promise<ShortnameReservation | null> {
        return this._findById(ctx, [shortname]);
    }

    watch(ctx: Context, shortname: string): Watch {
        return this._watch(ctx, [shortname]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ShortnameReservationShape>): ShortnameReservation {
        return new ShortnameReservation([value.shortname], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface NotificationCenterShape {
    id: number;
    kind: 'user';
}

export interface NotificationCenterCreateShape {
    kind: 'user';
}

export class NotificationCenter extends Entity<NotificationCenterShape> {
    get id(): number { return this._rawValue.id; }
    get kind(): 'user' { return this._rawValue.kind; }
    set kind(value: 'user') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class NotificationCenterFactory extends EntityFactory<NotificationCenterShape, NotificationCenter> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('notificationCenter');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'kind', type: { type: 'enum', values: ['user'] }, secure: false });
        let codec = c.struct({
            id: c.integer,
            kind: c.enum('user'),
        });
        let descriptor: EntityDescriptor<NotificationCenterShape> = {
            name: 'NotificationCenter',
            storageKey: 'notificationCenter',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new NotificationCenterFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<NotificationCenterShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: NotificationCenterCreateShape): Promise<NotificationCenter> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: NotificationCenterCreateShape): NotificationCenter {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<NotificationCenter | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<NotificationCenterShape>): NotificationCenter {
        return new NotificationCenter([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserNotificationCenterShape {
    id: number;
    uid: number;
}

export interface UserNotificationCenterCreateShape {
    uid: number;
}

export class UserNotificationCenter extends Entity<UserNotificationCenterShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
}

export class UserNotificationCenterFactory extends EntityFactory<UserNotificationCenterShape, UserNotificationCenter> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userNotificationCenter');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userNotificationCenter', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
        });
        let descriptor: EntityDescriptor<UserNotificationCenterShape> = {
            name: 'UserNotificationCenter',
            storageKey: 'userNotificationCenter',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserNotificationCenterFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserNotificationCenterShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        find: async (ctx: Context, uid: number) => {
            return this._findFromUniqueIndex(ctx, [uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: UserNotificationCenterCreateShape): Promise<UserNotificationCenter> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserNotificationCenterCreateShape): UserNotificationCenter {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserNotificationCenter | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserNotificationCenterShape>): UserNotificationCenter {
        return new UserNotificationCenter([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface NotificationShape {
    id: number;
    ncid: number;
    text: string | null;
    deleted: boolean | null;
    content: ({ type: 'new_comment', commentId: number } | { type: 'new_matchmaking_profiles', peerId: number, uids: (number)[], peerType: string } | { type: 'mention', peerId: number, peerType: string, messageId: number, messageType: string })[] | null;
}

export interface NotificationCreateShape {
    ncid: number;
    text?: string | null | undefined;
    deleted?: boolean | null | undefined;
    content?: ({ type: 'new_comment', commentId: number } | { type: 'new_matchmaking_profiles', peerId: number, uids: (number)[], peerType: string } | { type: 'mention', peerId: number, peerType: string, messageId: number, messageType: string })[] | null | undefined;
}

export class Notification extends Entity<NotificationShape> {
    get id(): number { return this._rawValue.id; }
    get ncid(): number { return this._rawValue.ncid; }
    set ncid(value: number) {
        let normalized = this.descriptor.codec.fields.ncid.normalize(value);
        if (this._rawValue.ncid !== normalized) {
            this._rawValue.ncid = normalized;
            this._updatedValues.ncid = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get content(): ({ type: 'new_comment', commentId: number } | { type: 'new_matchmaking_profiles', peerId: number, uids: (number)[], peerType: string } | { type: 'mention', peerId: number, peerType: string, messageId: number, messageType: string })[] | null { return this._rawValue.content; }
    set content(value: ({ type: 'new_comment', commentId: number } | { type: 'new_matchmaking_profiles', peerId: number, uids: (number)[], peerType: string } | { type: 'mention', peerId: number, peerType: string, messageId: number, messageType: string })[] | null) {
        let normalized = this.descriptor.codec.fields.content.normalize(value);
        if (this._rawValue.content !== normalized) {
            this._rawValue.content = normalized;
            this._updatedValues.content = normalized;
            this.invalidate();
        }
    }
}

export class NotificationFactory extends EntityFactory<NotificationShape, Notification> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('notification');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'notificationCenter', storageKey: 'notificationCenter', type: { type: 'range', fields: [{ name: 'ncid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('notification', 'notificationCenter'), condition: (src) => !src.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ncid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'content', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { new_comment: { commentId: { type: 'integer' } }, new_matchmaking_profiles: { peerId: { type: 'integer' }, uids: { type: 'array', inner: { type: 'integer' } }, peerType: { type: 'string' } }, mention: { peerId: { type: 'integer' }, peerType: { type: 'string' }, messageId: { type: 'integer' }, messageType: { type: 'string' } } } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ncid: c.integer,
            text: c.optional(c.string),
            deleted: c.optional(c.boolean),
            content: c.optional(c.array(c.union({ new_comment: c.struct({ commentId: c.integer }), new_matchmaking_profiles: c.struct({ peerId: c.integer, uids: c.array(c.integer), peerType: c.string }), mention: c.struct({ peerId: c.integer, peerType: c.string, messageId: c.integer, messageType: c.string }) }))),
        });
        let descriptor: EntityDescriptor<NotificationShape> = {
            name: 'Notification',
            storageKey: 'notification',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new NotificationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<NotificationShape>) {
        super(descriptor);
    }

    readonly notificationCenter = Object.freeze({
        findAll: async (ctx: Context, ncid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [ncid])).items;
        },
        query: (ctx: Context, ncid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [ncid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (ncid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [ncid], opts);
        },
        liveStream: (ctx: Context, ncid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [ncid], opts);
        },
    });

    create(ctx: Context, id: number, src: NotificationCreateShape): Promise<Notification> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: NotificationCreateShape): Notification {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Notification | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<NotificationShape>): Notification {
        return new Notification([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface NotificationCenterStateShape {
    ncid: number;
    seq: number;
    readNotificationId: number | null;
    readSeq: number | null;
    lastEmailNotification: number | null;
    lastPushNotification: number | null;
    lastEmailSeq: number | null;
    lastPushSeq: number | null;
}

export interface NotificationCenterStateCreateShape {
    seq: number;
    readNotificationId?: number | null | undefined;
    readSeq?: number | null | undefined;
    lastEmailNotification?: number | null | undefined;
    lastPushNotification?: number | null | undefined;
    lastEmailSeq?: number | null | undefined;
    lastPushSeq?: number | null | undefined;
}

export class NotificationCenterState extends Entity<NotificationCenterStateShape> {
    get ncid(): number { return this._rawValue.ncid; }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
    get readNotificationId(): number | null { return this._rawValue.readNotificationId; }
    set readNotificationId(value: number | null) {
        let normalized = this.descriptor.codec.fields.readNotificationId.normalize(value);
        if (this._rawValue.readNotificationId !== normalized) {
            this._rawValue.readNotificationId = normalized;
            this._updatedValues.readNotificationId = normalized;
            this.invalidate();
        }
    }
    get readSeq(): number | null { return this._rawValue.readSeq; }
    set readSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.readSeq.normalize(value);
        if (this._rawValue.readSeq !== normalized) {
            this._rawValue.readSeq = normalized;
            this._updatedValues.readSeq = normalized;
            this.invalidate();
        }
    }
    get lastEmailNotification(): number | null { return this._rawValue.lastEmailNotification; }
    set lastEmailNotification(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastEmailNotification.normalize(value);
        if (this._rawValue.lastEmailNotification !== normalized) {
            this._rawValue.lastEmailNotification = normalized;
            this._updatedValues.lastEmailNotification = normalized;
            this.invalidate();
        }
    }
    get lastPushNotification(): number | null { return this._rawValue.lastPushNotification; }
    set lastPushNotification(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastPushNotification.normalize(value);
        if (this._rawValue.lastPushNotification !== normalized) {
            this._rawValue.lastPushNotification = normalized;
            this._updatedValues.lastPushNotification = normalized;
            this.invalidate();
        }
    }
    get lastEmailSeq(): number | null { return this._rawValue.lastEmailSeq; }
    set lastEmailSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastEmailSeq.normalize(value);
        if (this._rawValue.lastEmailSeq !== normalized) {
            this._rawValue.lastEmailSeq = normalized;
            this._updatedValues.lastEmailSeq = normalized;
            this.invalidate();
        }
    }
    get lastPushSeq(): number | null { return this._rawValue.lastPushSeq; }
    set lastPushSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastPushSeq.normalize(value);
        if (this._rawValue.lastPushSeq !== normalized) {
            this._rawValue.lastPushSeq = normalized;
            this._updatedValues.lastPushSeq = normalized;
            this.invalidate();
        }
    }
}

export class NotificationCenterStateFactory extends EntityFactory<NotificationCenterStateShape, NotificationCenterState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('notificationCenterState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'ncid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'readNotificationId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'readSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastEmailNotification', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastPushNotification', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastEmailSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastPushSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            ncid: c.integer,
            seq: c.integer,
            readNotificationId: c.optional(c.integer),
            readSeq: c.optional(c.integer),
            lastEmailNotification: c.optional(c.integer),
            lastPushNotification: c.optional(c.integer),
            lastEmailSeq: c.optional(c.integer),
            lastPushSeq: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<NotificationCenterStateShape> = {
            name: 'NotificationCenterState',
            storageKey: 'notificationCenterState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new NotificationCenterStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<NotificationCenterStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, ncid: number, src: NotificationCenterStateCreateShape): Promise<NotificationCenterState> {
        return this._create(ctx, [ncid], this.descriptor.codec.normalize({ ncid, ...src }));
    }

    create_UNSAFE(ctx: Context, ncid: number, src: NotificationCenterStateCreateShape): NotificationCenterState {
        return this._create_UNSAFE(ctx, [ncid], this.descriptor.codec.normalize({ ncid, ...src }));
    }

    findById(ctx: Context, ncid: number): Promise<NotificationCenterState | null> {
        return this._findById(ctx, [ncid]);
    }

    watch(ctx: Context, ncid: number): Watch {
        return this._watch(ctx, [ncid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<NotificationCenterStateShape>): NotificationCenterState {
        return new NotificationCenterState([value.ncid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface NotificationCenterEventShape {
    ncid: number;
    seq: number;
    notificationId: number | null;
    updatedContent: { type: 'comment', peerId: number, peerType: string, commentId: number | null } | null;
    kind: 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated';
}

export interface NotificationCenterEventCreateShape {
    notificationId?: number | null | undefined;
    updatedContent?: { type: 'comment', peerId: number, peerType: string, commentId: number | null | undefined } | null | undefined;
    kind: 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated';
}

export class NotificationCenterEvent extends Entity<NotificationCenterEventShape> {
    get ncid(): number { return this._rawValue.ncid; }
    get seq(): number { return this._rawValue.seq; }
    get notificationId(): number | null { return this._rawValue.notificationId; }
    set notificationId(value: number | null) {
        let normalized = this.descriptor.codec.fields.notificationId.normalize(value);
        if (this._rawValue.notificationId !== normalized) {
            this._rawValue.notificationId = normalized;
            this._updatedValues.notificationId = normalized;
            this.invalidate();
        }
    }
    get updatedContent(): { type: 'comment', peerId: number, peerType: string, commentId: number | null } | null { return this._rawValue.updatedContent; }
    set updatedContent(value: { type: 'comment', peerId: number, peerType: string, commentId: number | null } | null) {
        let normalized = this.descriptor.codec.fields.updatedContent.normalize(value);
        if (this._rawValue.updatedContent !== normalized) {
            this._rawValue.updatedContent = normalized;
            this._updatedValues.updatedContent = normalized;
            this.invalidate();
        }
    }
    get kind(): 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated' { return this._rawValue.kind; }
    set kind(value: 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated') {
        let normalized = this.descriptor.codec.fields.kind.normalize(value);
        if (this._rawValue.kind !== normalized) {
            this._rawValue.kind = normalized;
            this._updatedValues.kind = normalized;
            this.invalidate();
        }
    }
}

export class NotificationCenterEventFactory extends EntityFactory<NotificationCenterEventShape, NotificationCenterEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('notificationCenterEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'notificationCenter', storageKey: 'notificationCenter', type: { type: 'range', fields: [{ name: 'ncid', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('notificationCenterEvent', 'notificationCenter'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'ncid', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'notificationId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'updatedContent', type: { type: 'optional', inner: { type: 'union', types: { comment: { peerId: { type: 'integer' }, peerType: { type: 'string' }, commentId: { type: 'optional', inner: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'kind', type: { type: 'enum', values: ['notification_received', 'notification_read', 'notification_deleted', 'notification_updated', 'notification_content_updated'] }, secure: false });
        let codec = c.struct({
            ncid: c.integer,
            seq: c.integer,
            notificationId: c.optional(c.integer),
            updatedContent: c.optional(c.union({ comment: c.struct({ peerId: c.integer, peerType: c.string, commentId: c.optional(c.integer) }) })),
            kind: c.enum('notification_received', 'notification_read', 'notification_deleted', 'notification_updated', 'notification_content_updated'),
        });
        let descriptor: EntityDescriptor<NotificationCenterEventShape> = {
            name: 'NotificationCenterEvent',
            storageKey: 'notificationCenterEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new NotificationCenterEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<NotificationCenterEventShape>) {
        super(descriptor);
    }

    readonly notificationCenter = Object.freeze({
        findAll: async (ctx: Context, ncid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [ncid])).items;
        },
        query: (ctx: Context, ncid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [ncid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (ncid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [ncid], opts);
        },
        liveStream: (ctx: Context, ncid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [ncid], opts);
        },
    });

    create(ctx: Context, ncid: number, seq: number, src: NotificationCenterEventCreateShape): Promise<NotificationCenterEvent> {
        return this._create(ctx, [ncid, seq], this.descriptor.codec.normalize({ ncid, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, ncid: number, seq: number, src: NotificationCenterEventCreateShape): NotificationCenterEvent {
        return this._create_UNSAFE(ctx, [ncid, seq], this.descriptor.codec.normalize({ ncid, seq, ...src }));
    }

    findById(ctx: Context, ncid: number, seq: number): Promise<NotificationCenterEvent | null> {
        return this._findById(ctx, [ncid, seq]);
    }

    watch(ctx: Context, ncid: number, seq: number): Watch {
        return this._watch(ctx, [ncid, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<NotificationCenterEventShape>): NotificationCenterEvent {
        return new NotificationCenterEvent([value.ncid, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserMessagingStateShape {
    uid: number;
    seq: number;
}

export interface UserMessagingStateCreateShape {
    seq: number;
}

export class UserMessagingState extends Entity<UserMessagingStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
}

export class UserMessagingStateFactory extends EntityFactory<UserMessagingStateShape, UserMessagingState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userMessagingState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            seq: c.integer,
        });
        let descriptor: EntityDescriptor<UserMessagingStateShape> = {
            name: 'UserMessagingState',
            storageKey: 'userMessagingState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserMessagingStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserMessagingStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserMessagingStateCreateShape): Promise<UserMessagingState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserMessagingStateCreateShape): UserMessagingState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserMessagingState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserMessagingStateShape>): UserMessagingState {
        return new UserMessagingState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserNotificationsStateShape {
    uid: number;
    lastEmailNotification: number | null;
    lastPushNotification: number | null;
    readSeq: number | null;
    lastEmailSeq: number | null;
    lastPushSeq: number | null;
    lastEmailCursor: string | null;
    lastPushCursor: string | null;
}

export interface UserNotificationsStateCreateShape {
    lastEmailNotification?: number | null | undefined;
    lastPushNotification?: number | null | undefined;
    readSeq?: number | null | undefined;
    lastEmailSeq?: number | null | undefined;
    lastPushSeq?: number | null | undefined;
    lastEmailCursor?: string | null | undefined;
    lastPushCursor?: string | null | undefined;
}

export class UserNotificationsState extends Entity<UserNotificationsStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get lastEmailNotification(): number | null { return this._rawValue.lastEmailNotification; }
    set lastEmailNotification(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastEmailNotification.normalize(value);
        if (this._rawValue.lastEmailNotification !== normalized) {
            this._rawValue.lastEmailNotification = normalized;
            this._updatedValues.lastEmailNotification = normalized;
            this.invalidate();
        }
    }
    get lastPushNotification(): number | null { return this._rawValue.lastPushNotification; }
    set lastPushNotification(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastPushNotification.normalize(value);
        if (this._rawValue.lastPushNotification !== normalized) {
            this._rawValue.lastPushNotification = normalized;
            this._updatedValues.lastPushNotification = normalized;
            this.invalidate();
        }
    }
    get readSeq(): number | null { return this._rawValue.readSeq; }
    set readSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.readSeq.normalize(value);
        if (this._rawValue.readSeq !== normalized) {
            this._rawValue.readSeq = normalized;
            this._updatedValues.readSeq = normalized;
            this.invalidate();
        }
    }
    get lastEmailSeq(): number | null { return this._rawValue.lastEmailSeq; }
    set lastEmailSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastEmailSeq.normalize(value);
        if (this._rawValue.lastEmailSeq !== normalized) {
            this._rawValue.lastEmailSeq = normalized;
            this._updatedValues.lastEmailSeq = normalized;
            this.invalidate();
        }
    }
    get lastPushSeq(): number | null { return this._rawValue.lastPushSeq; }
    set lastPushSeq(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastPushSeq.normalize(value);
        if (this._rawValue.lastPushSeq !== normalized) {
            this._rawValue.lastPushSeq = normalized;
            this._updatedValues.lastPushSeq = normalized;
            this.invalidate();
        }
    }
    get lastEmailCursor(): string | null { return this._rawValue.lastEmailCursor; }
    set lastEmailCursor(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastEmailCursor.normalize(value);
        if (this._rawValue.lastEmailCursor !== normalized) {
            this._rawValue.lastEmailCursor = normalized;
            this._updatedValues.lastEmailCursor = normalized;
            this.invalidate();
        }
    }
    get lastPushCursor(): string | null { return this._rawValue.lastPushCursor; }
    set lastPushCursor(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastPushCursor.normalize(value);
        if (this._rawValue.lastPushCursor !== normalized) {
            this._rawValue.lastPushCursor = normalized;
            this._updatedValues.lastPushCursor = normalized;
            this.invalidate();
        }
    }
}

export class UserNotificationsStateFactory extends EntityFactory<UserNotificationsStateShape, UserNotificationsState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userNotificationsState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastEmailNotification', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastPushNotification', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'readSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastEmailSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastPushSeq', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'lastEmailCursor', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastPushCursor', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            lastEmailNotification: c.optional(c.integer),
            lastPushNotification: c.optional(c.integer),
            readSeq: c.optional(c.integer),
            lastEmailSeq: c.optional(c.integer),
            lastPushSeq: c.optional(c.integer),
            lastEmailCursor: c.optional(c.string),
            lastPushCursor: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserNotificationsStateShape> = {
            name: 'UserNotificationsState',
            storageKey: 'userNotificationsState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserNotificationsStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserNotificationsStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserNotificationsStateCreateShape): Promise<UserNotificationsState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserNotificationsStateCreateShape): UserNotificationsState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserNotificationsState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserNotificationsStateShape>): UserNotificationsState {
        return new UserNotificationsState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedSubscriberShape {
    id: number;
    key: string;
}

export interface FeedSubscriberCreateShape {
    key: string;
}

export class FeedSubscriber extends Entity<FeedSubscriberShape> {
    get id(): number { return this._rawValue.id; }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
}

export class FeedSubscriberFactory extends EntityFactory<FeedSubscriberShape, FeedSubscriber> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedSubscriber');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscriber', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            key: c.string,
        });
        let descriptor: EntityDescriptor<FeedSubscriberShape> = {
            name: 'FeedSubscriber',
            storageKey: 'feedSubscriber',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedSubscriberFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedSubscriberShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, key: string) => {
            return this._findFromUniqueIndex(ctx, [key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: FeedSubscriberCreateShape): Promise<FeedSubscriber> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: FeedSubscriberCreateShape): FeedSubscriber {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedSubscriber | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedSubscriberShape>): FeedSubscriber {
        return new FeedSubscriber([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedSubscriptionShape {
    sid: number;
    tid: number;
    enabled: boolean;
}

export interface FeedSubscriptionCreateShape {
    enabled: boolean;
}

export class FeedSubscription extends Entity<FeedSubscriptionShape> {
    get sid(): number { return this._rawValue.sid; }
    get tid(): number { return this._rawValue.tid; }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class FeedSubscriptionFactory extends EntityFactory<FeedSubscriptionShape, FeedSubscription> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedSubscription');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'subscriber', storageKey: 'subscriber', type: { type: 'range', fields: [{ name: 'sid', type: 'integer' }, { name: 'tid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscription', 'subscriber'), condition: (state) => state.enabled });
        secondaryIndexes.push({ name: 'topic', storageKey: 'topic', type: { type: 'range', fields: [{ name: 'tid', type: 'integer' }, { name: 'sid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedSubscription', 'topic'), condition: (state) => state.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'sid', type: 'integer' });
        primaryKeys.push({ name: 'tid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            sid: c.integer,
            tid: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<FeedSubscriptionShape> = {
            name: 'FeedSubscription',
            storageKey: 'feedSubscription',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedSubscriptionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedSubscriptionShape>) {
        super(descriptor);
    }

    readonly subscriber = Object.freeze({
        findAll: async (ctx: Context, sid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [sid])).items;
        },
        query: (ctx: Context, sid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [sid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (sid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [sid], opts);
        },
        liveStream: (ctx: Context, sid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [sid], opts);
        },
    });

    readonly topic = Object.freeze({
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (tid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [tid], opts);
        },
        liveStream: (ctx: Context, tid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [tid], opts);
        },
    });

    create(ctx: Context, sid: number, tid: number, src: FeedSubscriptionCreateShape): Promise<FeedSubscription> {
        return this._create(ctx, [sid, tid], this.descriptor.codec.normalize({ sid, tid, ...src }));
    }

    create_UNSAFE(ctx: Context, sid: number, tid: number, src: FeedSubscriptionCreateShape): FeedSubscription {
        return this._create_UNSAFE(ctx, [sid, tid], this.descriptor.codec.normalize({ sid, tid, ...src }));
    }

    findById(ctx: Context, sid: number, tid: number): Promise<FeedSubscription | null> {
        return this._findById(ctx, [sid, tid]);
    }

    watch(ctx: Context, sid: number, tid: number): Watch {
        return this._watch(ctx, [sid, tid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedSubscriptionShape>): FeedSubscription {
        return new FeedSubscription([value.sid, value.tid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedTopicShape {
    id: number;
    key: string;
    isGlobal: boolean | null;
}

export interface FeedTopicCreateShape {
    key: string;
    isGlobal?: boolean | null | undefined;
}

export class FeedTopic extends Entity<FeedTopicShape> {
    get id(): number { return this._rawValue.id; }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
    get isGlobal(): boolean | null { return this._rawValue.isGlobal; }
    set isGlobal(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isGlobal.normalize(value);
        if (this._rawValue.isGlobal !== normalized) {
            this._rawValue.isGlobal = normalized;
            this._updatedValues.isGlobal = normalized;
            this.invalidate();
        }
    }
}

export class FeedTopicFactory extends EntityFactory<FeedTopicShape, FeedTopic> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedTopic');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('feedTopic', 'key'), condition: undefined });
        secondaryIndexes.push({ name: 'global', storageKey: 'global', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedTopic', 'global'), condition: src => src.isGlobal });
        secondaryIndexes.push({ name: 'fromGlobal', storageKey: 'fromGlobal', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedTopic', 'fromGlobal'), condition: src => src.isGlobal });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        fields.push({ name: 'isGlobal', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            key: c.string,
            isGlobal: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<FeedTopicShape> = {
            name: 'FeedTopic',
            storageKey: 'feedTopic',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedTopicFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedTopicShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, key: string) => {
            return this._findFromUniqueIndex(ctx, [key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly global = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    readonly fromGlobal = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    create(ctx: Context, id: number, src: FeedTopicCreateShape): Promise<FeedTopic> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: FeedTopicCreateShape): FeedTopic {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedTopic | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedTopicShape>): FeedTopic {
        return new FeedTopic([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedEventShape {
    id: number;
    tid: number;
    repeatKey: string | null;
    type: string;
    content: any;
    edited: boolean | null;
    deleted: boolean | null;
}

export interface FeedEventCreateShape {
    tid: number;
    repeatKey?: string | null | undefined;
    type: string;
    content: any;
    edited?: boolean | null | undefined;
    deleted?: boolean | null | undefined;
}

export class FeedEvent extends Entity<FeedEventShape> {
    get id(): number { return this._rawValue.id; }
    get tid(): number { return this._rawValue.tid; }
    set tid(value: number) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get repeatKey(): string | null { return this._rawValue.repeatKey; }
    set repeatKey(value: string | null) {
        let normalized = this.descriptor.codec.fields.repeatKey.normalize(value);
        if (this._rawValue.repeatKey !== normalized) {
            this._rawValue.repeatKey = normalized;
            this._updatedValues.repeatKey = normalized;
            this.invalidate();
        }
    }
    get type(): string { return this._rawValue.type; }
    set type(value: string) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get content(): any { return this._rawValue.content; }
    set content(value: any) {
        let normalized = this.descriptor.codec.fields.content.normalize(value);
        if (this._rawValue.content !== normalized) {
            this._rawValue.content = normalized;
            this._updatedValues.content = normalized;
            this.invalidate();
        }
    }
    get edited(): boolean | null { return this._rawValue.edited; }
    set edited(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.edited.normalize(value);
        if (this._rawValue.edited !== normalized) {
            this._rawValue.edited = normalized;
            this._updatedValues.edited = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class FeedEventFactory extends EntityFactory<FeedEventShape, FeedEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'topic', storageKey: 'topic', type: { type: 'range', fields: [{ name: 'tid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'topic'), condition: undefined });
        secondaryIndexes.push({ name: 'fromTopic', storageKey: 'fromTopic', type: { type: 'range', fields: [{ name: 'tid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'fromTopic'), condition: src => !src.deleted });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'updated'), condition: undefined });
        secondaryIndexes.push({ name: 'repeat', storageKey: 'repeat', type: { type: 'unique', fields: [{ name: 'tid', type: 'integer' }, { name: 'repeatKey', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('feedEvent', 'repeat'), condition: (src) => !!src.repeatKey });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'tid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'repeatKey', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'type', type: { type: 'string' }, secure: false });
        fields.push({ name: 'content', type: { type: 'json' }, secure: false });
        fields.push({ name: 'edited', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            tid: c.integer,
            repeatKey: c.optional(c.string),
            type: c.string,
            content: c.any,
            edited: c.optional(c.boolean),
            deleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<FeedEventShape> = {
            name: 'FeedEvent',
            storageKey: 'feedEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedEventShape>) {
        super(descriptor);
    }

    readonly topic = Object.freeze({
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (tid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [tid], opts);
        },
        liveStream: (ctx: Context, tid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [tid], opts);
        },
    });

    readonly fromTopic = Object.freeze({
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (tid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [tid], opts);
        },
        liveStream: (ctx: Context, tid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [tid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    readonly repeat = Object.freeze({
        find: async (ctx: Context, tid: number, repeatKey: string | null) => {
            return this._findFromUniqueIndex(ctx, [tid, repeatKey], this.descriptor.secondaryIndexes[3]);
        },
        findAll: async (ctx: Context, tid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [tid])).items;
        },
        query: (ctx: Context, tid: number, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [tid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: FeedEventCreateShape): Promise<FeedEvent> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: FeedEventCreateShape): FeedEvent {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedEvent | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedEventShape>): FeedEvent {
        return new FeedEvent([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedChannelShape {
    id: number;
    ownerId: number;
    title: string;
    about: string | null;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    socialImage: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    type: 'open' | 'editorial' | 'private' | null;
    isGlobal: boolean | null;
    isHidden: boolean | null;
}

export interface FeedChannelCreateShape {
    ownerId: number;
    title: string;
    about?: string | null | undefined;
    image?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    socialImage?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    type?: 'open' | 'editorial' | 'private' | null | undefined;
    isGlobal?: boolean | null | undefined;
    isHidden?: boolean | null | undefined;
}

export class FeedChannel extends Entity<FeedChannelShape> {
    get id(): number { return this._rawValue.id; }
    get ownerId(): number { return this._rawValue.ownerId; }
    set ownerId(value: number) {
        let normalized = this.descriptor.codec.fields.ownerId.normalize(value);
        if (this._rawValue.ownerId !== normalized) {
            this._rawValue.ownerId = normalized;
            this._updatedValues.ownerId = normalized;
            this.invalidate();
        }
    }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get about(): string | null { return this._rawValue.about; }
    set about(value: string | null) {
        let normalized = this.descriptor.codec.fields.about.normalize(value);
        if (this._rawValue.about !== normalized) {
            this._rawValue.about = normalized;
            this._updatedValues.about = normalized;
            this.invalidate();
        }
    }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get socialImage(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.socialImage; }
    set socialImage(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.socialImage.normalize(value);
        if (this._rawValue.socialImage !== normalized) {
            this._rawValue.socialImage = normalized;
            this._updatedValues.socialImage = normalized;
            this.invalidate();
        }
    }
    get type(): 'open' | 'editorial' | 'private' | null { return this._rawValue.type; }
    set type(value: 'open' | 'editorial' | 'private' | null) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get isGlobal(): boolean | null { return this._rawValue.isGlobal; }
    set isGlobal(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isGlobal.normalize(value);
        if (this._rawValue.isGlobal !== normalized) {
            this._rawValue.isGlobal = normalized;
            this._updatedValues.isGlobal = normalized;
            this.invalidate();
        }
    }
    get isHidden(): boolean | null { return this._rawValue.isHidden; }
    set isHidden(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isHidden.normalize(value);
        if (this._rawValue.isHidden !== normalized) {
            this._rawValue.isHidden = normalized;
            this._updatedValues.isHidden = normalized;
            this.invalidate();
        }
    }
}

export class FeedChannelFactory extends EntityFactory<FeedChannelShape, FeedChannel> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedChannel');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'owner', storageKey: 'owner', type: { type: 'range', fields: [{ name: 'ownerId', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannel', 'owner'), condition: src => !src.isHidden });
        secondaryIndexes.push({ name: 'global', storageKey: 'global', type: { type: 'range', fields: [{ name: 'id', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannel', 'global'), condition: src => !!src.isGlobal });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ownerId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'about', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'image', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'socialImage', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'type', type: { type: 'optional', inner: { type: 'enum', values: ['open', 'editorial', 'private'] } }, secure: false });
        fields.push({ name: 'isGlobal', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'isHidden', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ownerId: c.integer,
            title: c.string,
            about: c.optional(c.string),
            image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            socialImage: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            type: c.optional(c.enum('open', 'editorial', 'private')),
            isGlobal: c.optional(c.boolean),
            isHidden: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<FeedChannelShape> = {
            name: 'FeedChannel',
            storageKey: 'feedChannel',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedChannelFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedChannelShape>) {
        super(descriptor);
    }

    readonly owner = Object.freeze({
        findAll: async (ctx: Context, ownerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [ownerId])).items;
        },
        query: (ctx: Context, ownerId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [ownerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (ownerId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [ownerId], opts);
        },
        liveStream: (ctx: Context, ownerId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [ownerId], opts);
        },
    });

    readonly global = Object.freeze({
        findAll: async (ctx: Context, id: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [id])).items;
        },
        query: (ctx: Context, id: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [id], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (id: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [id], opts);
        },
        liveStream: (ctx: Context, id: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [id], opts);
        },
    });

    create(ctx: Context, id: number, src: FeedChannelCreateShape): Promise<FeedChannel> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: FeedChannelCreateShape): FeedChannel {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedChannel | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedChannelShape>): FeedChannel {
        return new FeedChannel([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedChannelAdminShape {
    channelId: number;
    uid: number;
    promoter: number | null;
    role: 'creator' | 'editor';
    enabled: boolean | null;
}

export interface FeedChannelAdminCreateShape {
    promoter?: number | null | undefined;
    role: 'creator' | 'editor';
    enabled?: boolean | null | undefined;
}

export class FeedChannelAdmin extends Entity<FeedChannelAdminShape> {
    get channelId(): number { return this._rawValue.channelId; }
    get uid(): number { return this._rawValue.uid; }
    get promoter(): number | null { return this._rawValue.promoter; }
    set promoter(value: number | null) {
        let normalized = this.descriptor.codec.fields.promoter.normalize(value);
        if (this._rawValue.promoter !== normalized) {
            this._rawValue.promoter = normalized;
            this._updatedValues.promoter = normalized;
            this.invalidate();
        }
    }
    get role(): 'creator' | 'editor' { return this._rawValue.role; }
    set role(value: 'creator' | 'editor') {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class FeedChannelAdminFactory extends EntityFactory<FeedChannelAdminShape, FeedChannelAdmin> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedChannelAdmin');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'channel', storageKey: 'channel', type: { type: 'range', fields: [{ name: 'channelId', type: 'integer' }, { name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannelAdmin', 'channel'), condition: src => !!src.enabled });
        secondaryIndexes.push({ name: 'fromUser', storageKey: 'fromUser', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'channelId', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannelAdmin', 'fromUser'), condition: src => !!src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'channelId', type: 'integer' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'promoter', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'enum', values: ['creator', 'editor'] }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            channelId: c.integer,
            uid: c.integer,
            promoter: c.optional(c.integer),
            role: c.enum('creator', 'editor'),
            enabled: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<FeedChannelAdminShape> = {
            name: 'FeedChannelAdmin',
            storageKey: 'feedChannelAdmin',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedChannelAdminFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedChannelAdminShape>) {
        super(descriptor);
    }

    readonly channel = Object.freeze({
        findAll: async (ctx: Context, channelId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [channelId])).items;
        },
        query: (ctx: Context, channelId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [channelId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (channelId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [channelId], opts);
        },
        liveStream: (ctx: Context, channelId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [channelId], opts);
        },
    });

    readonly fromUser = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, channelId: number, uid: number, src: FeedChannelAdminCreateShape): Promise<FeedChannelAdmin> {
        return this._create(ctx, [channelId, uid], this.descriptor.codec.normalize({ channelId, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, channelId: number, uid: number, src: FeedChannelAdminCreateShape): FeedChannelAdmin {
        return this._create_UNSAFE(ctx, [channelId, uid], this.descriptor.codec.normalize({ channelId, uid, ...src }));
    }

    findById(ctx: Context, channelId: number, uid: number): Promise<FeedChannelAdmin | null> {
        return this._findById(ctx, [channelId, uid]);
    }

    watch(ctx: Context, channelId: number, uid: number): Watch {
        return this._watch(ctx, [channelId, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedChannelAdminShape>): FeedChannelAdmin {
        return new FeedChannelAdmin([value.channelId, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedChannelIndexingQueueShape {
    id: number;
}

export interface FeedChannelIndexingQueueCreateShape {
}

export class FeedChannelIndexingQueue extends Entity<FeedChannelIndexingQueueShape> {
    get id(): number { return this._rawValue.id; }
}

export class FeedChannelIndexingQueueFactory extends EntityFactory<FeedChannelIndexingQueueShape, FeedChannelIndexingQueue> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedChannelIndexingQueue');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannelIndexingQueue', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        let codec = c.struct({
            id: c.integer,
        });
        let descriptor: EntityDescriptor<FeedChannelIndexingQueueShape> = {
            name: 'FeedChannelIndexingQueue',
            storageKey: 'feedChannelIndexingQueue',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedChannelIndexingQueueFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedChannelIndexingQueueShape>) {
        super(descriptor);
    }

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: FeedChannelIndexingQueueCreateShape): Promise<FeedChannelIndexingQueue> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: FeedChannelIndexingQueueCreateShape): FeedChannelIndexingQueue {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<FeedChannelIndexingQueue | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedChannelIndexingQueueShape>): FeedChannelIndexingQueue {
        return new FeedChannelIndexingQueue([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserFeedStateShape {
    uid: number;
    draftsChannelId: number | null;
}

export interface UserFeedStateCreateShape {
    draftsChannelId?: number | null | undefined;
}

export class UserFeedState extends Entity<UserFeedStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get draftsChannelId(): number | null { return this._rawValue.draftsChannelId; }
    set draftsChannelId(value: number | null) {
        let normalized = this.descriptor.codec.fields.draftsChannelId.normalize(value);
        if (this._rawValue.draftsChannelId !== normalized) {
            this._rawValue.draftsChannelId = normalized;
            this._updatedValues.draftsChannelId = normalized;
            this.invalidate();
        }
    }
}

export class UserFeedStateFactory extends EntityFactory<UserFeedStateShape, UserFeedState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userFeedState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'draftsChannelId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            draftsChannelId: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<UserFeedStateShape> = {
            name: 'UserFeedState',
            storageKey: 'userFeedState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserFeedStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserFeedStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserFeedStateCreateShape): Promise<UserFeedState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserFeedStateCreateShape): UserFeedState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserFeedState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserFeedStateShape>): UserFeedState {
        return new UserFeedState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeedChannelAutoSubscriptionShape {
    channelId: number;
    peerType: string;
    peerId: number;
    uid: number;
    enabled: boolean;
}

export interface FeedChannelAutoSubscriptionCreateShape {
    uid: number;
    enabled: boolean;
}

export class FeedChannelAutoSubscription extends Entity<FeedChannelAutoSubscriptionShape> {
    get channelId(): number { return this._rawValue.channelId; }
    get peerType(): string { return this._rawValue.peerType; }
    get peerId(): number { return this._rawValue.peerId; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class FeedChannelAutoSubscriptionFactory extends EntityFactory<FeedChannelAutoSubscriptionShape, FeedChannelAutoSubscription> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('feedChannelAutoSubscription');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromPeer', storageKey: 'fromPeer', type: { type: 'range', fields: [{ name: 'peerType', type: 'string' }, { name: 'peerId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannelAutoSubscription', 'fromPeer'), condition: src => src.enabled });
        secondaryIndexes.push({ name: 'fromChannel', storageKey: 'fromChannel', type: { type: 'range', fields: [{ name: 'channelId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('feedChannelAutoSubscription', 'fromChannel'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'channelId', type: 'integer' });
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            channelId: c.integer,
            peerType: c.string,
            peerId: c.integer,
            uid: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<FeedChannelAutoSubscriptionShape> = {
            name: 'FeedChannelAutoSubscription',
            storageKey: 'feedChannelAutoSubscription',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeedChannelAutoSubscriptionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeedChannelAutoSubscriptionShape>) {
        super(descriptor);
    }

    readonly fromPeer = Object.freeze({
        findAll: async (ctx: Context, peerType: string, peerId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId])).items;
        },
        query: (ctx: Context, peerType: string, peerId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
        liveStream: (ctx: Context, peerType: string, peerId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [peerType, peerId], opts);
        },
    });

    readonly fromChannel = Object.freeze({
        findAll: async (ctx: Context, channelId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [channelId])).items;
        },
        query: (ctx: Context, channelId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [channelId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (channelId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [channelId], opts);
        },
        liveStream: (ctx: Context, channelId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [channelId], opts);
        },
    });

    create(ctx: Context, channelId: number, peerType: string, peerId: number, src: FeedChannelAutoSubscriptionCreateShape): Promise<FeedChannelAutoSubscription> {
        return this._create(ctx, [channelId, peerType, peerId], this.descriptor.codec.normalize({ channelId, peerType, peerId, ...src }));
    }

    create_UNSAFE(ctx: Context, channelId: number, peerType: string, peerId: number, src: FeedChannelAutoSubscriptionCreateShape): FeedChannelAutoSubscription {
        return this._create_UNSAFE(ctx, [channelId, peerType, peerId], this.descriptor.codec.normalize({ channelId, peerType, peerId, ...src }));
    }

    findById(ctx: Context, channelId: number, peerType: string, peerId: number): Promise<FeedChannelAutoSubscription | null> {
        return this._findById(ctx, [channelId, peerType, peerId]);
    }

    watch(ctx: Context, channelId: number, peerType: string, peerId: number): Watch {
        return this._watch(ctx, [channelId, peerType, peerId]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeedChannelAutoSubscriptionShape>): FeedChannelAutoSubscription {
        return new FeedChannelAutoSubscription([value.channelId, value.peerType, value.peerId], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ChatAudienceCalculatingQueueShape {
    id: number;
    active: boolean;
    delta: number;
}

export interface ChatAudienceCalculatingQueueCreateShape {
    active: boolean;
    delta: number;
}

export class ChatAudienceCalculatingQueue extends Entity<ChatAudienceCalculatingQueueShape> {
    get id(): number { return this._rawValue.id; }
    get active(): boolean { return this._rawValue.active; }
    set active(value: boolean) {
        let normalized = this.descriptor.codec.fields.active.normalize(value);
        if (this._rawValue.active !== normalized) {
            this._rawValue.active = normalized;
            this._updatedValues.active = normalized;
            this.invalidate();
        }
    }
    get delta(): number { return this._rawValue.delta; }
    set delta(value: number) {
        let normalized = this.descriptor.codec.fields.delta.normalize(value);
        if (this._rawValue.delta !== normalized) {
            this._rawValue.delta = normalized;
            this._updatedValues.delta = normalized;
            this.invalidate();
        }
    }
}

export class ChatAudienceCalculatingQueueFactory extends EntityFactory<ChatAudienceCalculatingQueueShape, ChatAudienceCalculatingQueue> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('chatAudienceCalculatingQueue');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('chatAudienceCalculatingQueue', 'active'), condition: (src) => !!src.active });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'active', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'delta', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            active: c.boolean,
            delta: c.integer,
        });
        let descriptor: EntityDescriptor<ChatAudienceCalculatingQueueShape> = {
            name: 'ChatAudienceCalculatingQueue',
            storageKey: 'chatAudienceCalculatingQueue',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ChatAudienceCalculatingQueueFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ChatAudienceCalculatingQueueShape>) {
        super(descriptor);
    }

    readonly active = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: ChatAudienceCalculatingQueueCreateShape): Promise<ChatAudienceCalculatingQueue> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: ChatAudienceCalculatingQueueCreateShape): ChatAudienceCalculatingQueue {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<ChatAudienceCalculatingQueue | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ChatAudienceCalculatingQueueShape>): ChatAudienceCalculatingQueue {
        return new ChatAudienceCalculatingQueue([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ChannelLinkShape {
    id: string;
    creatorId: number;
    channelId: number;
    enabled: boolean;
}

export interface ChannelLinkCreateShape {
    creatorId: number;
    channelId: number;
    enabled: boolean;
}

export class ChannelLink extends Entity<ChannelLinkShape> {
    get id(): string { return this._rawValue.id; }
    get creatorId(): number { return this._rawValue.creatorId; }
    set creatorId(value: number) {
        let normalized = this.descriptor.codec.fields.creatorId.normalize(value);
        if (this._rawValue.creatorId !== normalized) {
            this._rawValue.creatorId = normalized;
            this._updatedValues.creatorId = normalized;
            this.invalidate();
        }
    }
    get channelId(): number { return this._rawValue.channelId; }
    set channelId(value: number) {
        let normalized = this.descriptor.codec.fields.channelId.normalize(value);
        if (this._rawValue.channelId !== normalized) {
            this._rawValue.channelId = normalized;
            this._updatedValues.channelId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class ChannelLinkFactory extends EntityFactory<ChannelLinkShape, ChannelLink> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('channelLink');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'channel', storageKey: 'channel', type: { type: 'range', fields: [{ name: 'channelId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('channelLink', 'channel'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'creatorId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'channelId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            creatorId: c.integer,
            channelId: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<ChannelLinkShape> = {
            name: 'ChannelLink',
            storageKey: 'channelLink',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ChannelLinkFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ChannelLinkShape>) {
        super(descriptor);
    }

    readonly channel = Object.freeze({
        findAll: async (ctx: Context, channelId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [channelId])).items;
        },
        query: (ctx: Context, channelId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [channelId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (channelId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [channelId], opts);
        },
        liveStream: (ctx: Context, channelId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [channelId], opts);
        },
    });

    create(ctx: Context, id: string, src: ChannelLinkCreateShape): Promise<ChannelLink> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ChannelLinkCreateShape): ChannelLink {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ChannelLink | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ChannelLinkShape>): ChannelLink {
        return new ChannelLink([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface AppInviteLinkShape {
    id: string;
    uid: number;
}

export interface AppInviteLinkCreateShape {
    uid: number;
}

export class AppInviteLink extends Entity<AppInviteLinkShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
}

export class AppInviteLinkFactory extends EntityFactory<AppInviteLinkShape, AppInviteLink> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('appInviteLink');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('appInviteLink', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
        });
        let descriptor: EntityDescriptor<AppInviteLinkShape> = {
            name: 'AppInviteLink',
            storageKey: 'appInviteLink',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AppInviteLinkFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AppInviteLinkShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        find: async (ctx: Context, uid: number) => {
            return this._findFromUniqueIndex(ctx, [uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: AppInviteLinkCreateShape): Promise<AppInviteLink> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: AppInviteLinkCreateShape): AppInviteLink {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<AppInviteLink | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AppInviteLinkShape>): AppInviteLink {
        return new AppInviteLink([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationPublicInviteLinkShape {
    id: string;
    uid: number;
    oid: number;
    enabled: boolean;
}

export interface OrganizationPublicInviteLinkCreateShape {
    uid: number;
    oid: number;
    enabled: boolean;
}

export class OrganizationPublicInviteLink extends Entity<OrganizationPublicInviteLinkShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get oid(): number { return this._rawValue.oid; }
    set oid(value: number) {
        let normalized = this.descriptor.codec.fields.oid.normalize(value);
        if (this._rawValue.oid !== normalized) {
            this._rawValue.oid = normalized;
            this._updatedValues.oid = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationPublicInviteLinkFactory extends EntityFactory<OrganizationPublicInviteLinkShape, OrganizationPublicInviteLink> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationPublicInviteLink');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'userInOrganization', storageKey: 'userInOrganization', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'oid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationPublicInviteLink', 'userInOrganization'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'oid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            oid: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<OrganizationPublicInviteLinkShape> = {
            name: 'OrganizationPublicInviteLink',
            storageKey: 'organizationPublicInviteLink',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationPublicInviteLinkFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationPublicInviteLinkShape>) {
        super(descriptor);
    }

    readonly userInOrganization = Object.freeze({
        find: async (ctx: Context, uid: number, oid: number) => {
            return this._findFromUniqueIndex(ctx, [uid, oid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: OrganizationPublicInviteLinkCreateShape): Promise<OrganizationPublicInviteLink> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: OrganizationPublicInviteLinkCreateShape): OrganizationPublicInviteLink {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<OrganizationPublicInviteLink | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationPublicInviteLinkShape>): OrganizationPublicInviteLink {
        return new OrganizationPublicInviteLink([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationInviteLinkShape {
    id: string;
    oid: number;
    email: string;
    uid: number;
    firstName: string | null;
    lastName: string | null;
    text: string | null;
    ttl: number | null;
    enabled: boolean | null;
    joined: boolean | null;
    role: 'MEMBER' | 'OWNER';
}

export interface OrganizationInviteLinkCreateShape {
    oid: number;
    email: string;
    uid: number;
    firstName?: string | null | undefined;
    lastName?: string | null | undefined;
    text?: string | null | undefined;
    ttl?: number | null | undefined;
    enabled?: boolean | null | undefined;
    joined?: boolean | null | undefined;
    role: 'MEMBER' | 'OWNER';
}

export class OrganizationInviteLink extends Entity<OrganizationInviteLinkShape> {
    get id(): string { return this._rawValue.id; }
    get oid(): number { return this._rawValue.oid; }
    set oid(value: number) {
        let normalized = this.descriptor.codec.fields.oid.normalize(value);
        if (this._rawValue.oid !== normalized) {
            this._rawValue.oid = normalized;
            this._updatedValues.oid = normalized;
            this.invalidate();
        }
    }
    get email(): string { return this._rawValue.email; }
    set email(value: string) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get firstName(): string | null { return this._rawValue.firstName; }
    set firstName(value: string | null) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get ttl(): number | null { return this._rawValue.ttl; }
    set ttl(value: number | null) {
        let normalized = this.descriptor.codec.fields.ttl.normalize(value);
        if (this._rawValue.ttl !== normalized) {
            this._rawValue.ttl = normalized;
            this._updatedValues.ttl = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get joined(): boolean | null { return this._rawValue.joined; }
    set joined(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.joined.normalize(value);
        if (this._rawValue.joined !== normalized) {
            this._rawValue.joined = normalized;
            this._updatedValues.joined = normalized;
            this.invalidate();
        }
    }
    get role(): 'MEMBER' | 'OWNER' { return this._rawValue.role; }
    set role(value: 'MEMBER' | 'OWNER') {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationInviteLinkFactory extends EntityFactory<OrganizationInviteLinkShape, OrganizationInviteLink> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationInviteLink');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'unique', fields: [{ name: 'oid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationInviteLink', 'organization'), condition: src => src.enabled });
        secondaryIndexes.push({ name: 'emailInOrganization', storageKey: 'emailInOrganization', type: { type: 'unique', fields: [{ name: 'email', type: 'string' }, { name: 'oid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationInviteLink', 'emailInOrganization'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'oid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'email', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'firstName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'ttl', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'joined', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'role', type: { type: 'enum', values: ['MEMBER', 'OWNER'] }, secure: false });
        let codec = c.struct({
            id: c.string,
            oid: c.integer,
            email: c.string,
            uid: c.integer,
            firstName: c.optional(c.string),
            lastName: c.optional(c.string),
            text: c.optional(c.string),
            ttl: c.optional(c.integer),
            enabled: c.optional(c.boolean),
            joined: c.optional(c.boolean),
            role: c.enum('MEMBER', 'OWNER'),
        });
        let descriptor: EntityDescriptor<OrganizationInviteLinkShape> = {
            name: 'OrganizationInviteLink',
            storageKey: 'organizationInviteLink',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationInviteLinkFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationInviteLinkShape>) {
        super(descriptor);
    }

    readonly organization = Object.freeze({
        find: async (ctx: Context, oid: number, id: string) => {
            return this._findFromUniqueIndex(ctx, [oid, id], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, oid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [oid])).items;
        },
        query: (ctx: Context, oid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [oid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly emailInOrganization = Object.freeze({
        find: async (ctx: Context, email: string, oid: number) => {
            return this._findFromUniqueIndex(ctx, [email, oid], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context, email: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [email])).items;
        },
        query: (ctx: Context, email: string, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [email], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: OrganizationInviteLinkCreateShape): Promise<OrganizationInviteLink> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: OrganizationInviteLinkCreateShape): OrganizationInviteLink {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<OrganizationInviteLink | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationInviteLinkShape>): OrganizationInviteLink {
        return new OrganizationInviteLink([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ChannelInvitationShape {
    id: string;
    creatorId: number;
    channelId: number;
    email: string;
    firstName: string | null;
    lastName: string | null;
    text: string | null;
    acceptedById: number | null;
    enabled: boolean | null;
}

export interface ChannelInvitationCreateShape {
    creatorId: number;
    channelId: number;
    email: string;
    firstName?: string | null | undefined;
    lastName?: string | null | undefined;
    text?: string | null | undefined;
    acceptedById?: number | null | undefined;
    enabled?: boolean | null | undefined;
}

export class ChannelInvitation extends Entity<ChannelInvitationShape> {
    get id(): string { return this._rawValue.id; }
    get creatorId(): number { return this._rawValue.creatorId; }
    set creatorId(value: number) {
        let normalized = this.descriptor.codec.fields.creatorId.normalize(value);
        if (this._rawValue.creatorId !== normalized) {
            this._rawValue.creatorId = normalized;
            this._updatedValues.creatorId = normalized;
            this.invalidate();
        }
    }
    get channelId(): number { return this._rawValue.channelId; }
    set channelId(value: number) {
        let normalized = this.descriptor.codec.fields.channelId.normalize(value);
        if (this._rawValue.channelId !== normalized) {
            this._rawValue.channelId = normalized;
            this._updatedValues.channelId = normalized;
            this.invalidate();
        }
    }
    get email(): string { return this._rawValue.email; }
    set email(value: string) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get firstName(): string | null { return this._rawValue.firstName; }
    set firstName(value: string | null) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get text(): string | null { return this._rawValue.text; }
    set text(value: string | null) {
        let normalized = this.descriptor.codec.fields.text.normalize(value);
        if (this._rawValue.text !== normalized) {
            this._rawValue.text = normalized;
            this._updatedValues.text = normalized;
            this.invalidate();
        }
    }
    get acceptedById(): number | null { return this._rawValue.acceptedById; }
    set acceptedById(value: number | null) {
        let normalized = this.descriptor.codec.fields.acceptedById.normalize(value);
        if (this._rawValue.acceptedById !== normalized) {
            this._rawValue.acceptedById = normalized;
            this._updatedValues.acceptedById = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class ChannelInvitationFactory extends EntityFactory<ChannelInvitationShape, ChannelInvitation> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('channelInvitation');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'channel', storageKey: 'channel', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }, { name: 'channelId', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('channelInvitation', 'channel'), condition: undefined });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('channelInvitation', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'creatorId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'channelId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'email', type: { type: 'string' }, secure: false });
        fields.push({ name: 'firstName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'text', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'acceptedById', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            creatorId: c.integer,
            channelId: c.integer,
            email: c.string,
            firstName: c.optional(c.string),
            lastName: c.optional(c.string),
            text: c.optional(c.string),
            acceptedById: c.optional(c.integer),
            enabled: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<ChannelInvitationShape> = {
            name: 'ChannelInvitation',
            storageKey: 'channelInvitation',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ChannelInvitationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ChannelInvitationShape>) {
        super(descriptor);
    }

    readonly channel = Object.freeze({
        findAll: async (ctx: Context, createdAt: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [createdAt])).items;
        },
        query: (ctx: Context, createdAt: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [createdAt], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (createdAt: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [createdAt], opts);
        },
        liveStream: (ctx: Context, createdAt: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [createdAt], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: string, src: ChannelInvitationCreateShape): Promise<ChannelInvitation> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ChannelInvitationCreateShape): ChannelInvitation {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ChannelInvitation | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ChannelInvitationShape>): ChannelInvitation {
        return new ChannelInvitation([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DiscoverUserPickedTagsShape {
    uid: number;
    id: string;
    deleted: boolean;
}

export interface DiscoverUserPickedTagsCreateShape {
    deleted: boolean;
}

export class DiscoverUserPickedTags extends Entity<DiscoverUserPickedTagsShape> {
    get uid(): number { return this._rawValue.uid; }
    get id(): string { return this._rawValue.id; }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class DiscoverUserPickedTagsFactory extends EntityFactory<DiscoverUserPickedTagsShape, DiscoverUserPickedTags> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('discoverUserPickedTags');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('discoverUserPickedTags', 'user'), condition: (src) => !src.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            id: c.string,
            deleted: c.boolean,
        });
        let descriptor: EntityDescriptor<DiscoverUserPickedTagsShape> = {
            name: 'DiscoverUserPickedTags',
            storageKey: 'discoverUserPickedTags',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DiscoverUserPickedTagsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DiscoverUserPickedTagsShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        find: async (ctx: Context, uid: number, id: string) => {
            return this._findFromUniqueIndex(ctx, [uid, id], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, uid: number, id: string, src: DiscoverUserPickedTagsCreateShape): Promise<DiscoverUserPickedTags> {
        return this._create(ctx, [uid, id], this.descriptor.codec.normalize({ uid, id, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, id: string, src: DiscoverUserPickedTagsCreateShape): DiscoverUserPickedTags {
        return this._create_UNSAFE(ctx, [uid, id], this.descriptor.codec.normalize({ uid, id, ...src }));
    }

    findById(ctx: Context, uid: number, id: string): Promise<DiscoverUserPickedTags | null> {
        return this._findById(ctx, [uid, id]);
    }

    watch(ctx: Context, uid: number, id: string): Watch {
        return this._watch(ctx, [uid, id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DiscoverUserPickedTagsShape>): DiscoverUserPickedTags {
        return new DiscoverUserPickedTags([value.uid, value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DiscoverStateShape {
    uid: number;
    skipped: boolean;
}

export interface DiscoverStateCreateShape {
    skipped: boolean;
}

export class DiscoverState extends Entity<DiscoverStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get skipped(): boolean { return this._rawValue.skipped; }
    set skipped(value: boolean) {
        let normalized = this.descriptor.codec.fields.skipped.normalize(value);
        if (this._rawValue.skipped !== normalized) {
            this._rawValue.skipped = normalized;
            this._updatedValues.skipped = normalized;
            this.invalidate();
        }
    }
}

export class DiscoverStateFactory extends EntityFactory<DiscoverStateShape, DiscoverState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('discoverState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'skipped', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            skipped: c.boolean,
        });
        let descriptor: EntityDescriptor<DiscoverStateShape> = {
            name: 'DiscoverState',
            storageKey: 'discoverState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DiscoverStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DiscoverStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: DiscoverStateCreateShape): Promise<DiscoverState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: DiscoverStateCreateShape): DiscoverState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<DiscoverState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DiscoverStateShape>): DiscoverState {
        return new DiscoverState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserOnboardingStateShape {
    uid: number;
    wellcomeSent: boolean | null;
    askCompleteDeiscoverSent: boolean | null;
    askInviteSent: boolean | null;
    askInstallAppsSent: boolean | null;
    askSendFirstMessageSent: boolean | null;
}

export interface UserOnboardingStateCreateShape {
    wellcomeSent?: boolean | null | undefined;
    askCompleteDeiscoverSent?: boolean | null | undefined;
    askInviteSent?: boolean | null | undefined;
    askInstallAppsSent?: boolean | null | undefined;
    askSendFirstMessageSent?: boolean | null | undefined;
}

export class UserOnboardingState extends Entity<UserOnboardingStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get wellcomeSent(): boolean | null { return this._rawValue.wellcomeSent; }
    set wellcomeSent(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.wellcomeSent.normalize(value);
        if (this._rawValue.wellcomeSent !== normalized) {
            this._rawValue.wellcomeSent = normalized;
            this._updatedValues.wellcomeSent = normalized;
            this.invalidate();
        }
    }
    get askCompleteDeiscoverSent(): boolean | null { return this._rawValue.askCompleteDeiscoverSent; }
    set askCompleteDeiscoverSent(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.askCompleteDeiscoverSent.normalize(value);
        if (this._rawValue.askCompleteDeiscoverSent !== normalized) {
            this._rawValue.askCompleteDeiscoverSent = normalized;
            this._updatedValues.askCompleteDeiscoverSent = normalized;
            this.invalidate();
        }
    }
    get askInviteSent(): boolean | null { return this._rawValue.askInviteSent; }
    set askInviteSent(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.askInviteSent.normalize(value);
        if (this._rawValue.askInviteSent !== normalized) {
            this._rawValue.askInviteSent = normalized;
            this._updatedValues.askInviteSent = normalized;
            this.invalidate();
        }
    }
    get askInstallAppsSent(): boolean | null { return this._rawValue.askInstallAppsSent; }
    set askInstallAppsSent(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.askInstallAppsSent.normalize(value);
        if (this._rawValue.askInstallAppsSent !== normalized) {
            this._rawValue.askInstallAppsSent = normalized;
            this._updatedValues.askInstallAppsSent = normalized;
            this.invalidate();
        }
    }
    get askSendFirstMessageSent(): boolean | null { return this._rawValue.askSendFirstMessageSent; }
    set askSendFirstMessageSent(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.askSendFirstMessageSent.normalize(value);
        if (this._rawValue.askSendFirstMessageSent !== normalized) {
            this._rawValue.askSendFirstMessageSent = normalized;
            this._updatedValues.askSendFirstMessageSent = normalized;
            this.invalidate();
        }
    }
}

export class UserOnboardingStateFactory extends EntityFactory<UserOnboardingStateShape, UserOnboardingState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userOnboardingState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'wellcomeSent', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'askCompleteDeiscoverSent', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'askInviteSent', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'askInstallAppsSent', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'askSendFirstMessageSent', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            wellcomeSent: c.optional(c.boolean),
            askCompleteDeiscoverSent: c.optional(c.boolean),
            askInviteSent: c.optional(c.boolean),
            askInstallAppsSent: c.optional(c.boolean),
            askSendFirstMessageSent: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<UserOnboardingStateShape> = {
            name: 'UserOnboardingState',
            storageKey: 'userOnboardingState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserOnboardingStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserOnboardingStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserOnboardingStateCreateShape): Promise<UserOnboardingState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserOnboardingStateCreateShape): UserOnboardingState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserOnboardingState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserOnboardingStateShape>): UserOnboardingState {
        return new UserOnboardingState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PushFirebaseShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushFirebaseCreateShape {
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number | null | undefined;
    failedFirstAt?: number | null | undefined;
    failedLastAt?: number | null | undefined;
    disabledAt?: number | null | undefined;
}

export class PushFirebase extends Entity<PushFirebaseShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get packageId(): string { return this._rawValue.packageId; }
    set packageId(value: string) {
        let normalized = this.descriptor.codec.fields.packageId.normalize(value);
        if (this._rawValue.packageId !== normalized) {
            this._rawValue.packageId = normalized;
            this._updatedValues.packageId = normalized;
            this.invalidate();
        }
    }
    get sandbox(): boolean { return this._rawValue.sandbox; }
    set sandbox(value: boolean) {
        let normalized = this.descriptor.codec.fields.sandbox.normalize(value);
        if (this._rawValue.sandbox !== normalized) {
            this._rawValue.sandbox = normalized;
            this._updatedValues.sandbox = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushFirebaseFactory extends EntityFactory<PushFirebaseShape, PushFirebase> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushFirebase');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushFirebase', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushFirebase', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'packageId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'sandbox', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            packageId: c.string,
            sandbox: c.boolean,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushFirebaseShape> = {
            name: 'PushFirebase',
            storageKey: 'pushFirebase',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushFirebaseFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushFirebaseShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: PushFirebaseCreateShape): Promise<PushFirebase> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PushFirebaseCreateShape): PushFirebase {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushFirebase | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushFirebaseShape>): PushFirebase {
        return new PushFirebase([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PushAppleShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushAppleCreateShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number | null | undefined;
    failedFirstAt?: number | null | undefined;
    failedLastAt?: number | null | undefined;
    disabledAt?: number | null | undefined;
}

export class PushApple extends Entity<PushAppleShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get bundleId(): string { return this._rawValue.bundleId; }
    set bundleId(value: string) {
        let normalized = this.descriptor.codec.fields.bundleId.normalize(value);
        if (this._rawValue.bundleId !== normalized) {
            this._rawValue.bundleId = normalized;
            this._updatedValues.bundleId = normalized;
            this.invalidate();
        }
    }
    get sandbox(): boolean { return this._rawValue.sandbox; }
    set sandbox(value: boolean) {
        let normalized = this.descriptor.codec.fields.sandbox.normalize(value);
        if (this._rawValue.sandbox !== normalized) {
            this._rawValue.sandbox = normalized;
            this._updatedValues.sandbox = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushAppleFactory extends EntityFactory<PushAppleShape, PushApple> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushApple');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushApple', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushApple', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'bundleId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'sandbox', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            bundleId: c.string,
            sandbox: c.boolean,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushAppleShape> = {
            name: 'PushApple',
            storageKey: 'pushApple',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushAppleFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushAppleShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: PushAppleCreateShape): Promise<PushApple> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PushAppleCreateShape): PushApple {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushApple | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushAppleShape>): PushApple {
        return new PushApple([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PushSafariShape {
    id: string;
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushSafariCreateShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    enabled: boolean;
    failures?: number | null | undefined;
    failedFirstAt?: number | null | undefined;
    failedLastAt?: number | null | undefined;
    disabledAt?: number | null | undefined;
}

export class PushSafari extends Entity<PushSafariShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get token(): string { return this._rawValue.token; }
    set token(value: string) {
        let normalized = this.descriptor.codec.fields.token.normalize(value);
        if (this._rawValue.token !== normalized) {
            this._rawValue.token = normalized;
            this._updatedValues.token = normalized;
            this.invalidate();
        }
    }
    get bundleId(): string { return this._rawValue.bundleId; }
    set bundleId(value: string) {
        let normalized = this.descriptor.codec.fields.bundleId.normalize(value);
        if (this._rawValue.bundleId !== normalized) {
            this._rawValue.bundleId = normalized;
            this._updatedValues.bundleId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushSafariFactory extends EntityFactory<PushSafariShape, PushSafari> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushSafari');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushSafari', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'token', storageKey: 'token', type: { type: 'unique', fields: [{ name: 'token', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushSafari', 'token'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'token', type: { type: 'string' }, secure: true });
        fields.push({ name: 'bundleId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            token: c.string,
            bundleId: c.string,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushSafariShape> = {
            name: 'PushSafari',
            storageKey: 'pushSafari',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushSafariFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushSafariShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly token = Object.freeze({
        find: async (ctx: Context, token: string) => {
            return this._findFromUniqueIndex(ctx, [token], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: PushSafariCreateShape): Promise<PushSafari> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PushSafariCreateShape): PushSafari {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushSafari | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushSafariShape>): PushSafari {
        return new PushSafari([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PushWebShape {
    id: string;
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures: number | null;
    failedFirstAt: number | null;
    failedLastAt: number | null;
    disabledAt: number | null;
}

export interface PushWebCreateShape {
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures?: number | null | undefined;
    failedFirstAt?: number | null | undefined;
    failedLastAt?: number | null | undefined;
    disabledAt?: number | null | undefined;
}

export class PushWeb extends Entity<PushWebShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get tid(): string { return this._rawValue.tid; }
    set tid(value: string) {
        let normalized = this.descriptor.codec.fields.tid.normalize(value);
        if (this._rawValue.tid !== normalized) {
            this._rawValue.tid = normalized;
            this._updatedValues.tid = normalized;
            this.invalidate();
        }
    }
    get endpoint(): string { return this._rawValue.endpoint; }
    set endpoint(value: string) {
        let normalized = this.descriptor.codec.fields.endpoint.normalize(value);
        if (this._rawValue.endpoint !== normalized) {
            this._rawValue.endpoint = normalized;
            this._updatedValues.endpoint = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get failures(): number | null { return this._rawValue.failures; }
    set failures(value: number | null) {
        let normalized = this.descriptor.codec.fields.failures.normalize(value);
        if (this._rawValue.failures !== normalized) {
            this._rawValue.failures = normalized;
            this._updatedValues.failures = normalized;
            this.invalidate();
        }
    }
    get failedFirstAt(): number | null { return this._rawValue.failedFirstAt; }
    set failedFirstAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedFirstAt.normalize(value);
        if (this._rawValue.failedFirstAt !== normalized) {
            this._rawValue.failedFirstAt = normalized;
            this._updatedValues.failedFirstAt = normalized;
            this.invalidate();
        }
    }
    get failedLastAt(): number | null { return this._rawValue.failedLastAt; }
    set failedLastAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.failedLastAt.normalize(value);
        if (this._rawValue.failedLastAt !== normalized) {
            this._rawValue.failedLastAt = normalized;
            this._updatedValues.failedLastAt = normalized;
            this.invalidate();
        }
    }
    get disabledAt(): number | null { return this._rawValue.disabledAt; }
    set disabledAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.disabledAt.normalize(value);
        if (this._rawValue.disabledAt !== normalized) {
            this._rawValue.disabledAt = normalized;
            this._updatedValues.disabledAt = normalized;
            this.invalidate();
        }
    }
}

export class PushWebFactory extends EntityFactory<PushWebShape, PushWeb> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('pushWeb');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushWeb', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'endpoint', storageKey: 'endpoint', type: { type: 'unique', fields: [{ name: 'endpoint', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('pushWeb', 'endpoint'), condition: src => src.enabled });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'tid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'endpoint', type: { type: 'string' }, secure: true });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'failures', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedFirstAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'failedLastAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'disabledAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            tid: c.string,
            endpoint: c.string,
            enabled: c.boolean,
            failures: c.optional(c.integer),
            failedFirstAt: c.optional(c.integer),
            failedLastAt: c.optional(c.integer),
            disabledAt: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<PushWebShape> = {
            name: 'PushWeb',
            storageKey: 'pushWeb',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PushWebFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PushWebShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly endpoint = Object.freeze({
        find: async (ctx: Context, endpoint: string) => {
            return this._findFromUniqueIndex(ctx, [endpoint], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: PushWebCreateShape): Promise<PushWeb> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PushWebCreateShape): PushWeb {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PushWeb | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PushWebShape>): PushWeb {
        return new PushWeb([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface AppHookShape {
    appId: number;
    chatId: number;
    key: string;
}

export interface AppHookCreateShape {
    key: string;
}

export class AppHook extends Entity<AppHookShape> {
    get appId(): number { return this._rawValue.appId; }
    get chatId(): number { return this._rawValue.chatId; }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
}

export class AppHookFactory extends EntityFactory<AppHookShape, AppHook> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('appHook');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('appHook', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'appId', type: 'integer' });
        primaryKeys.push({ name: 'chatId', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            appId: c.integer,
            chatId: c.integer,
            key: c.string,
        });
        let descriptor: EntityDescriptor<AppHookShape> = {
            name: 'AppHook',
            storageKey: 'appHook',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AppHookFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AppHookShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, key: string) => {
            return this._findFromUniqueIndex(ctx, [key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, appId: number, chatId: number, src: AppHookCreateShape): Promise<AppHook> {
        return this._create(ctx, [appId, chatId], this.descriptor.codec.normalize({ appId, chatId, ...src }));
    }

    create_UNSAFE(ctx: Context, appId: number, chatId: number, src: AppHookCreateShape): AppHook {
        return this._create_UNSAFE(ctx, [appId, chatId], this.descriptor.codec.normalize({ appId, chatId, ...src }));
    }

    findById(ctx: Context, appId: number, chatId: number): Promise<AppHook | null> {
        return this._findById(ctx, [appId, chatId]);
    }

    watch(ctx: Context, appId: number, chatId: number): Watch {
        return this._watch(ctx, [appId, chatId]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AppHookShape>): AppHook {
        return new AppHook([value.appId, value.chatId], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface StickerPackShape {
    id: number;
    title: string;
    uid: number;
    published: boolean;
    usesCount: number;
    emojis: ({ emoji: string, stickerId: string })[];
}

export interface StickerPackCreateShape {
    title: string;
    uid: number;
    published: boolean;
    usesCount: number;
    emojis: ({ emoji: string, stickerId: string })[];
}

export class StickerPack extends Entity<StickerPackShape> {
    get id(): number { return this._rawValue.id; }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get published(): boolean { return this._rawValue.published; }
    set published(value: boolean) {
        let normalized = this.descriptor.codec.fields.published.normalize(value);
        if (this._rawValue.published !== normalized) {
            this._rawValue.published = normalized;
            this._updatedValues.published = normalized;
            this.invalidate();
        }
    }
    get usesCount(): number { return this._rawValue.usesCount; }
    set usesCount(value: number) {
        let normalized = this.descriptor.codec.fields.usesCount.normalize(value);
        if (this._rawValue.usesCount !== normalized) {
            this._rawValue.usesCount = normalized;
            this._updatedValues.usesCount = normalized;
            this.invalidate();
        }
    }
    get emojis(): ({ emoji: string, stickerId: string })[] { return this._rawValue.emojis; }
    set emojis(value: ({ emoji: string, stickerId: string })[]) {
        let normalized = this.descriptor.codec.fields.emojis.normalize(value);
        if (this._rawValue.emojis !== normalized) {
            this._rawValue.emojis = normalized;
            this._updatedValues.emojis = normalized;
            this.invalidate();
        }
    }
}

export class StickerPackFactory extends EntityFactory<StickerPackShape, StickerPack> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('stickerPack');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'author', storageKey: 'author', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('stickerPack', 'author'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'published', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'usesCount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'emojis', type: { type: 'array', inner: { type: 'struct', fields: { emoji: { type: 'string' }, stickerId: { type: 'string' } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            title: c.string,
            uid: c.integer,
            published: c.boolean,
            usesCount: c.integer,
            emojis: c.array(c.struct({ emoji: c.string, stickerId: c.string })),
        });
        let descriptor: EntityDescriptor<StickerPackShape> = {
            name: 'StickerPack',
            storageKey: 'stickerPack',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new StickerPackFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<StickerPackShape>) {
        super(descriptor);
    }

    readonly author = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, id: number, src: StickerPackCreateShape): Promise<StickerPack> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: StickerPackCreateShape): StickerPack {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<StickerPack | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<StickerPackShape>): StickerPack {
        return new StickerPack([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserStickersStateShape {
    uid: number;
    packIds: (number)[];
    favoriteIds: (string)[];
}

export interface UserStickersStateCreateShape {
    packIds: (number)[];
    favoriteIds: (string)[];
}

export class UserStickersState extends Entity<UserStickersStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get packIds(): (number)[] { return this._rawValue.packIds; }
    set packIds(value: (number)[]) {
        let normalized = this.descriptor.codec.fields.packIds.normalize(value);
        if (this._rawValue.packIds !== normalized) {
            this._rawValue.packIds = normalized;
            this._updatedValues.packIds = normalized;
            this.invalidate();
        }
    }
    get favoriteIds(): (string)[] { return this._rawValue.favoriteIds; }
    set favoriteIds(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.favoriteIds.normalize(value);
        if (this._rawValue.favoriteIds !== normalized) {
            this._rawValue.favoriteIds = normalized;
            this._updatedValues.favoriteIds = normalized;
            this.invalidate();
        }
    }
}

export class UserStickersStateFactory extends EntityFactory<UserStickersStateShape, UserStickersState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStickersState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'packIds', type: { type: 'array', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'favoriteIds', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            packIds: c.array(c.integer),
            favoriteIds: c.array(c.string),
        });
        let descriptor: EntityDescriptor<UserStickersStateShape> = {
            name: 'UserStickersState',
            storageKey: 'userStickersState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStickersStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStickersStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserStickersStateCreateShape): Promise<UserStickersState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserStickersStateCreateShape): UserStickersState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserStickersState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStickersStateShape>): UserStickersState {
        return new UserStickersState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface StickerShape {
    id: string;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null };
    deleted: boolean;
    emoji: string;
    relatedEmojis: (string)[] | null;
    packId: number;
}

export interface StickerCreateShape {
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined };
    deleted: boolean;
    emoji: string;
    relatedEmojis?: (string)[] | null | undefined;
    packId: number;
}

export class Sticker extends Entity<StickerShape> {
    get id(): string { return this._rawValue.id; }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get emoji(): string { return this._rawValue.emoji; }
    set emoji(value: string) {
        let normalized = this.descriptor.codec.fields.emoji.normalize(value);
        if (this._rawValue.emoji !== normalized) {
            this._rawValue.emoji = normalized;
            this._updatedValues.emoji = normalized;
            this.invalidate();
        }
    }
    get relatedEmojis(): (string)[] | null { return this._rawValue.relatedEmojis; }
    set relatedEmojis(value: (string)[] | null) {
        let normalized = this.descriptor.codec.fields.relatedEmojis.normalize(value);
        if (this._rawValue.relatedEmojis !== normalized) {
            this._rawValue.relatedEmojis = normalized;
            this._updatedValues.relatedEmojis = normalized;
            this.invalidate();
        }
    }
    get packId(): number { return this._rawValue.packId; }
    set packId(value: number) {
        let normalized = this.descriptor.codec.fields.packId.normalize(value);
        if (this._rawValue.packId !== normalized) {
            this._rawValue.packId = normalized;
            this._updatedValues.packId = normalized;
            this.invalidate();
        }
    }
}

export class StickerFactory extends EntityFactory<StickerShape, Sticker> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('sticker');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'pack', storageKey: 'pack', type: { type: 'range', fields: [{ name: 'packId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('sticker', 'pack'), condition: undefined });
        secondaryIndexes.push({ name: 'packActive', storageKey: 'packActive', type: { type: 'range', fields: [{ name: 'packId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('sticker', 'packActive'), condition: (src) => !src.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'image', type: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'emoji', type: { type: 'string' }, secure: false });
        fields.push({ name: 'relatedEmojis', type: { type: 'optional', inner: { type: 'array', inner: { type: 'string' } } }, secure: false });
        fields.push({ name: 'packId', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.string,
            image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }),
            deleted: c.boolean,
            emoji: c.string,
            relatedEmojis: c.optional(c.array(c.string)),
            packId: c.integer,
        });
        let descriptor: EntityDescriptor<StickerShape> = {
            name: 'Sticker',
            storageKey: 'sticker',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new StickerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<StickerShape>) {
        super(descriptor);
    }

    readonly pack = Object.freeze({
        findAll: async (ctx: Context, packId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [packId])).items;
        },
        query: (ctx: Context, packId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [packId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (packId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [packId], opts);
        },
        liveStream: (ctx: Context, packId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [packId], opts);
        },
    });

    readonly packActive = Object.freeze({
        findAll: async (ctx: Context, packId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [packId])).items;
        },
        query: (ctx: Context, packId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [packId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (packId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [packId], opts);
        },
        liveStream: (ctx: Context, packId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [packId], opts);
        },
    });

    create(ctx: Context, id: string, src: StickerCreateShape): Promise<Sticker> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: StickerCreateShape): Sticker {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<Sticker | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<StickerShape>): Sticker {
        return new Sticker([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface MatchmakingRoomShape {
    peerId: number;
    peerType: string;
    enabled: boolean;
    questions: ({ type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] })[];
}

export interface MatchmakingRoomCreateShape {
    enabled: boolean;
    questions: ({ type: 'text', id: string, title: string, subtitle: string | null | undefined } | { type: 'multiselect', id: string, title: string, subtitle: string | null | undefined, tags: (string)[] })[];
}

export class MatchmakingRoom extends Entity<MatchmakingRoomShape> {
    get peerId(): number { return this._rawValue.peerId; }
    get peerType(): string { return this._rawValue.peerType; }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get questions(): ({ type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] })[] { return this._rawValue.questions; }
    set questions(value: ({ type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] })[]) {
        let normalized = this.descriptor.codec.fields.questions.normalize(value);
        if (this._rawValue.questions !== normalized) {
            this._rawValue.questions = normalized;
            this._updatedValues.questions = normalized;
            this.invalidate();
        }
    }
}

export class MatchmakingRoomFactory extends EntityFactory<MatchmakingRoomShape, MatchmakingRoom> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('matchmakingRoom');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        primaryKeys.push({ name: 'peerType', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'questions', type: { type: 'array', inner: { type: 'union', types: { text: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } } }, multiselect: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } }, tags: { type: 'array', inner: { type: 'string' } } } } } }, secure: false });
        let codec = c.struct({
            peerId: c.integer,
            peerType: c.string,
            enabled: c.boolean,
            questions: c.array(c.union({ text: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string) }), multiselect: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string), tags: c.array(c.string) }) })),
        });
        let descriptor: EntityDescriptor<MatchmakingRoomShape> = {
            name: 'MatchmakingRoom',
            storageKey: 'matchmakingRoom',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new MatchmakingRoomFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<MatchmakingRoomShape>) {
        super(descriptor);
    }

    create(ctx: Context, peerId: number, peerType: string, src: MatchmakingRoomCreateShape): Promise<MatchmakingRoom> {
        return this._create(ctx, [peerId, peerType], this.descriptor.codec.normalize({ peerId, peerType, ...src }));
    }

    create_UNSAFE(ctx: Context, peerId: number, peerType: string, src: MatchmakingRoomCreateShape): MatchmakingRoom {
        return this._create_UNSAFE(ctx, [peerId, peerType], this.descriptor.codec.normalize({ peerId, peerType, ...src }));
    }

    findById(ctx: Context, peerId: number, peerType: string): Promise<MatchmakingRoom | null> {
        return this._findById(ctx, [peerId, peerType]);
    }

    watch(ctx: Context, peerId: number, peerType: string): Watch {
        return this._watch(ctx, [peerId, peerType]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<MatchmakingRoomShape>): MatchmakingRoom {
        return new MatchmakingRoom([value.peerId, value.peerType], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface MatchmakingProfileShape {
    peerId: number;
    peerType: string;
    uid: number;
    answers: ({ type: 'text', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, text: string } | { type: 'multiselect', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, tags: (string)[] })[] | null;
}

export interface MatchmakingProfileCreateShape {
    answers?: ({ type: 'text', question: { type: 'text', id: string, title: string, subtitle: string | null | undefined } | { type: 'multiselect', id: string, title: string, subtitle: string | null | undefined, tags: (string)[] }, text: string } | { type: 'multiselect', question: { type: 'text', id: string, title: string, subtitle: string | null | undefined } | { type: 'multiselect', id: string, title: string, subtitle: string | null | undefined, tags: (string)[] }, tags: (string)[] })[] | null | undefined;
}

export class MatchmakingProfile extends Entity<MatchmakingProfileShape> {
    get peerId(): number { return this._rawValue.peerId; }
    get peerType(): string { return this._rawValue.peerType; }
    get uid(): number { return this._rawValue.uid; }
    get answers(): ({ type: 'text', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, text: string } | { type: 'multiselect', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, tags: (string)[] })[] | null { return this._rawValue.answers; }
    set answers(value: ({ type: 'text', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, text: string } | { type: 'multiselect', question: { type: 'text', id: string, title: string, subtitle: string | null } | { type: 'multiselect', id: string, title: string, subtitle: string | null, tags: (string)[] }, tags: (string)[] })[] | null) {
        let normalized = this.descriptor.codec.fields.answers.normalize(value);
        if (this._rawValue.answers !== normalized) {
            this._rawValue.answers = normalized;
            this._updatedValues.answers = normalized;
            this.invalidate();
        }
    }
}

export class MatchmakingProfileFactory extends EntityFactory<MatchmakingProfileShape, MatchmakingProfile> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('matchmakingProfile');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'room', storageKey: 'room', type: { type: 'range', fields: [{ name: 'peerId', type: 'integer' }, { name: 'peerType', type: 'string' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('matchmakingProfile', 'room'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'peerId', type: 'integer' });
        primaryKeys.push({ name: 'peerType', type: 'string' });
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'answers', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { text: { question: { type: 'union', types: { text: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } } }, multiselect: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } }, tags: { type: 'array', inner: { type: 'string' } } } } }, text: { type: 'string' } }, multiselect: { question: { type: 'union', types: { text: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } } }, multiselect: { id: { type: 'string' }, title: { type: 'string' }, subtitle: { type: 'optional', inner: { type: 'string' } }, tags: { type: 'array', inner: { type: 'string' } } } } }, tags: { type: 'array', inner: { type: 'string' } } } } } } }, secure: false });
        let codec = c.struct({
            peerId: c.integer,
            peerType: c.string,
            uid: c.integer,
            answers: c.optional(c.array(c.union({ text: c.struct({ question: c.union({ text: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string) }), multiselect: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string), tags: c.array(c.string) }) }), text: c.string }), multiselect: c.struct({ question: c.union({ text: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string) }), multiselect: c.struct({ id: c.string, title: c.string, subtitle: c.optional(c.string), tags: c.array(c.string) }) }), tags: c.array(c.string) }) }))),
        });
        let descriptor: EntityDescriptor<MatchmakingProfileShape> = {
            name: 'MatchmakingProfile',
            storageKey: 'matchmakingProfile',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new MatchmakingProfileFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<MatchmakingProfileShape>) {
        super(descriptor);
    }

    readonly room = Object.freeze({
        findAll: async (ctx: Context, peerId: number, peerType: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [peerId, peerType])).items;
        },
        query: (ctx: Context, peerId: number, peerType: string, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [peerId, peerType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (peerId: number, peerType: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [peerId, peerType], opts);
        },
        liveStream: (ctx: Context, peerId: number, peerType: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [peerId, peerType], opts);
        },
    });

    create(ctx: Context, peerId: number, peerType: string, uid: number, src: MatchmakingProfileCreateShape): Promise<MatchmakingProfile> {
        return this._create(ctx, [peerId, peerType, uid], this.descriptor.codec.normalize({ peerId, peerType, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, peerId: number, peerType: string, uid: number, src: MatchmakingProfileCreateShape): MatchmakingProfile {
        return this._create_UNSAFE(ctx, [peerId, peerType, uid], this.descriptor.codec.normalize({ peerId, peerType, uid, ...src }));
    }

    findById(ctx: Context, peerId: number, peerType: string, uid: number): Promise<MatchmakingProfile | null> {
        return this._findById(ctx, [peerId, peerType, uid]);
    }

    watch(ctx: Context, peerId: number, peerType: string, uid: number): Watch {
        return this._watch(ctx, [peerId, peerType, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<MatchmakingProfileShape>): MatchmakingProfile {
        return new MatchmakingProfile([value.peerId, value.peerType, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OauthApplicationShape {
    id: number;
    clientId: string;
    uid: number;
    clientSecret: string;
    title: string;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    allowedScopes: (string)[];
    allowedRedirectUrls: (string)[] | null;
    enabled: boolean;
}

export interface OauthApplicationCreateShape {
    clientId: string;
    uid: number;
    clientSecret: string;
    title: string;
    image?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    allowedScopes: (string)[];
    allowedRedirectUrls?: (string)[] | null | undefined;
    enabled: boolean;
}

export class OauthApplication extends Entity<OauthApplicationShape> {
    get id(): number { return this._rawValue.id; }
    get clientId(): string { return this._rawValue.clientId; }
    set clientId(value: string) {
        let normalized = this.descriptor.codec.fields.clientId.normalize(value);
        if (this._rawValue.clientId !== normalized) {
            this._rawValue.clientId = normalized;
            this._updatedValues.clientId = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get clientSecret(): string { return this._rawValue.clientSecret; }
    set clientSecret(value: string) {
        let normalized = this.descriptor.codec.fields.clientSecret.normalize(value);
        if (this._rawValue.clientSecret !== normalized) {
            this._rawValue.clientSecret = normalized;
            this._updatedValues.clientSecret = normalized;
            this.invalidate();
        }
    }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get allowedScopes(): (string)[] { return this._rawValue.allowedScopes; }
    set allowedScopes(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.allowedScopes.normalize(value);
        if (this._rawValue.allowedScopes !== normalized) {
            this._rawValue.allowedScopes = normalized;
            this._updatedValues.allowedScopes = normalized;
            this.invalidate();
        }
    }
    get allowedRedirectUrls(): (string)[] | null { return this._rawValue.allowedRedirectUrls; }
    set allowedRedirectUrls(value: (string)[] | null) {
        let normalized = this.descriptor.codec.fields.allowedRedirectUrls.normalize(value);
        if (this._rawValue.allowedRedirectUrls !== normalized) {
            this._rawValue.allowedRedirectUrls = normalized;
            this._updatedValues.allowedRedirectUrls = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class OauthApplicationFactory extends EntityFactory<OauthApplicationShape, OauthApplication> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('oauthApplication');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthApplication', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'byClientId', storageKey: 'byClientId', type: { type: 'unique', fields: [{ name: 'clientId', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthApplication', 'byClientId'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'clientId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'clientSecret', type: { type: 'string' }, secure: false });
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'image', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'allowedScopes', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'allowedRedirectUrls', type: { type: 'optional', inner: { type: 'array', inner: { type: 'string' } } }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            clientId: c.string,
            uid: c.integer,
            clientSecret: c.string,
            title: c.string,
            image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            allowedScopes: c.array(c.string),
            allowedRedirectUrls: c.optional(c.array(c.string)),
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<OauthApplicationShape> = {
            name: 'OauthApplication',
            storageKey: 'oauthApplication',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OauthApplicationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OauthApplicationShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly byClientId = Object.freeze({
        find: async (ctx: Context, clientId: string) => {
            return this._findFromUniqueIndex(ctx, [clientId], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: OauthApplicationCreateShape): Promise<OauthApplication> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: OauthApplicationCreateShape): OauthApplication {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<OauthApplication | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OauthApplicationShape>): OauthApplication {
        return new OauthApplication([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OauthContextShape {
    id: string;
    clientId: string;
    state: string;
    redirectUrl: string;
    code: string;
    scopes: (string)[];
    enabled: boolean;
    uid: number | null;
}

export interface OauthContextCreateShape {
    clientId: string;
    state: string;
    redirectUrl: string;
    code: string;
    scopes: (string)[];
    enabled: boolean;
    uid?: number | null | undefined;
}

export class OauthContext extends Entity<OauthContextShape> {
    get id(): string { return this._rawValue.id; }
    get clientId(): string { return this._rawValue.clientId; }
    set clientId(value: string) {
        let normalized = this.descriptor.codec.fields.clientId.normalize(value);
        if (this._rawValue.clientId !== normalized) {
            this._rawValue.clientId = normalized;
            this._updatedValues.clientId = normalized;
            this.invalidate();
        }
    }
    get state(): string { return this._rawValue.state; }
    set state(value: string) {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get redirectUrl(): string { return this._rawValue.redirectUrl; }
    set redirectUrl(value: string) {
        let normalized = this.descriptor.codec.fields.redirectUrl.normalize(value);
        if (this._rawValue.redirectUrl !== normalized) {
            this._rawValue.redirectUrl = normalized;
            this._updatedValues.redirectUrl = normalized;
            this.invalidate();
        }
    }
    get code(): string { return this._rawValue.code; }
    set code(value: string) {
        let normalized = this.descriptor.codec.fields.code.normalize(value);
        if (this._rawValue.code !== normalized) {
            this._rawValue.code = normalized;
            this._updatedValues.code = normalized;
            this.invalidate();
        }
    }
    get scopes(): (string)[] { return this._rawValue.scopes; }
    set scopes(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.scopes.normalize(value);
        if (this._rawValue.scopes !== normalized) {
            this._rawValue.scopes = normalized;
            this._updatedValues.scopes = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get uid(): number | null { return this._rawValue.uid; }
    set uid(value: number | null) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
}

export class OauthContextFactory extends EntityFactory<OauthContextShape, OauthContext> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('oauthContext');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromCode', storageKey: 'fromCode', type: { type: 'unique', fields: [{ name: 'code', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthContext', 'fromCode'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'clientId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'state', type: { type: 'string' }, secure: false });
        fields.push({ name: 'redirectUrl', type: { type: 'string' }, secure: false });
        fields.push({ name: 'code', type: { type: 'string' }, secure: false });
        fields.push({ name: 'scopes', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            clientId: c.string,
            state: c.string,
            redirectUrl: c.string,
            code: c.string,
            scopes: c.array(c.string),
            enabled: c.boolean,
            uid: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<OauthContextShape> = {
            name: 'OauthContext',
            storageKey: 'oauthContext',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OauthContextFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OauthContextShape>) {
        super(descriptor);
    }

    readonly fromCode = Object.freeze({
        find: async (ctx: Context, code: string) => {
            return this._findFromUniqueIndex(ctx, [code], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: OauthContextCreateShape): Promise<OauthContext> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: OauthContextCreateShape): OauthContext {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<OauthContext | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OauthContextShape>): OauthContext {
        return new OauthContext([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OauthTokenShape {
    uuid: string;
    salt: string;
    uid: number;
    clientId: string;
    enabled: boolean | null;
    scopes: (string)[];
}

export interface OauthTokenCreateShape {
    salt: string;
    uid: number;
    clientId: string;
    enabled?: boolean | null | undefined;
    scopes: (string)[];
}

export class OauthToken extends Entity<OauthTokenShape> {
    get uuid(): string { return this._rawValue.uuid; }
    get salt(): string { return this._rawValue.salt; }
    set salt(value: string) {
        let normalized = this.descriptor.codec.fields.salt.normalize(value);
        if (this._rawValue.salt !== normalized) {
            this._rawValue.salt = normalized;
            this._updatedValues.salt = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get clientId(): string { return this._rawValue.clientId; }
    set clientId(value: string) {
        let normalized = this.descriptor.codec.fields.clientId.normalize(value);
        if (this._rawValue.clientId !== normalized) {
            this._rawValue.clientId = normalized;
            this._updatedValues.clientId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get scopes(): (string)[] { return this._rawValue.scopes; }
    set scopes(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.scopes.normalize(value);
        if (this._rawValue.scopes !== normalized) {
            this._rawValue.scopes = normalized;
            this._updatedValues.scopes = normalized;
            this.invalidate();
        }
    }
}

export class OauthTokenFactory extends EntityFactory<OauthTokenShape, OauthToken> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('oauthToken');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'salt', storageKey: 'salt', type: { type: 'unique', fields: [{ name: 'salt', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthToken', 'salt'), condition: undefined });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'uuid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthToken', 'user'), condition: src => src.enabled !== false });
        secondaryIndexes.push({ name: 'app', storageKey: 'app', type: { type: 'range', fields: [{ name: 'clientId', type: 'string' }, { name: 'uuid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oauthToken', 'app'), condition: src => src.enabled !== false });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uuid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'salt', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'clientId', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'scopes', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uuid: c.string,
            salt: c.string,
            uid: c.integer,
            clientId: c.string,
            enabled: c.optional(c.boolean),
            scopes: c.array(c.string),
        });
        let descriptor: EntityDescriptor<OauthTokenShape> = {
            name: 'OauthToken',
            storageKey: 'oauthToken',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OauthTokenFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OauthTokenShape>) {
        super(descriptor);
    }

    readonly salt = Object.freeze({
        find: async (ctx: Context, salt: string) => {
            return this._findFromUniqueIndex(ctx, [salt], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    readonly app = Object.freeze({
        findAll: async (ctx: Context, clientId: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [clientId])).items;
        },
        query: (ctx: Context, clientId: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [clientId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (clientId: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [clientId], opts);
        },
        liveStream: (ctx: Context, clientId: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [clientId], opts);
        },
    });

    create(ctx: Context, uuid: string, src: OauthTokenCreateShape): Promise<OauthToken> {
        return this._create(ctx, [uuid], this.descriptor.codec.normalize({ uuid, ...src }));
    }

    create_UNSAFE(ctx: Context, uuid: string, src: OauthTokenCreateShape): OauthToken {
        return this._create_UNSAFE(ctx, [uuid], this.descriptor.codec.normalize({ uuid, ...src }));
    }

    findById(ctx: Context, uuid: string): Promise<OauthToken | null> {
        return this._findById(ctx, [uuid]);
    }

    watch(ctx: Context, uuid: string): Watch {
        return this._watch(ctx, [uuid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OauthTokenShape>): OauthToken {
        return new OauthToken([value.uuid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserLocationShape {
    uid: number;
    isSharing: boolean | null;
    lastLocations: ({ date: number, location: { lat: number, long: number } })[];
}

export interface UserLocationCreateShape {
    isSharing?: boolean | null | undefined;
    lastLocations: ({ date: number, location: { lat: number, long: number } })[];
}

export class UserLocation extends Entity<UserLocationShape> {
    get uid(): number { return this._rawValue.uid; }
    get isSharing(): boolean | null { return this._rawValue.isSharing; }
    set isSharing(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isSharing.normalize(value);
        if (this._rawValue.isSharing !== normalized) {
            this._rawValue.isSharing = normalized;
            this._updatedValues.isSharing = normalized;
            this.invalidate();
        }
    }
    get lastLocations(): ({ date: number, location: { lat: number, long: number } })[] { return this._rawValue.lastLocations; }
    set lastLocations(value: ({ date: number, location: { lat: number, long: number } })[]) {
        let normalized = this.descriptor.codec.fields.lastLocations.normalize(value);
        if (this._rawValue.lastLocations !== normalized) {
            this._rawValue.lastLocations = normalized;
            this._updatedValues.lastLocations = normalized;
            this.invalidate();
        }
    }
}

export class UserLocationFactory extends EntityFactory<UserLocationShape, UserLocation> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userLocation');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'isSharing', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'lastLocations', type: { type: 'array', inner: { type: 'struct', fields: { date: { type: 'integer' }, location: { type: 'struct', fields: { lat: { type: 'float' }, long: { type: 'float' } } } } } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            isSharing: c.optional(c.boolean),
            lastLocations: c.array(c.struct({ date: c.integer, location: c.struct({ lat: c.float, long: c.float }) })),
        });
        let descriptor: EntityDescriptor<UserLocationShape> = {
            name: 'UserLocation',
            storageKey: 'userLocation',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserLocationFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserLocationShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: UserLocationCreateShape): Promise<UserLocation> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserLocationCreateShape): UserLocation {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserLocation | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserLocationShape>): UserLocation {
        return new UserLocation([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PowerupShape {
    id: number;
    uid: number | null;
    name: string;
    permissions: (string)[];
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    imageMonochrome: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null;
    description: string | null;
    deleted: boolean;
}

export interface PowerupCreateShape {
    uid?: number | null | undefined;
    name: string;
    permissions: (string)[];
    image?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    imageMonochrome?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
    description?: string | null | undefined;
    deleted: boolean;
}

export class Powerup extends Entity<PowerupShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number | null { return this._rawValue.uid; }
    set uid(value: number | null) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get name(): string { return this._rawValue.name; }
    set name(value: string) {
        let normalized = this.descriptor.codec.fields.name.normalize(value);
        if (this._rawValue.name !== normalized) {
            this._rawValue.name = normalized;
            this._updatedValues.name = normalized;
            this.invalidate();
        }
    }
    get permissions(): (string)[] { return this._rawValue.permissions; }
    set permissions(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.permissions.normalize(value);
        if (this._rawValue.permissions !== normalized) {
            this._rawValue.permissions = normalized;
            this._updatedValues.permissions = normalized;
            this.invalidate();
        }
    }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get imageMonochrome(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this._rawValue.imageMonochrome; }
    set imageMonochrome(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null) {
        let normalized = this.descriptor.codec.fields.imageMonochrome.normalize(value);
        if (this._rawValue.imageMonochrome !== normalized) {
            this._rawValue.imageMonochrome = normalized;
            this._updatedValues.imageMonochrome = normalized;
            this.invalidate();
        }
    }
    get description(): string | null { return this._rawValue.description; }
    set description(value: string | null) {
        let normalized = this.descriptor.codec.fields.description.normalize(value);
        if (this._rawValue.description !== normalized) {
            this._rawValue.description = normalized;
            this._updatedValues.description = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class PowerupFactory extends EntityFactory<PowerupShape, Powerup> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('powerup');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'name', type: { type: 'string' }, secure: false });
        fields.push({ name: 'permissions', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'image', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'imageMonochrome', type: { type: 'optional', inner: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } } }, secure: false });
        fields.push({ name: 'description', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.optional(c.integer),
            name: c.string,
            permissions: c.array(c.string),
            image: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            imageMonochrome: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
            description: c.optional(c.string),
            deleted: c.boolean,
        });
        let descriptor: EntityDescriptor<PowerupShape> = {
            name: 'Powerup',
            storageKey: 'powerup',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PowerupFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PowerupShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: PowerupCreateShape): Promise<Powerup> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: PowerupCreateShape): Powerup {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Powerup | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PowerupShape>): Powerup {
        return new Powerup([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ChatPowerupShape {
    pid: number;
    cid: number;
    enabled: boolean;
    userSettings: any;
}

export interface ChatPowerupCreateShape {
    enabled: boolean;
    userSettings: any;
}

export class ChatPowerup extends Entity<ChatPowerupShape> {
    get pid(): number { return this._rawValue.pid; }
    get cid(): number { return this._rawValue.cid; }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
    get userSettings(): any { return this._rawValue.userSettings; }
    set userSettings(value: any) {
        let normalized = this.descriptor.codec.fields.userSettings.normalize(value);
        if (this._rawValue.userSettings !== normalized) {
            this._rawValue.userSettings = normalized;
            this._updatedValues.userSettings = normalized;
            this.invalidate();
        }
    }
}

export class ChatPowerupFactory extends EntityFactory<ChatPowerupShape, ChatPowerup> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('chatPowerup');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'byPid', storageKey: 'byPid', type: { type: 'range', fields: [{ name: 'pid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('chatPowerup', 'byPid'), condition: undefined });
        secondaryIndexes.push({ name: 'byCid', storageKey: 'byCid', type: { type: 'range', fields: [{ name: 'cid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('chatPowerup', 'byCid'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'pid', type: 'integer' });
        primaryKeys.push({ name: 'cid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'userSettings', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            pid: c.integer,
            cid: c.integer,
            enabled: c.boolean,
            userSettings: c.any,
        });
        let descriptor: EntityDescriptor<ChatPowerupShape> = {
            name: 'ChatPowerup',
            storageKey: 'chatPowerup',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ChatPowerupFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ChatPowerupShape>) {
        super(descriptor);
    }

    readonly byPid = Object.freeze({
        findAll: async (ctx: Context, pid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [pid])).items;
        },
        query: (ctx: Context, pid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [pid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (pid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [pid], opts);
        },
        liveStream: (ctx: Context, pid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [pid], opts);
        },
    });

    readonly byCid = Object.freeze({
        findAll: async (ctx: Context, cid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [cid])).items;
        },
        query: (ctx: Context, cid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [cid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (cid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [cid], opts);
        },
        liveStream: (ctx: Context, cid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [cid], opts);
        },
    });

    create(ctx: Context, pid: number, cid: number, src: ChatPowerupCreateShape): Promise<ChatPowerup> {
        return this._create(ctx, [pid, cid], this.descriptor.codec.normalize({ pid, cid, ...src }));
    }

    create_UNSAFE(ctx: Context, pid: number, cid: number, src: ChatPowerupCreateShape): ChatPowerup {
        return this._create_UNSAFE(ctx, [pid, cid], this.descriptor.codec.normalize({ pid, cid, ...src }));
    }

    findById(ctx: Context, pid: number, cid: number): Promise<ChatPowerup | null> {
        return this._findById(ctx, [pid, cid]);
    }

    watch(ctx: Context, pid: number, cid: number): Watch {
        return this._watch(ctx, [pid, cid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ChatPowerupShape>): ChatPowerup {
        return new ChatPowerup([value.pid, value.cid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PermissionRequestShape {
    id: string;
    uid: number;
    gid: number;
    appType: 'powerup';
    appId: number;
    scopeType: 'global' | 'chat';
    scopeId: number | null;
    status: 'rejected' | 'waiting' | 'granted';
}

export interface PermissionRequestCreateShape {
    uid: number;
    gid: number;
    appType: 'powerup';
    appId: number;
    scopeType: 'global' | 'chat';
    scopeId?: number | null | undefined;
    status: 'rejected' | 'waiting' | 'granted';
}

export class PermissionRequest extends Entity<PermissionRequestShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get gid(): number { return this._rawValue.gid; }
    set gid(value: number) {
        let normalized = this.descriptor.codec.fields.gid.normalize(value);
        if (this._rawValue.gid !== normalized) {
            this._rawValue.gid = normalized;
            this._updatedValues.gid = normalized;
            this.invalidate();
        }
    }
    get appType(): 'powerup' { return this._rawValue.appType; }
    set appType(value: 'powerup') {
        let normalized = this.descriptor.codec.fields.appType.normalize(value);
        if (this._rawValue.appType !== normalized) {
            this._rawValue.appType = normalized;
            this._updatedValues.appType = normalized;
            this.invalidate();
        }
    }
    get appId(): number { return this._rawValue.appId; }
    set appId(value: number) {
        let normalized = this.descriptor.codec.fields.appId.normalize(value);
        if (this._rawValue.appId !== normalized) {
            this._rawValue.appId = normalized;
            this._updatedValues.appId = normalized;
            this.invalidate();
        }
    }
    get scopeType(): 'global' | 'chat' { return this._rawValue.scopeType; }
    set scopeType(value: 'global' | 'chat') {
        let normalized = this.descriptor.codec.fields.scopeType.normalize(value);
        if (this._rawValue.scopeType !== normalized) {
            this._rawValue.scopeType = normalized;
            this._updatedValues.scopeType = normalized;
            this.invalidate();
        }
    }
    get scopeId(): number | null { return this._rawValue.scopeId; }
    set scopeId(value: number | null) {
        let normalized = this.descriptor.codec.fields.scopeId.normalize(value);
        if (this._rawValue.scopeId !== normalized) {
            this._rawValue.scopeId = normalized;
            this._updatedValues.scopeId = normalized;
            this.invalidate();
        }
    }
    get status(): 'rejected' | 'waiting' | 'granted' { return this._rawValue.status; }
    set status(value: 'rejected' | 'waiting' | 'granted') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
}

export class PermissionRequestFactory extends EntityFactory<PermissionRequestShape, PermissionRequest> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('permissionRequest');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('permissionRequest', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'userGroup', storageKey: 'userGroup', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'gid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('permissionRequest', 'userGroup'), condition: undefined });
        secondaryIndexes.push({ name: 'groupApp', storageKey: 'groupApp', type: { type: 'range', fields: [{ name: 'gid', type: 'integer' }, { name: 'appType', type: 'string' }, { name: 'appId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('permissionRequest', 'groupApp'), condition: undefined });
        secondaryIndexes.push({ name: 'userApp', storageKey: 'userApp', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'appType', type: 'string' }, { name: 'appId', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('permissionRequest', 'userApp'), condition: undefined });
        secondaryIndexes.push({ name: 'single', storageKey: 'single', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'gid', type: 'integer' }, { name: 'appType', type: 'string' }, { name: 'appId', type: 'integer' }, { name: 'scopeType', type: 'string' }, { name: 'scopeId', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('permissionRequest', 'single'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'gid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'appType', type: { type: 'enum', values: ['powerup'] }, secure: false });
        fields.push({ name: 'appId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'scopeType', type: { type: 'enum', values: ['global', 'chat'] }, secure: false });
        fields.push({ name: 'scopeId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['rejected', 'waiting', 'granted'] }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            gid: c.integer,
            appType: c.enum('powerup'),
            appId: c.integer,
            scopeType: c.enum('global', 'chat'),
            scopeId: c.optional(c.integer),
            status: c.enum('rejected', 'waiting', 'granted'),
        });
        let descriptor: EntityDescriptor<PermissionRequestShape> = {
            name: 'PermissionRequest',
            storageKey: 'permissionRequest',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PermissionRequestFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PermissionRequestShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly userGroup = Object.freeze({
        findAll: async (ctx: Context, uid: number, gid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid, gid])).items;
        },
        query: (ctx: Context, uid: number, gid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid, gid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, gid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid, gid], opts);
        },
        liveStream: (ctx: Context, uid: number, gid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid, gid], opts);
        },
    });

    readonly groupApp = Object.freeze({
        findAll: async (ctx: Context, gid: number, appType: 'powerup', appId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [gid, appType, appId])).items;
        },
        query: (ctx: Context, gid: number, appType: 'powerup', appId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [gid, appType, appId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (gid: number, appType: 'powerup', appId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [gid, appType, appId], opts);
        },
        liveStream: (ctx: Context, gid: number, appType: 'powerup', appId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [gid, appType, appId], opts);
        },
    });

    readonly userApp = Object.freeze({
        findAll: async (ctx: Context, uid: number, appType: 'powerup', appId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [uid, appType, appId])).items;
        },
        query: (ctx: Context, uid: number, appType: 'powerup', appId: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [uid, appType, appId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, appType: 'powerup', appId: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [uid, appType, appId], opts);
        },
        liveStream: (ctx: Context, uid: number, appType: 'powerup', appId: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [uid, appType, appId], opts);
        },
    });

    readonly single = Object.freeze({
        find: async (ctx: Context, uid: number, gid: number, appType: 'powerup', appId: number, scopeType: 'global' | 'chat', scopeId: number | null) => {
            return this._findFromUniqueIndex(ctx, [uid, gid, appType, appId, scopeType, scopeId], this.descriptor.secondaryIndexes[4]);
        },
        findAll: async (ctx: Context, uid: number, gid: number, appType: 'powerup', appId: number, scopeType: 'global' | 'chat') => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[4], [uid, gid, appType, appId, scopeType])).items;
        },
        query: (ctx: Context, uid: number, gid: number, appType: 'powerup', appId: number, scopeType: 'global' | 'chat', opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[4], [uid, gid, appType, appId, scopeType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: PermissionRequestCreateShape): Promise<PermissionRequest> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PermissionRequestCreateShape): PermissionRequest {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PermissionRequest | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PermissionRequestShape>): PermissionRequest {
        return new PermissionRequest([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserStorageNamespaceShape {
    id: number;
    ns: string;
}

export interface UserStorageNamespaceCreateShape {
    ns: string;
}

export class UserStorageNamespace extends Entity<UserStorageNamespaceShape> {
    get id(): number { return this._rawValue.id; }
    get ns(): string { return this._rawValue.ns; }
    set ns(value: string) {
        let normalized = this.descriptor.codec.fields.ns.normalize(value);
        if (this._rawValue.ns !== normalized) {
            this._rawValue.ns = normalized;
            this._updatedValues.ns = normalized;
            this.invalidate();
        }
    }
}

export class UserStorageNamespaceFactory extends EntityFactory<UserStorageNamespaceShape, UserStorageNamespace> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStorageNamespace');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'namespace', storageKey: 'namespace', type: { type: 'unique', fields: [{ name: 'ns', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStorageNamespace', 'namespace'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ns', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            ns: c.string,
        });
        let descriptor: EntityDescriptor<UserStorageNamespaceShape> = {
            name: 'UserStorageNamespace',
            storageKey: 'userStorageNamespace',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStorageNamespaceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStorageNamespaceShape>) {
        super(descriptor);
    }

    readonly namespace = Object.freeze({
        find: async (ctx: Context, ns: string) => {
            return this._findFromUniqueIndex(ctx, [ns], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: UserStorageNamespaceCreateShape): Promise<UserStorageNamespace> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: UserStorageNamespaceCreateShape): UserStorageNamespace {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UserStorageNamespace | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStorageNamespaceShape>): UserStorageNamespace {
        return new UserStorageNamespace([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserStorageRecordShape {
    uid: number;
    id: number;
    ns: number;
    key: string;
    value: string | null;
}

export interface UserStorageRecordCreateShape {
    ns: number;
    key: string;
    value?: string | null | undefined;
}

export class UserStorageRecord extends Entity<UserStorageRecordShape> {
    get uid(): number { return this._rawValue.uid; }
    get id(): number { return this._rawValue.id; }
    get ns(): number { return this._rawValue.ns; }
    set ns(value: number) {
        let normalized = this.descriptor.codec.fields.ns.normalize(value);
        if (this._rawValue.ns !== normalized) {
            this._rawValue.ns = normalized;
            this._updatedValues.ns = normalized;
            this.invalidate();
        }
    }
    get key(): string { return this._rawValue.key; }
    set key(value: string) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
    get value(): string | null { return this._rawValue.value; }
    set value(value: string | null) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class UserStorageRecordFactory extends EntityFactory<UserStorageRecordShape, UserStorageRecord> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStorageRecord');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'key', storageKey: 'key', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }, { name: 'ns', type: 'integer' }, { name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStorageRecord', 'key'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'ns', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'key', type: { type: 'string' }, secure: false });
        fields.push({ name: 'value', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            id: c.integer,
            ns: c.integer,
            key: c.string,
            value: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserStorageRecordShape> = {
            name: 'UserStorageRecord',
            storageKey: 'userStorageRecord',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStorageRecordFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStorageRecordShape>) {
        super(descriptor);
    }

    readonly key = Object.freeze({
        find: async (ctx: Context, uid: number, ns: number, key: string) => {
            return this._findFromUniqueIndex(ctx, [uid, ns, key], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, uid: number, ns: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid, ns])).items;
        },
        query: (ctx: Context, uid: number, ns: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid, ns], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, uid: number, id: number, src: UserStorageRecordCreateShape): Promise<UserStorageRecord> {
        return this._create(ctx, [uid, id], this.descriptor.codec.normalize({ uid, id, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, id: number, src: UserStorageRecordCreateShape): UserStorageRecord {
        return this._create_UNSAFE(ctx, [uid, id], this.descriptor.codec.normalize({ uid, id, ...src }));
    }

    findById(ctx: Context, uid: number, id: number): Promise<UserStorageRecord | null> {
        return this._findById(ctx, [uid, id]);
    }

    watch(ctx: Context, uid: number, id: number): Watch {
        return this._watch(ctx, [uid, id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStorageRecordShape>): UserStorageRecord {
        return new UserStorageRecord([value.uid, value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserStripeCustomerShape {
    uid: number;
    uniqueKey: string;
    stripeId: string | null;
}

export interface UserStripeCustomerCreateShape {
    uniqueKey: string;
    stripeId?: string | null | undefined;
}

export class UserStripeCustomer extends Entity<UserStripeCustomerShape> {
    get uid(): number { return this._rawValue.uid; }
    get uniqueKey(): string { return this._rawValue.uniqueKey; }
    set uniqueKey(value: string) {
        let normalized = this.descriptor.codec.fields.uniqueKey.normalize(value);
        if (this._rawValue.uniqueKey !== normalized) {
            this._rawValue.uniqueKey = normalized;
            this._updatedValues.uniqueKey = normalized;
            this.invalidate();
        }
    }
    get stripeId(): string | null { return this._rawValue.stripeId; }
    set stripeId(value: string | null) {
        let normalized = this.descriptor.codec.fields.stripeId.normalize(value);
        if (this._rawValue.stripeId !== normalized) {
            this._rawValue.stripeId = normalized;
            this._updatedValues.stripeId = normalized;
            this.invalidate();
        }
    }
}

export class UserStripeCustomerFactory extends EntityFactory<UserStripeCustomerShape, UserStripeCustomer> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStripeCustomer');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'stripe', storageKey: 'stripe', type: { type: 'unique', fields: [{ name: 'stripeId', type: 'opt_string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStripeCustomer', 'stripe'), condition: (s) => !!s.stripeId });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uniqueKey', type: { type: 'string' }, secure: false });
        fields.push({ name: 'stripeId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            uniqueKey: c.string,
            stripeId: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<UserStripeCustomerShape> = {
            name: 'UserStripeCustomer',
            storageKey: 'userStripeCustomer',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStripeCustomerFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStripeCustomerShape>) {
        super(descriptor);
    }

    readonly stripe = Object.freeze({
        find: async (ctx: Context, stripeId: string | null) => {
            return this._findFromUniqueIndex(ctx, [stripeId], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, uid: number, src: UserStripeCustomerCreateShape): Promise<UserStripeCustomer> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: UserStripeCustomerCreateShape): UserStripeCustomer {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<UserStripeCustomer | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStripeCustomerShape>): UserStripeCustomer {
        return new UserStripeCustomer([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface UserStripeCardShape {
    uid: number;
    pmid: string;
    default: boolean;
    deleted: boolean;
    brand: string;
    country: string;
    exp_month: number;
    exp_year: number;
    last4: string;
    stripeAttached: boolean;
    stripeDetached: boolean;
}

export interface UserStripeCardCreateShape {
    default: boolean;
    deleted: boolean;
    brand: string;
    country: string;
    exp_month: number;
    exp_year: number;
    last4: string;
    stripeAttached: boolean;
    stripeDetached: boolean;
}

export class UserStripeCard extends Entity<UserStripeCardShape> {
    get uid(): number { return this._rawValue.uid; }
    get pmid(): string { return this._rawValue.pmid; }
    get default(): boolean { return this._rawValue.default; }
    set default(value: boolean) {
        let normalized = this.descriptor.codec.fields.default.normalize(value);
        if (this._rawValue.default !== normalized) {
            this._rawValue.default = normalized;
            this._updatedValues.default = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean { return this._rawValue.deleted; }
    set deleted(value: boolean) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get brand(): string { return this._rawValue.brand; }
    set brand(value: string) {
        let normalized = this.descriptor.codec.fields.brand.normalize(value);
        if (this._rawValue.brand !== normalized) {
            this._rawValue.brand = normalized;
            this._updatedValues.brand = normalized;
            this.invalidate();
        }
    }
    get country(): string { return this._rawValue.country; }
    set country(value: string) {
        let normalized = this.descriptor.codec.fields.country.normalize(value);
        if (this._rawValue.country !== normalized) {
            this._rawValue.country = normalized;
            this._updatedValues.country = normalized;
            this.invalidate();
        }
    }
    get exp_month(): number { return this._rawValue.exp_month; }
    set exp_month(value: number) {
        let normalized = this.descriptor.codec.fields.exp_month.normalize(value);
        if (this._rawValue.exp_month !== normalized) {
            this._rawValue.exp_month = normalized;
            this._updatedValues.exp_month = normalized;
            this.invalidate();
        }
    }
    get exp_year(): number { return this._rawValue.exp_year; }
    set exp_year(value: number) {
        let normalized = this.descriptor.codec.fields.exp_year.normalize(value);
        if (this._rawValue.exp_year !== normalized) {
            this._rawValue.exp_year = normalized;
            this._updatedValues.exp_year = normalized;
            this.invalidate();
        }
    }
    get last4(): string { return this._rawValue.last4; }
    set last4(value: string) {
        let normalized = this.descriptor.codec.fields.last4.normalize(value);
        if (this._rawValue.last4 !== normalized) {
            this._rawValue.last4 = normalized;
            this._updatedValues.last4 = normalized;
            this.invalidate();
        }
    }
    get stripeAttached(): boolean { return this._rawValue.stripeAttached; }
    set stripeAttached(value: boolean) {
        let normalized = this.descriptor.codec.fields.stripeAttached.normalize(value);
        if (this._rawValue.stripeAttached !== normalized) {
            this._rawValue.stripeAttached = normalized;
            this._updatedValues.stripeAttached = normalized;
            this.invalidate();
        }
    }
    get stripeDetached(): boolean { return this._rawValue.stripeDetached; }
    set stripeDetached(value: boolean) {
        let normalized = this.descriptor.codec.fields.stripeDetached.normalize(value);
        if (this._rawValue.stripeDetached !== normalized) {
            this._rawValue.stripeDetached = normalized;
            this._updatedValues.stripeDetached = normalized;
            this.invalidate();
        }
    }
}

export class UserStripeCardFactory extends EntityFactory<UserStripeCardShape, UserStripeCard> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('userStripeCard');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'default', storageKey: 'default', type: { type: 'unique', fields: [{ name: 'uid', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('userStripeCard', 'default'), condition: (s) => s.default });
        secondaryIndexes.push({ name: 'pmid', storageKey: 'pmid', type: { type: 'unique', fields: [{ name: 'pmid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStripeCard', 'pmid'), condition: undefined });
        secondaryIndexes.push({ name: 'users', storageKey: 'users', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'pmid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('userStripeCard', 'users'), condition: (s) => !s.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'pmid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'default', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'brand', type: { type: 'string' }, secure: false });
        fields.push({ name: 'country', type: { type: 'string' }, secure: false });
        fields.push({ name: 'exp_month', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'exp_year', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'last4', type: { type: 'string' }, secure: false });
        fields.push({ name: 'stripeAttached', type: { type: 'boolean' }, secure: false });
        fields.push({ name: 'stripeDetached', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            pmid: c.string,
            default: c.boolean,
            deleted: c.boolean,
            brand: c.string,
            country: c.string,
            exp_month: c.integer,
            exp_year: c.integer,
            last4: c.string,
            stripeAttached: c.boolean,
            stripeDetached: c.boolean,
        });
        let descriptor: EntityDescriptor<UserStripeCardShape> = {
            name: 'UserStripeCard',
            storageKey: 'userStripeCard',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UserStripeCardFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UserStripeCardShape>) {
        super(descriptor);
    }

    readonly default = Object.freeze({
        find: async (ctx: Context, uid: number) => {
            return this._findFromUniqueIndex(ctx, [uid], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly pmid = Object.freeze({
        find: async (ctx: Context, pmid: string) => {
            return this._findFromUniqueIndex(ctx, [pmid], this.descriptor.secondaryIndexes[1]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly users = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, pmid: string, src: UserStripeCardCreateShape): Promise<UserStripeCard> {
        return this._create(ctx, [uid, pmid], this.descriptor.codec.normalize({ uid, pmid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, pmid: string, src: UserStripeCardCreateShape): UserStripeCard {
        return this._create_UNSAFE(ctx, [uid, pmid], this.descriptor.codec.normalize({ uid, pmid, ...src }));
    }

    findById(ctx: Context, uid: number, pmid: string): Promise<UserStripeCard | null> {
        return this._findById(ctx, [uid, pmid]);
    }

    watch(ctx: Context, uid: number, pmid: string): Watch {
        return this._watch(ctx, [uid, pmid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UserStripeCardShape>): UserStripeCard {
        return new UserStripeCard([value.uid, value.pmid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletShape {
    uid: number;
    balance: number;
    balanceLocked: number;
    isLocked: boolean | null;
}

export interface WalletCreateShape {
    balance: number;
    balanceLocked: number;
    isLocked?: boolean | null | undefined;
}

export class Wallet extends Entity<WalletShape> {
    get uid(): number { return this._rawValue.uid; }
    get balance(): number { return this._rawValue.balance; }
    set balance(value: number) {
        let normalized = this.descriptor.codec.fields.balance.normalize(value);
        if (this._rawValue.balance !== normalized) {
            this._rawValue.balance = normalized;
            this._updatedValues.balance = normalized;
            this.invalidate();
        }
    }
    get balanceLocked(): number { return this._rawValue.balanceLocked; }
    set balanceLocked(value: number) {
        let normalized = this.descriptor.codec.fields.balanceLocked.normalize(value);
        if (this._rawValue.balanceLocked !== normalized) {
            this._rawValue.balanceLocked = normalized;
            this._updatedValues.balanceLocked = normalized;
            this.invalidate();
        }
    }
    get isLocked(): boolean | null { return this._rawValue.isLocked; }
    set isLocked(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.isLocked.normalize(value);
        if (this._rawValue.isLocked !== normalized) {
            this._rawValue.isLocked = normalized;
            this._updatedValues.isLocked = normalized;
            this.invalidate();
        }
    }
}

export class WalletFactory extends EntityFactory<WalletShape, Wallet> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('wallet');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'balance', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'balanceLocked', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'isLocked', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            balance: c.integer,
            balanceLocked: c.integer,
            isLocked: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<WalletShape> = {
            name: 'Wallet',
            storageKey: 'wallet',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: WalletCreateShape): Promise<Wallet> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: WalletCreateShape): Wallet {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<Wallet | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletShape>): Wallet {
        return new Wallet([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletTransactionShape {
    id: string;
    uid: number;
    status: 'pending' | 'canceled' | 'success';
    parentId: string | null;
    deleted: boolean | null;
    operation: { type: 'deposit', amount: number, payment: string | null } | { type: 'subscription', chargeAmount: number, walletAmount: number, subscription: string, index: number } | { type: 'transfer_out', walletAmount: number, chargeAmount: number, toUser: number, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'transfer_in', amount: number, fromUser: number } | { type: 'purchase', walletAmount: number, chargeAmount: number, purchase: string, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'income', amount: number, source: 'subscription' | 'purchase', id: string };
}

export interface WalletTransactionCreateShape {
    uid: number;
    status: 'pending' | 'canceled' | 'success';
    parentId?: string | null | undefined;
    deleted?: boolean | null | undefined;
    operation: { type: 'deposit', amount: number, payment: string | null | undefined } | { type: 'subscription', chargeAmount: number, walletAmount: number, subscription: string, index: number } | { type: 'transfer_out', walletAmount: number, chargeAmount: number, toUser: number, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'transfer_in', amount: number, fromUser: number } | { type: 'purchase', walletAmount: number, chargeAmount: number, purchase: string, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'income', amount: number, source: 'subscription' | 'purchase', id: string };
}

export class WalletTransaction extends Entity<WalletTransactionShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get status(): 'pending' | 'canceled' | 'success' { return this._rawValue.status; }
    set status(value: 'pending' | 'canceled' | 'success') {
        let normalized = this.descriptor.codec.fields.status.normalize(value);
        if (this._rawValue.status !== normalized) {
            this._rawValue.status = normalized;
            this._updatedValues.status = normalized;
            this.invalidate();
        }
    }
    get parentId(): string | null { return this._rawValue.parentId; }
    set parentId(value: string | null) {
        let normalized = this.descriptor.codec.fields.parentId.normalize(value);
        if (this._rawValue.parentId !== normalized) {
            this._rawValue.parentId = normalized;
            this._updatedValues.parentId = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get operation(): { type: 'deposit', amount: number, payment: string | null } | { type: 'subscription', chargeAmount: number, walletAmount: number, subscription: string, index: number } | { type: 'transfer_out', walletAmount: number, chargeAmount: number, toUser: number, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'transfer_in', amount: number, fromUser: number } | { type: 'purchase', walletAmount: number, chargeAmount: number, purchase: string, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'income', amount: number, source: 'subscription' | 'purchase', id: string } { return this._rawValue.operation; }
    set operation(value: { type: 'deposit', amount: number, payment: string | null } | { type: 'subscription', chargeAmount: number, walletAmount: number, subscription: string, index: number } | { type: 'transfer_out', walletAmount: number, chargeAmount: number, toUser: number, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'transfer_in', amount: number, fromUser: number } | { type: 'purchase', walletAmount: number, chargeAmount: number, purchase: string, payment: { type: 'payment', id: string } | { type: 'paymentIntent', id: string } | { type: 'balance',  } } | { type: 'income', amount: number, source: 'subscription' | 'purchase', id: string }) {
        let normalized = this.descriptor.codec.fields.operation.normalize(value);
        if (this._rawValue.operation !== normalized) {
            this._rawValue.operation = normalized;
            this._updatedValues.operation = normalized;
            this.invalidate();
        }
    }
}

export class WalletTransactionFactory extends EntityFactory<WalletTransactionShape, WalletTransaction> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletTransaction');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'pending', storageKey: 'pending', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletTransaction', 'pending'), condition: (s) => !s.deleted && (s.status === 'pending' || s.status === 'canceling') });
        secondaryIndexes.push({ name: 'history', storageKey: 'history', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletTransaction', 'history'), condition: (s) => !s.deleted && !(s.status === 'pending' || s.status === 'canceling') });
        secondaryIndexes.push({ name: 'pendingChild', storageKey: 'pendingChild', type: { type: 'range', fields: [{ name: 'parentId', type: 'opt_string' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletTransaction', 'pendingChild'), condition: (s) => s.status === 'pending' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'status', type: { type: 'enum', values: ['pending', 'canceled', 'success'] }, secure: false });
        fields.push({ name: 'parentId', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'operation', type: { type: 'union', types: { deposit: { amount: { type: 'integer' }, payment: { type: 'optional', inner: { type: 'string' } } }, subscription: { chargeAmount: { type: 'integer' }, walletAmount: { type: 'integer' }, subscription: { type: 'string' }, index: { type: 'integer' } }, transfer_out: { walletAmount: { type: 'integer' }, chargeAmount: { type: 'integer' }, toUser: { type: 'integer' }, payment: { type: 'union', types: { payment: { id: { type: 'string' } }, paymentIntent: { id: { type: 'string' } }, balance: {  } } } }, transfer_in: { amount: { type: 'integer' }, fromUser: { type: 'integer' } }, purchase: { walletAmount: { type: 'integer' }, chargeAmount: { type: 'integer' }, purchase: { type: 'string' }, payment: { type: 'union', types: { payment: { id: { type: 'string' } }, paymentIntent: { id: { type: 'string' } }, balance: {  } } } }, income: { amount: { type: 'integer' }, source: { type: 'enum', values: ['subscription', 'purchase'] }, id: { type: 'string' } } } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            status: c.enum('pending', 'canceled', 'success'),
            parentId: c.optional(c.string),
            deleted: c.optional(c.boolean),
            operation: c.union({ deposit: c.struct({ amount: c.integer, payment: c.optional(c.string) }), subscription: c.struct({ chargeAmount: c.integer, walletAmount: c.integer, subscription: c.string, index: c.integer }), transfer_out: c.struct({ walletAmount: c.integer, chargeAmount: c.integer, toUser: c.integer, payment: c.union({ payment: c.struct({ id: c.string }), paymentIntent: c.struct({ id: c.string }), balance: c.struct({  }) }) }), transfer_in: c.struct({ amount: c.integer, fromUser: c.integer }), purchase: c.struct({ walletAmount: c.integer, chargeAmount: c.integer, purchase: c.string, payment: c.union({ payment: c.struct({ id: c.string }), paymentIntent: c.struct({ id: c.string }), balance: c.struct({  }) }) }), income: c.struct({ amount: c.integer, source: c.enum('subscription', 'purchase'), id: c.string }) }),
        });
        let descriptor: EntityDescriptor<WalletTransactionShape> = {
            name: 'WalletTransaction',
            storageKey: 'walletTransaction',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletTransactionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletTransactionShape>) {
        super(descriptor);
    }

    readonly pending = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly history = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    readonly pendingChild = Object.freeze({
        findAll: async (ctx: Context, parentId: string | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [parentId])).items;
        },
        query: (ctx: Context, parentId: string | null, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [parentId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (parentId: string | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [parentId], opts);
        },
        liveStream: (ctx: Context, parentId: string | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [parentId], opts);
        },
    });

    create(ctx: Context, id: string, src: WalletTransactionCreateShape): Promise<WalletTransaction> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: WalletTransactionCreateShape): WalletTransaction {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<WalletTransaction | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletTransactionShape>): WalletTransaction {
        return new WalletTransaction([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletDepositRequestShape {
    uid: number;
    retryKey: string;
    pid: string;
}

export interface WalletDepositRequestCreateShape {
    pid: string;
}

export class WalletDepositRequest extends Entity<WalletDepositRequestShape> {
    get uid(): number { return this._rawValue.uid; }
    get retryKey(): string { return this._rawValue.retryKey; }
    get pid(): string { return this._rawValue.pid; }
    set pid(value: string) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
}

export class WalletDepositRequestFactory extends EntityFactory<WalletDepositRequestShape, WalletDepositRequest> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletDepositRequest');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'retryKey', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            retryKey: c.string,
            pid: c.string,
        });
        let descriptor: EntityDescriptor<WalletDepositRequestShape> = {
            name: 'WalletDepositRequest',
            storageKey: 'walletDepositRequest',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletDepositRequestFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletDepositRequestShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, retryKey: string, src: WalletDepositRequestCreateShape): Promise<WalletDepositRequest> {
        return this._create(ctx, [uid, retryKey], this.descriptor.codec.normalize({ uid, retryKey, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, retryKey: string, src: WalletDepositRequestCreateShape): WalletDepositRequest {
        return this._create_UNSAFE(ctx, [uid, retryKey], this.descriptor.codec.normalize({ uid, retryKey, ...src }));
    }

    findById(ctx: Context, uid: number, retryKey: string): Promise<WalletDepositRequest | null> {
        return this._findById(ctx, [uid, retryKey]);
    }

    watch(ctx: Context, uid: number, retryKey: string): Watch {
        return this._watch(ctx, [uid, retryKey]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletDepositRequestShape>): WalletDepositRequest {
        return new WalletDepositRequest([value.uid, value.retryKey], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletTransferRequestShape {
    fromUid: number;
    toUid: number;
    retryKey: string;
    pid: string | null;
}

export interface WalletTransferRequestCreateShape {
    pid?: string | null | undefined;
}

export class WalletTransferRequest extends Entity<WalletTransferRequestShape> {
    get fromUid(): number { return this._rawValue.fromUid; }
    get toUid(): number { return this._rawValue.toUid; }
    get retryKey(): string { return this._rawValue.retryKey; }
    get pid(): string | null { return this._rawValue.pid; }
    set pid(value: string | null) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
}

export class WalletTransferRequestFactory extends EntityFactory<WalletTransferRequestShape, WalletTransferRequest> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletTransferRequest');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'fromUid', type: 'integer' });
        primaryKeys.push({ name: 'toUid', type: 'integer' });
        primaryKeys.push({ name: 'retryKey', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            fromUid: c.integer,
            toUid: c.integer,
            retryKey: c.string,
            pid: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<WalletTransferRequestShape> = {
            name: 'WalletTransferRequest',
            storageKey: 'walletTransferRequest',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletTransferRequestFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletTransferRequestShape>) {
        super(descriptor);
    }

    create(ctx: Context, fromUid: number, toUid: number, retryKey: string, src: WalletTransferRequestCreateShape): Promise<WalletTransferRequest> {
        return this._create(ctx, [fromUid, toUid, retryKey], this.descriptor.codec.normalize({ fromUid, toUid, retryKey, ...src }));
    }

    create_UNSAFE(ctx: Context, fromUid: number, toUid: number, retryKey: string, src: WalletTransferRequestCreateShape): WalletTransferRequest {
        return this._create_UNSAFE(ctx, [fromUid, toUid, retryKey], this.descriptor.codec.normalize({ fromUid, toUid, retryKey, ...src }));
    }

    findById(ctx: Context, fromUid: number, toUid: number, retryKey: string): Promise<WalletTransferRequest | null> {
        return this._findById(ctx, [fromUid, toUid, retryKey]);
    }

    watch(ctx: Context, fromUid: number, toUid: number, retryKey: string): Watch {
        return this._watch(ctx, [fromUid, toUid, retryKey]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletTransferRequestShape>): WalletTransferRequest {
        return new WalletTransferRequest([value.fromUid, value.toUid, value.retryKey], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletPurchaseShape {
    id: string;
    uid: number;
    pid: string | null;
    txid: string;
    deleted: boolean | null;
    amount: number;
    product: { type: 'group', gid: number } | { type: 'donate_message', uid: number, cid: number, mid: number | null } | { type: 'donate_reaction', uid: number, mid: number };
    state: 'pending' | 'canceled' | 'success';
}

export interface WalletPurchaseCreateShape {
    uid: number;
    pid?: string | null | undefined;
    txid: string;
    deleted?: boolean | null | undefined;
    amount: number;
    product: { type: 'group', gid: number } | { type: 'donate_message', uid: number, cid: number, mid: number | null | undefined } | { type: 'donate_reaction', uid: number, mid: number };
    state: 'pending' | 'canceled' | 'success';
}

export class WalletPurchase extends Entity<WalletPurchaseShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get pid(): string | null { return this._rawValue.pid; }
    set pid(value: string | null) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
    get txid(): string { return this._rawValue.txid; }
    set txid(value: string) {
        let normalized = this.descriptor.codec.fields.txid.normalize(value);
        if (this._rawValue.txid !== normalized) {
            this._rawValue.txid = normalized;
            this._updatedValues.txid = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
    get amount(): number { return this._rawValue.amount; }
    set amount(value: number) {
        let normalized = this.descriptor.codec.fields.amount.normalize(value);
        if (this._rawValue.amount !== normalized) {
            this._rawValue.amount = normalized;
            this._updatedValues.amount = normalized;
            this.invalidate();
        }
    }
    get product(): { type: 'group', gid: number } | { type: 'donate_message', uid: number, cid: number, mid: number | null } | { type: 'donate_reaction', uid: number, mid: number } { return this._rawValue.product; }
    set product(value: { type: 'group', gid: number } | { type: 'donate_message', uid: number, cid: number, mid: number | null } | { type: 'donate_reaction', uid: number, mid: number }) {
        let normalized = this.descriptor.codec.fields.product.normalize(value);
        if (this._rawValue.product !== normalized) {
            this._rawValue.product = normalized;
            this._updatedValues.product = normalized;
            this.invalidate();
        }
    }
    get state(): 'pending' | 'canceled' | 'success' { return this._rawValue.state; }
    set state(value: 'pending' | 'canceled' | 'success') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
}

export class WalletPurchaseFactory extends EntityFactory<WalletPurchaseShape, WalletPurchase> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletPurchase');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletPurchase', 'user'), condition: (s) => !s.deleted });
        secondaryIndexes.push({ name: 'userSuccess', storageKey: 'userSuccess', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletPurchase', 'userSuccess'), condition: (s) => !s.deleted && s.state === 'success' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'pid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'txid', type: { type: 'string' }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'amount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'product', type: { type: 'union', types: { group: { gid: { type: 'integer' } }, donate_message: { uid: { type: 'integer' }, cid: { type: 'integer' }, mid: { type: 'optional', inner: { type: 'integer' } } }, donate_reaction: { uid: { type: 'integer' }, mid: { type: 'integer' } } } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['pending', 'canceled', 'success'] }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            pid: c.optional(c.string),
            txid: c.string,
            deleted: c.optional(c.boolean),
            amount: c.integer,
            product: c.union({ group: c.struct({ gid: c.integer }), donate_message: c.struct({ uid: c.integer, cid: c.integer, mid: c.optional(c.integer) }), donate_reaction: c.struct({ uid: c.integer, mid: c.integer }) }),
            state: c.enum('pending', 'canceled', 'success'),
        });
        let descriptor: EntityDescriptor<WalletPurchaseShape> = {
            name: 'WalletPurchase',
            storageKey: 'walletPurchase',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletPurchaseFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletPurchaseShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly userSuccess = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, id: string, src: WalletPurchaseCreateShape): Promise<WalletPurchase> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: WalletPurchaseCreateShape): WalletPurchase {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<WalletPurchase | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletPurchaseShape>): WalletPurchase {
        return new WalletPurchase([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletSubscriptionShape {
    id: string;
    uid: number;
    amount: number;
    interval: 'week' | 'month';
    start: number;
    proudct: { type: 'donate', uid: number } | { type: 'group', gid: number };
    state: 'started' | 'grace_period' | 'retrying' | 'canceled' | 'expired';
}

export interface WalletSubscriptionCreateShape {
    uid: number;
    amount: number;
    interval: 'week' | 'month';
    start: number;
    proudct: { type: 'donate', uid: number } | { type: 'group', gid: number };
    state: 'started' | 'grace_period' | 'retrying' | 'canceled' | 'expired';
}

export class WalletSubscription extends Entity<WalletSubscriptionShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get amount(): number { return this._rawValue.amount; }
    set amount(value: number) {
        let normalized = this.descriptor.codec.fields.amount.normalize(value);
        if (this._rawValue.amount !== normalized) {
            this._rawValue.amount = normalized;
            this._updatedValues.amount = normalized;
            this.invalidate();
        }
    }
    get interval(): 'week' | 'month' { return this._rawValue.interval; }
    set interval(value: 'week' | 'month') {
        let normalized = this.descriptor.codec.fields.interval.normalize(value);
        if (this._rawValue.interval !== normalized) {
            this._rawValue.interval = normalized;
            this._updatedValues.interval = normalized;
            this.invalidate();
        }
    }
    get start(): number { return this._rawValue.start; }
    set start(value: number) {
        let normalized = this.descriptor.codec.fields.start.normalize(value);
        if (this._rawValue.start !== normalized) {
            this._rawValue.start = normalized;
            this._updatedValues.start = normalized;
            this.invalidate();
        }
    }
    get proudct(): { type: 'donate', uid: number } | { type: 'group', gid: number } { return this._rawValue.proudct; }
    set proudct(value: { type: 'donate', uid: number } | { type: 'group', gid: number }) {
        let normalized = this.descriptor.codec.fields.proudct.normalize(value);
        if (this._rawValue.proudct !== normalized) {
            this._rawValue.proudct = normalized;
            this._updatedValues.proudct = normalized;
            this.invalidate();
        }
    }
    get state(): 'started' | 'grace_period' | 'retrying' | 'canceled' | 'expired' { return this._rawValue.state; }
    set state(value: 'started' | 'grace_period' | 'retrying' | 'canceled' | 'expired') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
}

export class WalletSubscriptionFactory extends EntityFactory<WalletSubscriptionShape, WalletSubscription> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletSubscription');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'active', storageKey: 'active', type: { type: 'range', fields: [{ name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('walletSubscription', 'active'), condition: (s) => s.state !== 'expired' });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('walletSubscription', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'amount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'interval', type: { type: 'enum', values: ['week', 'month'] }, secure: false });
        fields.push({ name: 'start', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'proudct', type: { type: 'union', types: { donate: { uid: { type: 'integer' } }, group: { gid: { type: 'integer' } } } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['started', 'grace_period', 'retrying', 'canceled', 'expired'] }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            amount: c.integer,
            interval: c.enum('week', 'month'),
            start: c.integer,
            proudct: c.union({ donate: c.struct({ uid: c.integer }), group: c.struct({ gid: c.integer }) }),
            state: c.enum('started', 'grace_period', 'retrying', 'canceled', 'expired'),
        });
        let descriptor: EntityDescriptor<WalletSubscriptionShape> = {
            name: 'WalletSubscription',
            storageKey: 'walletSubscription',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletSubscriptionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletSubscriptionShape>) {
        super(descriptor);
    }

    readonly active = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, id: string, src: WalletSubscriptionCreateShape): Promise<WalletSubscription> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: WalletSubscriptionCreateShape): WalletSubscription {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<WalletSubscription | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletSubscriptionShape>): WalletSubscription {
        return new WalletSubscription([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletSubscriptionSchedulingShape {
    id: string;
    currentPeriodIndex: number;
}

export interface WalletSubscriptionSchedulingCreateShape {
    currentPeriodIndex: number;
}

export class WalletSubscriptionScheduling extends Entity<WalletSubscriptionSchedulingShape> {
    get id(): string { return this._rawValue.id; }
    get currentPeriodIndex(): number { return this._rawValue.currentPeriodIndex; }
    set currentPeriodIndex(value: number) {
        let normalized = this.descriptor.codec.fields.currentPeriodIndex.normalize(value);
        if (this._rawValue.currentPeriodIndex !== normalized) {
            this._rawValue.currentPeriodIndex = normalized;
            this._updatedValues.currentPeriodIndex = normalized;
            this.invalidate();
        }
    }
}

export class WalletSubscriptionSchedulingFactory extends EntityFactory<WalletSubscriptionSchedulingShape, WalletSubscriptionScheduling> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletSubscriptionScheduling');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'currentPeriodIndex', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            id: c.string,
            currentPeriodIndex: c.integer,
        });
        let descriptor: EntityDescriptor<WalletSubscriptionSchedulingShape> = {
            name: 'WalletSubscriptionScheduling',
            storageKey: 'walletSubscriptionScheduling',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletSubscriptionSchedulingFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletSubscriptionSchedulingShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: WalletSubscriptionSchedulingCreateShape): Promise<WalletSubscriptionScheduling> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: WalletSubscriptionSchedulingCreateShape): WalletSubscriptionScheduling {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<WalletSubscriptionScheduling | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletSubscriptionSchedulingShape>): WalletSubscriptionScheduling {
        return new WalletSubscriptionScheduling([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface WalletSubscriptionPeriodShape {
    id: string;
    index: number;
    pid: string | null;
    start: number;
    state: 'pending' | 'failing' | 'success' | 'canceled';
    needCancel: boolean | null;
    scheduledCancel: boolean | null;
}

export interface WalletSubscriptionPeriodCreateShape {
    pid?: string | null | undefined;
    start: number;
    state: 'pending' | 'failing' | 'success' | 'canceled';
    needCancel?: boolean | null | undefined;
    scheduledCancel?: boolean | null | undefined;
}

export class WalletSubscriptionPeriod extends Entity<WalletSubscriptionPeriodShape> {
    get id(): string { return this._rawValue.id; }
    get index(): number { return this._rawValue.index; }
    get pid(): string | null { return this._rawValue.pid; }
    set pid(value: string | null) {
        let normalized = this.descriptor.codec.fields.pid.normalize(value);
        if (this._rawValue.pid !== normalized) {
            this._rawValue.pid = normalized;
            this._updatedValues.pid = normalized;
            this.invalidate();
        }
    }
    get start(): number { return this._rawValue.start; }
    set start(value: number) {
        let normalized = this.descriptor.codec.fields.start.normalize(value);
        if (this._rawValue.start !== normalized) {
            this._rawValue.start = normalized;
            this._updatedValues.start = normalized;
            this.invalidate();
        }
    }
    get state(): 'pending' | 'failing' | 'success' | 'canceled' { return this._rawValue.state; }
    set state(value: 'pending' | 'failing' | 'success' | 'canceled') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get needCancel(): boolean | null { return this._rawValue.needCancel; }
    set needCancel(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.needCancel.normalize(value);
        if (this._rawValue.needCancel !== normalized) {
            this._rawValue.needCancel = normalized;
            this._updatedValues.needCancel = normalized;
            this.invalidate();
        }
    }
    get scheduledCancel(): boolean | null { return this._rawValue.scheduledCancel; }
    set scheduledCancel(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.scheduledCancel.normalize(value);
        if (this._rawValue.scheduledCancel !== normalized) {
            this._rawValue.scheduledCancel = normalized;
            this._updatedValues.scheduledCancel = normalized;
            this.invalidate();
        }
    }
}

export class WalletSubscriptionPeriodFactory extends EntityFactory<WalletSubscriptionPeriodShape, WalletSubscriptionPeriod> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('walletSubscriptionPeriod');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'pendingCancel', storageKey: 'pendingCancel', type: { type: 'range', fields: [{ name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('walletSubscriptionPeriod', 'pendingCancel'), condition: (s) => s.needCancel && !s.scheduledCancel });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        primaryKeys.push({ name: 'index', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'pid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'start', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['pending', 'failing', 'success', 'canceled'] }, secure: false });
        fields.push({ name: 'needCancel', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        fields.push({ name: 'scheduledCancel', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            index: c.integer,
            pid: c.optional(c.string),
            start: c.integer,
            state: c.enum('pending', 'failing', 'success', 'canceled'),
            needCancel: c.optional(c.boolean),
            scheduledCancel: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<WalletSubscriptionPeriodShape> = {
            name: 'WalletSubscriptionPeriod',
            storageKey: 'walletSubscriptionPeriod',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new WalletSubscriptionPeriodFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<WalletSubscriptionPeriodShape>) {
        super(descriptor);
    }

    readonly pendingCancel = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: string, index: number, src: WalletSubscriptionPeriodCreateShape): Promise<WalletSubscriptionPeriod> {
        return this._create(ctx, [id, index], this.descriptor.codec.normalize({ id, index, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, index: number, src: WalletSubscriptionPeriodCreateShape): WalletSubscriptionPeriod {
        return this._create_UNSAFE(ctx, [id, index], this.descriptor.codec.normalize({ id, index, ...src }));
    }

    findById(ctx: Context, id: string, index: number): Promise<WalletSubscriptionPeriod | null> {
        return this._findById(ctx, [id, index]);
    }

    watch(ctx: Context, id: string, index: number): Watch {
        return this._watch(ctx, [id, index]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<WalletSubscriptionPeriodShape>): WalletSubscriptionPeriod {
        return new WalletSubscriptionPeriod([value.id, value.index], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PaymentIntentShape {
    id: string;
    state: 'pending' | 'success' | 'canceled';
    amount: number;
    operation: { type: 'deposit', uid: number } | { type: 'payment', id: string } | { type: 'purchase', id: string };
}

export interface PaymentIntentCreateShape {
    state: 'pending' | 'success' | 'canceled';
    amount: number;
    operation: { type: 'deposit', uid: number } | { type: 'payment', id: string } | { type: 'purchase', id: string };
}

export class PaymentIntent extends Entity<PaymentIntentShape> {
    get id(): string { return this._rawValue.id; }
    get state(): 'pending' | 'success' | 'canceled' { return this._rawValue.state; }
    set state(value: 'pending' | 'success' | 'canceled') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get amount(): number { return this._rawValue.amount; }
    set amount(value: number) {
        let normalized = this.descriptor.codec.fields.amount.normalize(value);
        if (this._rawValue.amount !== normalized) {
            this._rawValue.amount = normalized;
            this._updatedValues.amount = normalized;
            this.invalidate();
        }
    }
    get operation(): { type: 'deposit', uid: number } | { type: 'payment', id: string } | { type: 'purchase', id: string } { return this._rawValue.operation; }
    set operation(value: { type: 'deposit', uid: number } | { type: 'payment', id: string } | { type: 'purchase', id: string }) {
        let normalized = this.descriptor.codec.fields.operation.normalize(value);
        if (this._rawValue.operation !== normalized) {
            this._rawValue.operation = normalized;
            this._updatedValues.operation = normalized;
            this.invalidate();
        }
    }
}

export class PaymentIntentFactory extends EntityFactory<PaymentIntentShape, PaymentIntent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('paymentIntent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'state', type: { type: 'enum', values: ['pending', 'success', 'canceled'] }, secure: false });
        fields.push({ name: 'amount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'operation', type: { type: 'union', types: { deposit: { uid: { type: 'integer' } }, payment: { id: { type: 'string' } }, purchase: { id: { type: 'string' } } } }, secure: false });
        let codec = c.struct({
            id: c.string,
            state: c.enum('pending', 'success', 'canceled'),
            amount: c.integer,
            operation: c.union({ deposit: c.struct({ uid: c.integer }), payment: c.struct({ id: c.string }), purchase: c.struct({ id: c.string }) }),
        });
        let descriptor: EntityDescriptor<PaymentIntentShape> = {
            name: 'PaymentIntent',
            storageKey: 'paymentIntent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PaymentIntentFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PaymentIntentShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: PaymentIntentCreateShape): Promise<PaymentIntent> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PaymentIntentCreateShape): PaymentIntent {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PaymentIntent | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PaymentIntentShape>): PaymentIntent {
        return new PaymentIntent([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PaymentShape {
    id: string;
    uid: number;
    amount: number;
    state: 'pending' | 'success' | 'action_required' | 'failing' | 'canceled';
    operation: { type: 'deposit', uid: number, txid: string } | { type: 'subscription', uid: number, subscription: string, period: number, txid: string } | { type: 'transfer', fromUid: number, fromTx: string, toUid: number, toTx: string } | { type: 'purchase', id: string };
    piid: string | null;
}

export interface PaymentCreateShape {
    uid: number;
    amount: number;
    state: 'pending' | 'success' | 'action_required' | 'failing' | 'canceled';
    operation: { type: 'deposit', uid: number, txid: string } | { type: 'subscription', uid: number, subscription: string, period: number, txid: string } | { type: 'transfer', fromUid: number, fromTx: string, toUid: number, toTx: string } | { type: 'purchase', id: string };
    piid?: string | null | undefined;
}

export class Payment extends Entity<PaymentShape> {
    get id(): string { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get amount(): number { return this._rawValue.amount; }
    set amount(value: number) {
        let normalized = this.descriptor.codec.fields.amount.normalize(value);
        if (this._rawValue.amount !== normalized) {
            this._rawValue.amount = normalized;
            this._updatedValues.amount = normalized;
            this.invalidate();
        }
    }
    get state(): 'pending' | 'success' | 'action_required' | 'failing' | 'canceled' { return this._rawValue.state; }
    set state(value: 'pending' | 'success' | 'action_required' | 'failing' | 'canceled') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get operation(): { type: 'deposit', uid: number, txid: string } | { type: 'subscription', uid: number, subscription: string, period: number, txid: string } | { type: 'transfer', fromUid: number, fromTx: string, toUid: number, toTx: string } | { type: 'purchase', id: string } { return this._rawValue.operation; }
    set operation(value: { type: 'deposit', uid: number, txid: string } | { type: 'subscription', uid: number, subscription: string, period: number, txid: string } | { type: 'transfer', fromUid: number, fromTx: string, toUid: number, toTx: string } | { type: 'purchase', id: string }) {
        let normalized = this.descriptor.codec.fields.operation.normalize(value);
        if (this._rawValue.operation !== normalized) {
            this._rawValue.operation = normalized;
            this._updatedValues.operation = normalized;
            this.invalidate();
        }
    }
    get piid(): string | null { return this._rawValue.piid; }
    set piid(value: string | null) {
        let normalized = this.descriptor.codec.fields.piid.normalize(value);
        if (this._rawValue.piid !== normalized) {
            this._rawValue.piid = normalized;
            this._updatedValues.piid = normalized;
            this.invalidate();
        }
    }
}

export class PaymentFactory extends EntityFactory<PaymentShape, Payment> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('payment');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('payment', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'pending', storageKey: 'pending', type: { type: 'range', fields: [{ name: 'id', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('payment', 'pending'), condition: (s) => s.state === 'pending' || s.state === 'failing' });
        secondaryIndexes.push({ name: 'userFailing', storageKey: 'userFailing', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('payment', 'userFailing'), condition: (s) => s.state === 'failing' || s.state === 'action_required' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'amount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['pending', 'success', 'action_required', 'failing', 'canceled'] }, secure: false });
        fields.push({ name: 'operation', type: { type: 'union', types: { deposit: { uid: { type: 'integer' }, txid: { type: 'string' } }, subscription: { uid: { type: 'integer' }, subscription: { type: 'string' }, period: { type: 'integer' }, txid: { type: 'string' } }, transfer: { fromUid: { type: 'integer' }, fromTx: { type: 'string' }, toUid: { type: 'integer' }, toTx: { type: 'string' } }, purchase: { id: { type: 'string' } } } }, secure: false });
        fields.push({ name: 'piid', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            uid: c.integer,
            amount: c.integer,
            state: c.enum('pending', 'success', 'action_required', 'failing', 'canceled'),
            operation: c.union({ deposit: c.struct({ uid: c.integer, txid: c.string }), subscription: c.struct({ uid: c.integer, subscription: c.string, period: c.integer, txid: c.string }), transfer: c.struct({ fromUid: c.integer, fromTx: c.string, toUid: c.integer, toTx: c.string }), purchase: c.struct({ id: c.string }) }),
            piid: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<PaymentShape> = {
            name: 'Payment',
            storageKey: 'payment',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PaymentFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PaymentShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly pending = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    readonly userFailing = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [uid], opts);
        },
    });

    create(ctx: Context, id: string, src: PaymentCreateShape): Promise<Payment> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PaymentCreateShape): Payment {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<Payment | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PaymentShape>): Payment {
        return new Payment([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PaymentSchedulingShape {
    id: string;
    attempt: number;
    failuresCount: number;
    lastFailureDate: number | null;
    inProgress: boolean;
}

export interface PaymentSchedulingCreateShape {
    attempt: number;
    failuresCount: number;
    lastFailureDate?: number | null | undefined;
    inProgress: boolean;
}

export class PaymentScheduling extends Entity<PaymentSchedulingShape> {
    get id(): string { return this._rawValue.id; }
    get attempt(): number { return this._rawValue.attempt; }
    set attempt(value: number) {
        let normalized = this.descriptor.codec.fields.attempt.normalize(value);
        if (this._rawValue.attempt !== normalized) {
            this._rawValue.attempt = normalized;
            this._updatedValues.attempt = normalized;
            this.invalidate();
        }
    }
    get failuresCount(): number { return this._rawValue.failuresCount; }
    set failuresCount(value: number) {
        let normalized = this.descriptor.codec.fields.failuresCount.normalize(value);
        if (this._rawValue.failuresCount !== normalized) {
            this._rawValue.failuresCount = normalized;
            this._updatedValues.failuresCount = normalized;
            this.invalidate();
        }
    }
    get lastFailureDate(): number | null { return this._rawValue.lastFailureDate; }
    set lastFailureDate(value: number | null) {
        let normalized = this.descriptor.codec.fields.lastFailureDate.normalize(value);
        if (this._rawValue.lastFailureDate !== normalized) {
            this._rawValue.lastFailureDate = normalized;
            this._updatedValues.lastFailureDate = normalized;
            this.invalidate();
        }
    }
    get inProgress(): boolean { return this._rawValue.inProgress; }
    set inProgress(value: boolean) {
        let normalized = this.descriptor.codec.fields.inProgress.normalize(value);
        if (this._rawValue.inProgress !== normalized) {
            this._rawValue.inProgress = normalized;
            this._updatedValues.inProgress = normalized;
            this.invalidate();
        }
    }
}

export class PaymentSchedulingFactory extends EntityFactory<PaymentSchedulingShape, PaymentScheduling> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('paymentScheduling');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'attempt', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'failuresCount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'lastFailureDate', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'inProgress', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            attempt: c.integer,
            failuresCount: c.integer,
            lastFailureDate: c.optional(c.integer),
            inProgress: c.boolean,
        });
        let descriptor: EntityDescriptor<PaymentSchedulingShape> = {
            name: 'PaymentScheduling',
            storageKey: 'paymentScheduling',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PaymentSchedulingFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PaymentSchedulingShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: PaymentSchedulingCreateShape): Promise<PaymentScheduling> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: PaymentSchedulingCreateShape): PaymentScheduling {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<PaymentScheduling | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PaymentSchedulingShape>): PaymentScheduling {
        return new PaymentScheduling([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface StripeEventsCursorShape {
    id: string;
    cursor: string;
}

export interface StripeEventsCursorCreateShape {
    cursor: string;
}

export class StripeEventsCursor extends Entity<StripeEventsCursorShape> {
    get id(): string { return this._rawValue.id; }
    get cursor(): string { return this._rawValue.cursor; }
    set cursor(value: string) {
        let normalized = this.descriptor.codec.fields.cursor.normalize(value);
        if (this._rawValue.cursor !== normalized) {
            this._rawValue.cursor = normalized;
            this._updatedValues.cursor = normalized;
            this.invalidate();
        }
    }
}

export class StripeEventsCursorFactory extends EntityFactory<StripeEventsCursorShape, StripeEventsCursor> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('stripeEventsCursor');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cursor', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.string,
            cursor: c.string,
        });
        let descriptor: EntityDescriptor<StripeEventsCursorShape> = {
            name: 'StripeEventsCursor',
            storageKey: 'stripeEventsCursor',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new StripeEventsCursorFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<StripeEventsCursorShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: StripeEventsCursorCreateShape): Promise<StripeEventsCursor> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: StripeEventsCursorCreateShape): StripeEventsCursor {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<StripeEventsCursor | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<StripeEventsCursorShape>): StripeEventsCursor {
        return new StripeEventsCursor([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface StripeEventShape {
    id: string;
    type: string;
    data: any;
    date: number;
    liveMode: boolean;
}

export interface StripeEventCreateShape {
    type: string;
    data: any;
    date: number;
    liveMode: boolean;
}

export class StripeEvent extends Entity<StripeEventShape> {
    get id(): string { return this._rawValue.id; }
    get type(): string { return this._rawValue.type; }
    set type(value: string) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get data(): any { return this._rawValue.data; }
    set data(value: any) {
        let normalized = this.descriptor.codec.fields.data.normalize(value);
        if (this._rawValue.data !== normalized) {
            this._rawValue.data = normalized;
            this._updatedValues.data = normalized;
            this.invalidate();
        }
    }
    get date(): number { return this._rawValue.date; }
    set date(value: number) {
        let normalized = this.descriptor.codec.fields.date.normalize(value);
        if (this._rawValue.date !== normalized) {
            this._rawValue.date = normalized;
            this._updatedValues.date = normalized;
            this.invalidate();
        }
    }
    get liveMode(): boolean { return this._rawValue.liveMode; }
    set liveMode(value: boolean) {
        let normalized = this.descriptor.codec.fields.liveMode.normalize(value);
        if (this._rawValue.liveMode !== normalized) {
            this._rawValue.liveMode = normalized;
            this._updatedValues.liveMode = normalized;
            this.invalidate();
        }
    }
}

export class StripeEventFactory extends EntityFactory<StripeEventShape, StripeEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('stripeEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'type', type: { type: 'string' }, secure: false });
        fields.push({ name: 'data', type: { type: 'json' }, secure: false });
        fields.push({ name: 'date', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'liveMode', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            type: c.string,
            data: c.any,
            date: c.integer,
            liveMode: c.boolean,
        });
        let descriptor: EntityDescriptor<StripeEventShape> = {
            name: 'StripeEvent',
            storageKey: 'stripeEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new StripeEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<StripeEventShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: StripeEventCreateShape): Promise<StripeEvent> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: StripeEventCreateShape): StripeEvent {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<StripeEvent | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<StripeEventShape>): StripeEvent {
        return new StripeEvent([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface SequenceShape {
    sequence: string;
    value: number;
}

export interface SequenceCreateShape {
    value: number;
}

export class Sequence extends Entity<SequenceShape> {
    get sequence(): string { return this._rawValue.sequence; }
    get value(): number { return this._rawValue.value; }
    set value(value: number) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class SequenceFactory extends EntityFactory<SequenceShape, Sequence> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('sequence');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'sequence', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            sequence: c.string,
            value: c.integer,
        });
        let descriptor: EntityDescriptor<SequenceShape> = {
            name: 'Sequence',
            storageKey: 'sequence',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SequenceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SequenceShape>) {
        super(descriptor);
    }

    create(ctx: Context, sequence: string, src: SequenceCreateShape): Promise<Sequence> {
        return this._create(ctx, [sequence], this.descriptor.codec.normalize({ sequence, ...src }));
    }

    create_UNSAFE(ctx: Context, sequence: string, src: SequenceCreateShape): Sequence {
        return this._create_UNSAFE(ctx, [sequence], this.descriptor.codec.normalize({ sequence, ...src }));
    }

    findById(ctx: Context, sequence: string): Promise<Sequence | null> {
        return this._findById(ctx, [sequence]);
    }

    watch(ctx: Context, sequence: string): Watch {
        return this._watch(ctx, [sequence]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SequenceShape>): Sequence {
        return new Sequence([value.sequence], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EnvironmentShape {
    production: number;
    comment: string;
}

export interface EnvironmentCreateShape {
    comment: string;
}

export class Environment extends Entity<EnvironmentShape> {
    get production(): number { return this._rawValue.production; }
    get comment(): string { return this._rawValue.comment; }
    set comment(value: string) {
        let normalized = this.descriptor.codec.fields.comment.normalize(value);
        if (this._rawValue.comment !== normalized) {
            this._rawValue.comment = normalized;
            this._updatedValues.comment = normalized;
            this.invalidate();
        }
    }
}

export class EnvironmentFactory extends EntityFactory<EnvironmentShape, Environment> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('environment');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'production', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'comment', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            production: c.integer,
            comment: c.string,
        });
        let descriptor: EntityDescriptor<EnvironmentShape> = {
            name: 'Environment',
            storageKey: 'environment',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EnvironmentFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EnvironmentShape>) {
        super(descriptor);
    }

    create(ctx: Context, production: number, src: EnvironmentCreateShape): Promise<Environment> {
        return this._create(ctx, [production], this.descriptor.codec.normalize({ production, ...src }));
    }

    create_UNSAFE(ctx: Context, production: number, src: EnvironmentCreateShape): Environment {
        return this._create_UNSAFE(ctx, [production], this.descriptor.codec.normalize({ production, ...src }));
    }

    findById(ctx: Context, production: number): Promise<Environment | null> {
        return this._findById(ctx, [production]);
    }

    watch(ctx: Context, production: number): Watch {
        return this._watch(ctx, [production]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EnvironmentShape>): Environment {
        return new Environment([value.production], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EnvironmentVariableShape {
    name: string;
    value: string;
}

export interface EnvironmentVariableCreateShape {
    value: string;
}

export class EnvironmentVariable extends Entity<EnvironmentVariableShape> {
    get name(): string { return this._rawValue.name; }
    get value(): string { return this._rawValue.value; }
    set value(value: string) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class EnvironmentVariableFactory extends EntityFactory<EnvironmentVariableShape, EnvironmentVariable> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('environmentVariable');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'name', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            name: c.string,
            value: c.string,
        });
        let descriptor: EntityDescriptor<EnvironmentVariableShape> = {
            name: 'EnvironmentVariable',
            storageKey: 'environmentVariable',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EnvironmentVariableFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EnvironmentVariableShape>) {
        super(descriptor);
    }

    create(ctx: Context, name: string, src: EnvironmentVariableCreateShape): Promise<EnvironmentVariable> {
        return this._create(ctx, [name], this.descriptor.codec.normalize({ name, ...src }));
    }

    create_UNSAFE(ctx: Context, name: string, src: EnvironmentVariableCreateShape): EnvironmentVariable {
        return this._create_UNSAFE(ctx, [name], this.descriptor.codec.normalize({ name, ...src }));
    }

    findById(ctx: Context, name: string): Promise<EnvironmentVariable | null> {
        return this._findById(ctx, [name]);
    }

    watch(ctx: Context, name: string): Watch {
        return this._watch(ctx, [name]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EnvironmentVariableShape>): EnvironmentVariable {
        return new EnvironmentVariable([value.name], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ServiceCacheShape {
    service: string;
    key: string;
    value: string | null;
}

export interface ServiceCacheCreateShape {
    value?: string | null | undefined;
}

export class ServiceCache extends Entity<ServiceCacheShape> {
    get service(): string { return this._rawValue.service; }
    get key(): string { return this._rawValue.key; }
    get value(): string | null { return this._rawValue.value; }
    set value(value: string | null) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class ServiceCacheFactory extends EntityFactory<ServiceCacheShape, ServiceCache> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('serviceCache');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'fromService', storageKey: 'fromService', type: { type: 'range', fields: [{ name: 'service', type: 'string' }, { name: 'key', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('serviceCache', 'fromService'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'service', type: 'string' });
        primaryKeys.push({ name: 'key', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            service: c.string,
            key: c.string,
            value: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<ServiceCacheShape> = {
            name: 'ServiceCache',
            storageKey: 'serviceCache',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ServiceCacheFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ServiceCacheShape>) {
        super(descriptor);
    }

    readonly fromService = Object.freeze({
        findAll: async (ctx: Context, service: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [service])).items;
        },
        query: (ctx: Context, service: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [service], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (service: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [service], opts);
        },
        liveStream: (ctx: Context, service: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [service], opts);
        },
    });

    create(ctx: Context, service: string, key: string, src: ServiceCacheCreateShape): Promise<ServiceCache> {
        return this._create(ctx, [service, key], this.descriptor.codec.normalize({ service, key, ...src }));
    }

    create_UNSAFE(ctx: Context, service: string, key: string, src: ServiceCacheCreateShape): ServiceCache {
        return this._create_UNSAFE(ctx, [service, key], this.descriptor.codec.normalize({ service, key, ...src }));
    }

    findById(ctx: Context, service: string, key: string): Promise<ServiceCache | null> {
        return this._findById(ctx, [service, key]);
    }

    watch(ctx: Context, service: string, key: string): Watch {
        return this._watch(ctx, [service, key]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ServiceCacheShape>): ServiceCache {
        return new ServiceCache([value.service, value.key], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ReaderStateShape {
    id: string;
    cursor: string;
    version: number | null;
}

export interface ReaderStateCreateShape {
    cursor: string;
    version?: number | null | undefined;
}

export class ReaderState extends Entity<ReaderStateShape> {
    get id(): string { return this._rawValue.id; }
    get cursor(): string { return this._rawValue.cursor; }
    set cursor(value: string) {
        let normalized = this.descriptor.codec.fields.cursor.normalize(value);
        if (this._rawValue.cursor !== normalized) {
            this._rawValue.cursor = normalized;
            this._updatedValues.cursor = normalized;
            this.invalidate();
        }
    }
    get version(): number | null { return this._rawValue.version; }
    set version(value: number | null) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
}

export class ReaderStateFactory extends EntityFactory<ReaderStateShape, ReaderState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('readerState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cursor', type: { type: 'string' }, secure: false });
        fields.push({ name: 'version', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            cursor: c.string,
            version: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<ReaderStateShape> = {
            name: 'ReaderState',
            storageKey: 'readerState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ReaderStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ReaderStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: ReaderStateCreateShape): Promise<ReaderState> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: ReaderStateCreateShape): ReaderState {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<ReaderState | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ReaderStateShape>): ReaderState {
        return new ReaderState([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface SuperAdminShape {
    id: number;
    role: string;
    enabled: boolean;
}

export interface SuperAdminCreateShape {
    role: string;
    enabled: boolean;
}

export class SuperAdmin extends Entity<SuperAdminShape> {
    get id(): number { return this._rawValue.id; }
    get role(): string { return this._rawValue.role; }
    set role(value: string) {
        let normalized = this.descriptor.codec.fields.role.normalize(value);
        if (this._rawValue.role !== normalized) {
            this._rawValue.role = normalized;
            this._updatedValues.role = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class SuperAdminFactory extends EntityFactory<SuperAdminShape, SuperAdmin> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('superAdmin');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'role', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            role: c.string,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<SuperAdminShape> = {
            name: 'SuperAdmin',
            storageKey: 'superAdmin',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SuperAdminFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SuperAdminShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: SuperAdminCreateShape): Promise<SuperAdmin> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: SuperAdminCreateShape): SuperAdmin {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<SuperAdmin | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SuperAdminShape>): SuperAdmin {
        return new SuperAdmin([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface AuthTokenShape {
    uuid: string;
    salt: string;
    uid: number;
    lastIp: string;
    enabled: boolean | null;
}

export interface AuthTokenCreateShape {
    salt: string;
    uid: number;
    lastIp: string;
    enabled?: boolean | null | undefined;
}

export class AuthToken extends Entity<AuthTokenShape> {
    get uuid(): string { return this._rawValue.uuid; }
    get salt(): string { return this._rawValue.salt; }
    set salt(value: string) {
        let normalized = this.descriptor.codec.fields.salt.normalize(value);
        if (this._rawValue.salt !== normalized) {
            this._rawValue.salt = normalized;
            this._updatedValues.salt = normalized;
            this.invalidate();
        }
    }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get lastIp(): string { return this._rawValue.lastIp; }
    set lastIp(value: string) {
        let normalized = this.descriptor.codec.fields.lastIp.normalize(value);
        if (this._rawValue.lastIp !== normalized) {
            this._rawValue.lastIp = normalized;
            this._updatedValues.lastIp = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean | null { return this._rawValue.enabled; }
    set enabled(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class AuthTokenFactory extends EntityFactory<AuthTokenShape, AuthToken> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('authToken');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'salt', storageKey: 'salt', type: { type: 'unique', fields: [{ name: 'salt', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('authToken', 'salt'), condition: undefined });
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'uuid', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('authToken', 'user'), condition: src => src.enabled !== false });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uuid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'salt', type: { type: 'string' }, secure: false });
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'lastIp', type: { type: 'string' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            uuid: c.string,
            salt: c.string,
            uid: c.integer,
            lastIp: c.string,
            enabled: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<AuthTokenShape> = {
            name: 'AuthToken',
            storageKey: 'authToken',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AuthTokenFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AuthTokenShape>) {
        super(descriptor);
    }

    readonly salt = Object.freeze({
        find: async (ctx: Context, salt: string) => {
            return this._findFromUniqueIndex(ctx, [salt], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [uid], opts);
        },
    });

    create(ctx: Context, uuid: string, src: AuthTokenCreateShape): Promise<AuthToken> {
        return this._create(ctx, [uuid], this.descriptor.codec.normalize({ uuid, ...src }));
    }

    create_UNSAFE(ctx: Context, uuid: string, src: AuthTokenCreateShape): AuthToken {
        return this._create_UNSAFE(ctx, [uuid], this.descriptor.codec.normalize({ uuid, ...src }));
    }

    findById(ctx: Context, uuid: string): Promise<AuthToken | null> {
        return this._findById(ctx, [uuid]);
    }

    watch(ctx: Context, uuid: string): Watch {
        return this._watch(ctx, [uuid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AuthTokenShape>): AuthToken {
        return new AuthToken([value.uuid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface AuthCodeSessionShape {
    uid: string;
    code: string;
    expires: number;
    attemptsCount: number | null;
    email: string;
    tokenId: string | null;
    enabled: boolean;
}

export interface AuthCodeSessionCreateShape {
    code: string;
    expires: number;
    attemptsCount?: number | null | undefined;
    email: string;
    tokenId?: string | null | undefined;
    enabled: boolean;
}

export class AuthCodeSession extends Entity<AuthCodeSessionShape> {
    get uid(): string { return this._rawValue.uid; }
    get code(): string { return this._rawValue.code; }
    set code(value: string) {
        let normalized = this.descriptor.codec.fields.code.normalize(value);
        if (this._rawValue.code !== normalized) {
            this._rawValue.code = normalized;
            this._updatedValues.code = normalized;
            this.invalidate();
        }
    }
    get expires(): number { return this._rawValue.expires; }
    set expires(value: number) {
        let normalized = this.descriptor.codec.fields.expires.normalize(value);
        if (this._rawValue.expires !== normalized) {
            this._rawValue.expires = normalized;
            this._updatedValues.expires = normalized;
            this.invalidate();
        }
    }
    get attemptsCount(): number | null { return this._rawValue.attemptsCount; }
    set attemptsCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.attemptsCount.normalize(value);
        if (this._rawValue.attemptsCount !== normalized) {
            this._rawValue.attemptsCount = normalized;
            this._updatedValues.attemptsCount = normalized;
            this.invalidate();
        }
    }
    get email(): string { return this._rawValue.email; }
    set email(value: string) {
        let normalized = this.descriptor.codec.fields.email.normalize(value);
        if (this._rawValue.email !== normalized) {
            this._rawValue.email = normalized;
            this._updatedValues.email = normalized;
            this.invalidate();
        }
    }
    get tokenId(): string | null { return this._rawValue.tokenId; }
    set tokenId(value: string | null) {
        let normalized = this.descriptor.codec.fields.tokenId.normalize(value);
        if (this._rawValue.tokenId !== normalized) {
            this._rawValue.tokenId = normalized;
            this._updatedValues.tokenId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class AuthCodeSessionFactory extends EntityFactory<AuthCodeSessionShape, AuthCodeSession> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('authCodeSession');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'code', type: { type: 'string' }, secure: true });
        fields.push({ name: 'expires', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'attemptsCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'email', type: { type: 'string' }, secure: false });
        fields.push({ name: 'tokenId', type: { type: 'optional', inner: { type: 'string' } }, secure: true });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            uid: c.string,
            code: c.string,
            expires: c.integer,
            attemptsCount: c.optional(c.integer),
            email: c.string,
            tokenId: c.optional(c.string),
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<AuthCodeSessionShape> = {
            name: 'AuthCodeSession',
            storageKey: 'authCodeSession',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new AuthCodeSessionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<AuthCodeSessionShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: string, src: AuthCodeSessionCreateShape): Promise<AuthCodeSession> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: string, src: AuthCodeSessionCreateShape): AuthCodeSession {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: string): Promise<AuthCodeSession | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: string): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<AuthCodeSessionShape>): AuthCodeSession {
        return new AuthCodeSession([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface FeatureFlagShape {
    key: string;
    title: string;
}

export interface FeatureFlagCreateShape {
    title: string;
}

export class FeatureFlag extends Entity<FeatureFlagShape> {
    get key(): string { return this._rawValue.key; }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
}

export class FeatureFlagFactory extends EntityFactory<FeatureFlagShape, FeatureFlag> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('featureFlag');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'key', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            key: c.string,
            title: c.string,
        });
        let descriptor: EntityDescriptor<FeatureFlagShape> = {
            name: 'FeatureFlag',
            storageKey: 'featureFlag',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new FeatureFlagFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<FeatureFlagShape>) {
        super(descriptor);
    }

    create(ctx: Context, key: string, src: FeatureFlagCreateShape): Promise<FeatureFlag> {
        return this._create(ctx, [key], this.descriptor.codec.normalize({ key, ...src }));
    }

    create_UNSAFE(ctx: Context, key: string, src: FeatureFlagCreateShape): FeatureFlag {
        return this._create_UNSAFE(ctx, [key], this.descriptor.codec.normalize({ key, ...src }));
    }

    findById(ctx: Context, key: string): Promise<FeatureFlag | null> {
        return this._findById(ctx, [key]);
    }

    watch(ctx: Context, key: string): Watch {
        return this._watch(ctx, [key]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<FeatureFlagShape>): FeatureFlag {
        return new FeatureFlag([value.key], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OrganizationFeaturesShape {
    id: string;
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export interface OrganizationFeaturesCreateShape {
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export class OrganizationFeatures extends Entity<OrganizationFeaturesShape> {
    get id(): string { return this._rawValue.id; }
    get featureKey(): string { return this._rawValue.featureKey; }
    set featureKey(value: string) {
        let normalized = this.descriptor.codec.fields.featureKey.normalize(value);
        if (this._rawValue.featureKey !== normalized) {
            this._rawValue.featureKey = normalized;
            this._updatedValues.featureKey = normalized;
            this.invalidate();
        }
    }
    get organizationId(): number { return this._rawValue.organizationId; }
    set organizationId(value: number) {
        let normalized = this.descriptor.codec.fields.organizationId.normalize(value);
        if (this._rawValue.organizationId !== normalized) {
            this._rawValue.organizationId = normalized;
            this._updatedValues.organizationId = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class OrganizationFeaturesFactory extends EntityFactory<OrganizationFeaturesShape, OrganizationFeatures> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('organizationFeatures');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'organization', storageKey: 'organization', type: { type: 'unique', fields: [{ name: 'organizationId', type: 'integer' }, { name: 'featureKey', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('organizationFeatures', 'organization'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'featureKey', type: { type: 'string' }, secure: false });
        fields.push({ name: 'organizationId', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            id: c.string,
            featureKey: c.string,
            organizationId: c.integer,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<OrganizationFeaturesShape> = {
            name: 'OrganizationFeatures',
            storageKey: 'organizationFeatures',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OrganizationFeaturesFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OrganizationFeaturesShape>) {
        super(descriptor);
    }

    readonly organization = Object.freeze({
        find: async (ctx: Context, organizationId: number, featureKey: string) => {
            return this._findFromUniqueIndex(ctx, [organizationId, featureKey], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, organizationId: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [organizationId])).items;
        },
        query: (ctx: Context, organizationId: number, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [organizationId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: string, src: OrganizationFeaturesCreateShape): Promise<OrganizationFeatures> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: OrganizationFeaturesCreateShape): OrganizationFeatures {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<OrganizationFeatures | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OrganizationFeaturesShape>): OrganizationFeatures {
        return new OrganizationFeatures([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface HyperLogShape {
    id: string;
    type: string;
    date: number;
    body: any;
}

export interface HyperLogCreateShape {
    type: string;
    date: number;
    body: any;
}

export class HyperLog extends Entity<HyperLogShape> {
    get id(): string { return this._rawValue.id; }
    get type(): string { return this._rawValue.type; }
    set type(value: string) {
        let normalized = this.descriptor.codec.fields.type.normalize(value);
        if (this._rawValue.type !== normalized) {
            this._rawValue.type = normalized;
            this._updatedValues.type = normalized;
            this.invalidate();
        }
    }
    get date(): number { return this._rawValue.date; }
    set date(value: number) {
        let normalized = this.descriptor.codec.fields.date.normalize(value);
        if (this._rawValue.date !== normalized) {
            this._rawValue.date = normalized;
            this._updatedValues.date = normalized;
            this.invalidate();
        }
    }
    get body(): any { return this._rawValue.body; }
    set body(value: any) {
        let normalized = this.descriptor.codec.fields.body.normalize(value);
        if (this._rawValue.body !== normalized) {
            this._rawValue.body = normalized;
            this._updatedValues.body = normalized;
            this.invalidate();
        }
    }

    delete(ctx: Context) {
        return this._delete(ctx);
    }
}

export class HyperLogFactory extends EntityFactory<HyperLogShape, HyperLog> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('hyperLog');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('hyperLog', 'created'), condition: undefined });
        secondaryIndexes.push({ name: 'userEvents', storageKey: 'userEvents', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('hyperLog', 'userEvents'), condition: (src) => src.type === 'track' });
        secondaryIndexes.push({ name: 'onlineChangeEvents', storageKey: 'onlineChangeEvents', type: { type: 'range', fields: [{ name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('hyperLog', 'onlineChangeEvents'), condition: (src) => src.type === 'online_status' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'type', type: { type: 'string' }, secure: false });
        fields.push({ name: 'date', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'body', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            id: c.string,
            type: c.string,
            date: c.integer,
            body: c.any,
        });
        let descriptor: EntityDescriptor<HyperLogShape> = {
            name: 'HyperLog',
            storageKey: 'hyperLog',
            allowDelete: true,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new HyperLogFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<HyperLogShape>) {
        super(descriptor);
    }

    readonly created = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly userEvents = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    readonly onlineChangeEvents = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    create(ctx: Context, id: string, src: HyperLogCreateShape): Promise<HyperLog> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: HyperLogCreateShape): HyperLog {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<HyperLog | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<HyperLogShape>): HyperLog {
        return new HyperLog([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface HyperLogTypeShape {
    name: string;
    count: number;
}

export interface HyperLogTypeCreateShape {
    count: number;
}

export class HyperLogType extends Entity<HyperLogTypeShape> {
    get name(): string { return this._rawValue.name; }
    get count(): number { return this._rawValue.count; }
    set count(value: number) {
        let normalized = this.descriptor.codec.fields.count.normalize(value);
        if (this._rawValue.count !== normalized) {
            this._rawValue.count = normalized;
            this._updatedValues.count = normalized;
            this.invalidate();
        }
    }
}

export class HyperLogTypeFactory extends EntityFactory<HyperLogTypeShape, HyperLogType> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('hyperLogType');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'name', storageKey: 'name', type: { type: 'range', fields: [{ name: 'name', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('hyperLogType', 'name'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'name', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'count', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            name: c.string,
            count: c.integer,
        });
        let descriptor: EntityDescriptor<HyperLogTypeShape> = {
            name: 'HyperLogType',
            storageKey: 'hyperLogType',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new HyperLogTypeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<HyperLogTypeShape>) {
        super(descriptor);
    }

    readonly name = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, name: string, src: HyperLogTypeCreateShape): Promise<HyperLogType> {
        return this._create(ctx, [name], this.descriptor.codec.normalize({ name, ...src }));
    }

    create_UNSAFE(ctx: Context, name: string, src: HyperLogTypeCreateShape): HyperLogType {
        return this._create_UNSAFE(ctx, [name], this.descriptor.codec.normalize({ name, ...src }));
    }

    findById(ctx: Context, name: string): Promise<HyperLogType | null> {
        return this._findById(ctx, [name]);
    }

    watch(ctx: Context, name: string): Watch {
        return this._watch(ctx, [name]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<HyperLogTypeShape>): HyperLogType {
        return new HyperLogType([value.name], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface TaskShape {
    taskType: string;
    uid: string;
    arguments: any;
    result: any;
    startAt: number | null;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskMaxFailureCount: number | null;
    taskFailureCount: number | null;
    taskFailureTime: number | null;
    taskLockSeed: string | null;
    taskLockTimeout: number | null;
    taskFailureMessage: string | null;
}

export interface TaskCreateShape {
    arguments: any;
    result: any;
    startAt?: number | null | undefined;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskMaxFailureCount?: number | null | undefined;
    taskFailureCount?: number | null | undefined;
    taskFailureTime?: number | null | undefined;
    taskLockSeed?: string | null | undefined;
    taskLockTimeout?: number | null | undefined;
    taskFailureMessage?: string | null | undefined;
}

export class Task extends Entity<TaskShape> {
    get taskType(): string { return this._rawValue.taskType; }
    get uid(): string { return this._rawValue.uid; }
    get arguments(): any { return this._rawValue.arguments; }
    set arguments(value: any) {
        let normalized = this.descriptor.codec.fields.arguments.normalize(value);
        if (this._rawValue.arguments !== normalized) {
            this._rawValue.arguments = normalized;
            this._updatedValues.arguments = normalized;
            this.invalidate();
        }
    }
    get result(): any { return this._rawValue.result; }
    set result(value: any) {
        let normalized = this.descriptor.codec.fields.result.normalize(value);
        if (this._rawValue.result !== normalized) {
            this._rawValue.result = normalized;
            this._updatedValues.result = normalized;
            this.invalidate();
        }
    }
    get startAt(): number | null { return this._rawValue.startAt; }
    set startAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.startAt.normalize(value);
        if (this._rawValue.startAt !== normalized) {
            this._rawValue.startAt = normalized;
            this._updatedValues.startAt = normalized;
            this.invalidate();
        }
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' { return this._rawValue.taskStatus; }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        let normalized = this.descriptor.codec.fields.taskStatus.normalize(value);
        if (this._rawValue.taskStatus !== normalized) {
            this._rawValue.taskStatus = normalized;
            this._updatedValues.taskStatus = normalized;
            this.invalidate();
        }
    }
    get taskMaxFailureCount(): number | null { return this._rawValue.taskMaxFailureCount; }
    set taskMaxFailureCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.taskMaxFailureCount.normalize(value);
        if (this._rawValue.taskMaxFailureCount !== normalized) {
            this._rawValue.taskMaxFailureCount = normalized;
            this._updatedValues.taskMaxFailureCount = normalized;
            this.invalidate();
        }
    }
    get taskFailureCount(): number | null { return this._rawValue.taskFailureCount; }
    set taskFailureCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.taskFailureCount.normalize(value);
        if (this._rawValue.taskFailureCount !== normalized) {
            this._rawValue.taskFailureCount = normalized;
            this._updatedValues.taskFailureCount = normalized;
            this.invalidate();
        }
    }
    get taskFailureTime(): number | null { return this._rawValue.taskFailureTime; }
    set taskFailureTime(value: number | null) {
        let normalized = this.descriptor.codec.fields.taskFailureTime.normalize(value);
        if (this._rawValue.taskFailureTime !== normalized) {
            this._rawValue.taskFailureTime = normalized;
            this._updatedValues.taskFailureTime = normalized;
            this.invalidate();
        }
    }
    get taskLockSeed(): string | null { return this._rawValue.taskLockSeed; }
    set taskLockSeed(value: string | null) {
        let normalized = this.descriptor.codec.fields.taskLockSeed.normalize(value);
        if (this._rawValue.taskLockSeed !== normalized) {
            this._rawValue.taskLockSeed = normalized;
            this._updatedValues.taskLockSeed = normalized;
            this.invalidate();
        }
    }
    get taskLockTimeout(): number | null { return this._rawValue.taskLockTimeout; }
    set taskLockTimeout(value: number | null) {
        let normalized = this.descriptor.codec.fields.taskLockTimeout.normalize(value);
        if (this._rawValue.taskLockTimeout !== normalized) {
            this._rawValue.taskLockTimeout = normalized;
            this._updatedValues.taskLockTimeout = normalized;
            this.invalidate();
        }
    }
    get taskFailureMessage(): string | null { return this._rawValue.taskFailureMessage; }
    set taskFailureMessage(value: string | null) {
        let normalized = this.descriptor.codec.fields.taskFailureMessage.normalize(value);
        if (this._rawValue.taskFailureMessage !== normalized) {
            this._rawValue.taskFailureMessage = normalized;
            this._updatedValues.taskFailureMessage = normalized;
            this.invalidate();
        }
    }

    delete(ctx: Context) {
        return this._delete(ctx);
    }
}

export class TaskFactory extends EntityFactory<TaskShape, Task> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('task');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'pending', storageKey: 'pending', type: { type: 'range', fields: [{ name: 'taskType', type: 'string' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('task', 'pending'), condition: (src) => src.taskStatus === 'pending' && !src.startAt });
        secondaryIndexes.push({ name: 'delayedPending', storageKey: 'delayedPending', type: { type: 'range', fields: [{ name: 'taskType', type: 'string' }, { name: 'startAt', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('task', 'delayedPending'), condition: (src) => src.taskStatus === 'pending' && !!src.startAt });
        secondaryIndexes.push({ name: 'executing', storageKey: 'executing', type: { type: 'range', fields: [{ name: 'taskLockTimeout', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('task', 'executing'), condition: (src) => src.taskStatus === 'executing' });
        secondaryIndexes.push({ name: 'failing', storageKey: 'failing', type: { type: 'range', fields: [{ name: 'taskFailureTime', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('task', 'failing'), condition: (src) => src.taskStatus === 'failing' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'taskType', type: 'string' });
        primaryKeys.push({ name: 'uid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'arguments', type: { type: 'json' }, secure: false });
        fields.push({ name: 'result', type: { type: 'json' }, secure: false });
        fields.push({ name: 'startAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskStatus', type: { type: 'enum', values: ['pending', 'executing', 'failing', 'failed', 'completed'] }, secure: false });
        fields.push({ name: 'taskMaxFailureCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskFailureCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskFailureTime', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskLockSeed', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'taskLockTimeout', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskFailureMessage', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            taskType: c.string,
            uid: c.string,
            arguments: c.any,
            result: c.any,
            startAt: c.optional(c.integer),
            taskStatus: c.enum('pending', 'executing', 'failing', 'failed', 'completed'),
            taskMaxFailureCount: c.optional(c.integer),
            taskFailureCount: c.optional(c.integer),
            taskFailureTime: c.optional(c.integer),
            taskLockSeed: c.optional(c.string),
            taskLockTimeout: c.optional(c.integer),
            taskFailureMessage: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<TaskShape> = {
            name: 'Task',
            storageKey: 'task',
            allowDelete: true,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new TaskFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<TaskShape>) {
        super(descriptor);
    }

    readonly pending = Object.freeze({
        findAll: async (ctx: Context, taskType: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [taskType])).items;
        },
        query: (ctx: Context, taskType: string, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [taskType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (taskType: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [taskType], opts);
        },
        liveStream: (ctx: Context, taskType: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [taskType], opts);
        },
    });

    readonly delayedPending = Object.freeze({
        findAll: async (ctx: Context, taskType: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [taskType])).items;
        },
        query: (ctx: Context, taskType: string, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [taskType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (taskType: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [taskType], opts);
        },
        liveStream: (ctx: Context, taskType: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [taskType], opts);
        },
    });

    readonly executing = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[2], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[2], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[2], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[2], [], opts);
        },
    });

    readonly failing = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[3], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[3], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[3], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[3], [], opts);
        },
    });

    create(ctx: Context, taskType: string, uid: string, src: TaskCreateShape): Promise<Task> {
        return this._create(ctx, [taskType, uid], this.descriptor.codec.normalize({ taskType, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, taskType: string, uid: string, src: TaskCreateShape): Task {
        return this._create_UNSAFE(ctx, [taskType, uid], this.descriptor.codec.normalize({ taskType, uid, ...src }));
    }

    findById(ctx: Context, taskType: string, uid: string): Promise<Task | null> {
        return this._findById(ctx, [taskType, uid]);
    }

    watch(ctx: Context, taskType: string, uid: string): Watch {
        return this._watch(ctx, [taskType, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<TaskShape>): Task {
        return new Task([value.taskType, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DelayedTaskShape {
    taskType: string;
    uid: string;
    delay: number;
    arguments: any;
    result: any | null;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureTime: number | null;
    taskFailureMessage: string | null;
}

export interface DelayedTaskCreateShape {
    delay: number;
    arguments: any;
    result?: any | null | undefined;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureTime?: number | null | undefined;
    taskFailureMessage?: string | null | undefined;
}

export class DelayedTask extends Entity<DelayedTaskShape> {
    get taskType(): string { return this._rawValue.taskType; }
    get uid(): string { return this._rawValue.uid; }
    get delay(): number { return this._rawValue.delay; }
    set delay(value: number) {
        let normalized = this.descriptor.codec.fields.delay.normalize(value);
        if (this._rawValue.delay !== normalized) {
            this._rawValue.delay = normalized;
            this._updatedValues.delay = normalized;
            this.invalidate();
        }
    }
    get arguments(): any { return this._rawValue.arguments; }
    set arguments(value: any) {
        let normalized = this.descriptor.codec.fields.arguments.normalize(value);
        if (this._rawValue.arguments !== normalized) {
            this._rawValue.arguments = normalized;
            this._updatedValues.arguments = normalized;
            this.invalidate();
        }
    }
    get result(): any | null { return this._rawValue.result; }
    set result(value: any | null) {
        let normalized = this.descriptor.codec.fields.result.normalize(value);
        if (this._rawValue.result !== normalized) {
            this._rawValue.result = normalized;
            this._updatedValues.result = normalized;
            this.invalidate();
        }
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' { return this._rawValue.taskStatus; }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        let normalized = this.descriptor.codec.fields.taskStatus.normalize(value);
        if (this._rawValue.taskStatus !== normalized) {
            this._rawValue.taskStatus = normalized;
            this._updatedValues.taskStatus = normalized;
            this.invalidate();
        }
    }
    get taskFailureTime(): number | null { return this._rawValue.taskFailureTime; }
    set taskFailureTime(value: number | null) {
        let normalized = this.descriptor.codec.fields.taskFailureTime.normalize(value);
        if (this._rawValue.taskFailureTime !== normalized) {
            this._rawValue.taskFailureTime = normalized;
            this._updatedValues.taskFailureTime = normalized;
            this.invalidate();
        }
    }
    get taskFailureMessage(): string | null { return this._rawValue.taskFailureMessage; }
    set taskFailureMessage(value: string | null) {
        let normalized = this.descriptor.codec.fields.taskFailureMessage.normalize(value);
        if (this._rawValue.taskFailureMessage !== normalized) {
            this._rawValue.taskFailureMessage = normalized;
            this._updatedValues.taskFailureMessage = normalized;
            this.invalidate();
        }
    }
}

export class DelayedTaskFactory extends EntityFactory<DelayedTaskShape, DelayedTask> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('delayedTask');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'pending', storageKey: 'pending', type: { type: 'range', fields: [{ name: 'taskType', type: 'string' }, { name: 'delay', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('delayedTask', 'pending'), condition: (src) => src.taskStatus === 'pending' });
        secondaryIndexes.push({ name: 'failing', storageKey: 'failing', type: { type: 'range', fields: [{ name: 'taskFailureTime', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('delayedTask', 'failing'), condition: (src) => src.taskStatus === 'failing' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'taskType', type: 'string' });
        primaryKeys.push({ name: 'uid', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'delay', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'arguments', type: { type: 'json' }, secure: false });
        fields.push({ name: 'result', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'taskStatus', type: { type: 'enum', values: ['pending', 'executing', 'failing', 'failed', 'completed'] }, secure: false });
        fields.push({ name: 'taskFailureTime', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'taskFailureMessage', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            taskType: c.string,
            uid: c.string,
            delay: c.integer,
            arguments: c.any,
            result: c.optional(c.any),
            taskStatus: c.enum('pending', 'executing', 'failing', 'failed', 'completed'),
            taskFailureTime: c.optional(c.integer),
            taskFailureMessage: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<DelayedTaskShape> = {
            name: 'DelayedTask',
            storageKey: 'delayedTask',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DelayedTaskFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DelayedTaskShape>) {
        super(descriptor);
    }

    readonly pending = Object.freeze({
        findAll: async (ctx: Context, taskType: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [taskType])).items;
        },
        query: (ctx: Context, taskType: string, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [taskType], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (taskType: string, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [taskType], opts);
        },
        liveStream: (ctx: Context, taskType: string, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [taskType], opts);
        },
    });

    readonly failing = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, taskType: string, uid: string, src: DelayedTaskCreateShape): Promise<DelayedTask> {
        return this._create(ctx, [taskType, uid], this.descriptor.codec.normalize({ taskType, uid, ...src }));
    }

    create_UNSAFE(ctx: Context, taskType: string, uid: string, src: DelayedTaskCreateShape): DelayedTask {
        return this._create_UNSAFE(ctx, [taskType, uid], this.descriptor.codec.normalize({ taskType, uid, ...src }));
    }

    findById(ctx: Context, taskType: string, uid: string): Promise<DelayedTask | null> {
        return this._findById(ctx, [taskType, uid]);
    }

    watch(ctx: Context, taskType: string, uid: string): Watch {
        return this._watch(ctx, [taskType, uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DelayedTaskShape>): DelayedTask {
        return new DelayedTask([value.taskType, value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ServiceThrottleShape {
    service: string;
    key: string;
    lastFireTime: number;
    firedCount: number;
}

export interface ServiceThrottleCreateShape {
    lastFireTime: number;
    firedCount: number;
}

export class ServiceThrottle extends Entity<ServiceThrottleShape> {
    get service(): string { return this._rawValue.service; }
    get key(): string { return this._rawValue.key; }
    get lastFireTime(): number { return this._rawValue.lastFireTime; }
    set lastFireTime(value: number) {
        let normalized = this.descriptor.codec.fields.lastFireTime.normalize(value);
        if (this._rawValue.lastFireTime !== normalized) {
            this._rawValue.lastFireTime = normalized;
            this._updatedValues.lastFireTime = normalized;
            this.invalidate();
        }
    }
    get firedCount(): number { return this._rawValue.firedCount; }
    set firedCount(value: number) {
        let normalized = this.descriptor.codec.fields.firedCount.normalize(value);
        if (this._rawValue.firedCount !== normalized) {
            this._rawValue.firedCount = normalized;
            this._updatedValues.firedCount = normalized;
            this.invalidate();
        }
    }
}

export class ServiceThrottleFactory extends EntityFactory<ServiceThrottleShape, ServiceThrottle> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('serviceThrottle');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'service', type: 'string' });
        primaryKeys.push({ name: 'key', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastFireTime', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'firedCount', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            service: c.string,
            key: c.string,
            lastFireTime: c.integer,
            firedCount: c.integer,
        });
        let descriptor: EntityDescriptor<ServiceThrottleShape> = {
            name: 'ServiceThrottle',
            storageKey: 'serviceThrottle',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ServiceThrottleFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ServiceThrottleShape>) {
        super(descriptor);
    }

    create(ctx: Context, service: string, key: string, src: ServiceThrottleCreateShape): Promise<ServiceThrottle> {
        return this._create(ctx, [service, key], this.descriptor.codec.normalize({ service, key, ...src }));
    }

    create_UNSAFE(ctx: Context, service: string, key: string, src: ServiceThrottleCreateShape): ServiceThrottle {
        return this._create_UNSAFE(ctx, [service, key], this.descriptor.codec.normalize({ service, key, ...src }));
    }

    findById(ctx: Context, service: string, key: string): Promise<ServiceThrottle | null> {
        return this._findById(ctx, [service, key]);
    }

    watch(ctx: Context, service: string, key: string): Watch {
        return this._watch(ctx, [service, key]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ServiceThrottleShape>): ServiceThrottle {
        return new ServiceThrottle([value.service, value.key], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface OneTimeCodeShape {
    service: string;
    id: string;
    code: string;
    expires: number;
    attemptsCount: number;
    data: any;
    enabled: boolean;
}

export interface OneTimeCodeCreateShape {
    code: string;
    expires: number;
    attemptsCount: number;
    data: any;
    enabled: boolean;
}

export class OneTimeCode extends Entity<OneTimeCodeShape> {
    get service(): string { return this._rawValue.service; }
    get id(): string { return this._rawValue.id; }
    get code(): string { return this._rawValue.code; }
    set code(value: string) {
        let normalized = this.descriptor.codec.fields.code.normalize(value);
        if (this._rawValue.code !== normalized) {
            this._rawValue.code = normalized;
            this._updatedValues.code = normalized;
            this.invalidate();
        }
    }
    get expires(): number { return this._rawValue.expires; }
    set expires(value: number) {
        let normalized = this.descriptor.codec.fields.expires.normalize(value);
        if (this._rawValue.expires !== normalized) {
            this._rawValue.expires = normalized;
            this._updatedValues.expires = normalized;
            this.invalidate();
        }
    }
    get attemptsCount(): number { return this._rawValue.attemptsCount; }
    set attemptsCount(value: number) {
        let normalized = this.descriptor.codec.fields.attemptsCount.normalize(value);
        if (this._rawValue.attemptsCount !== normalized) {
            this._rawValue.attemptsCount = normalized;
            this._updatedValues.attemptsCount = normalized;
            this.invalidate();
        }
    }
    get data(): any { return this._rawValue.data; }
    set data(value: any) {
        let normalized = this.descriptor.codec.fields.data.normalize(value);
        if (this._rawValue.data !== normalized) {
            this._rawValue.data = normalized;
            this._updatedValues.data = normalized;
            this.invalidate();
        }
    }
    get enabled(): boolean { return this._rawValue.enabled; }
    set enabled(value: boolean) {
        let normalized = this.descriptor.codec.fields.enabled.normalize(value);
        if (this._rawValue.enabled !== normalized) {
            this._rawValue.enabled = normalized;
            this._updatedValues.enabled = normalized;
            this.invalidate();
        }
    }
}

export class OneTimeCodeFactory extends EntityFactory<OneTimeCodeShape, OneTimeCode> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('oneTimeCode');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'code', storageKey: 'code', type: { type: 'unique', fields: [{ name: 'service', type: 'string' }, { name: 'code', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('oneTimeCode', 'code'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'service', type: 'string' });
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'code', type: { type: 'string' }, secure: true });
        fields.push({ name: 'expires', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'attemptsCount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'data', type: { type: 'json' }, secure: false });
        fields.push({ name: 'enabled', type: { type: 'boolean' }, secure: false });
        let codec = c.struct({
            service: c.string,
            id: c.string,
            code: c.string,
            expires: c.integer,
            attemptsCount: c.integer,
            data: c.any,
            enabled: c.boolean,
        });
        let descriptor: EntityDescriptor<OneTimeCodeShape> = {
            name: 'OneTimeCode',
            storageKey: 'oneTimeCode',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new OneTimeCodeFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<OneTimeCodeShape>) {
        super(descriptor);
    }

    readonly code = Object.freeze({
        find: async (ctx: Context, service: string, code: string) => {
            return this._findFromUniqueIndex(ctx, [service, code], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context, service: string) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [service])).items;
        },
        query: (ctx: Context, service: string, opts?: RangeQueryOptions<string>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [service], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, service: string, id: string, src: OneTimeCodeCreateShape): Promise<OneTimeCode> {
        return this._create(ctx, [service, id], this.descriptor.codec.normalize({ service, id, ...src }));
    }

    create_UNSAFE(ctx: Context, service: string, id: string, src: OneTimeCodeCreateShape): OneTimeCode {
        return this._create_UNSAFE(ctx, [service, id], this.descriptor.codec.normalize({ service, id, ...src }));
    }

    findById(ctx: Context, service: string, id: string): Promise<OneTimeCode | null> {
        return this._findById(ctx, [service, id]);
    }

    watch(ctx: Context, service: string, id: string): Watch {
        return this._watch(ctx, [service, id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<OneTimeCodeShape>): OneTimeCode {
        return new OneTimeCode([value.service, value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DebugEventShape {
    uid: number;
    seq: number;
    key: string | null;
}

export interface DebugEventCreateShape {
    key?: string | null | undefined;
}

export class DebugEvent extends Entity<DebugEventShape> {
    get uid(): number { return this._rawValue.uid; }
    get seq(): number { return this._rawValue.seq; }
    get key(): string | null { return this._rawValue.key; }
    set key(value: string | null) {
        let normalized = this.descriptor.codec.fields.key.normalize(value);
        if (this._rawValue.key !== normalized) {
            this._rawValue.key = normalized;
            this._updatedValues.key = normalized;
            this.invalidate();
        }
    }
}

export class DebugEventFactory extends EntityFactory<DebugEventShape, DebugEvent> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('debugEvent');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'seq', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('debugEvent', 'user'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'seq', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'key', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            seq: c.integer,
            key: c.optional(c.string),
        });
        let descriptor: EntityDescriptor<DebugEventShape> = {
            name: 'DebugEvent',
            storageKey: 'debugEvent',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DebugEventFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DebugEventShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, seq: number, src: DebugEventCreateShape): Promise<DebugEvent> {
        return this._create(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, seq: number, src: DebugEventCreateShape): DebugEvent {
        return this._create_UNSAFE(ctx, [uid, seq], this.descriptor.codec.normalize({ uid, seq, ...src }));
    }

    findById(ctx: Context, uid: number, seq: number): Promise<DebugEvent | null> {
        return this._findById(ctx, [uid, seq]);
    }

    watch(ctx: Context, uid: number, seq: number): Watch {
        return this._watch(ctx, [uid, seq]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DebugEventShape>): DebugEvent {
        return new DebugEvent([value.uid, value.seq], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DebugEventStateShape {
    uid: number;
    seq: number;
}

export interface DebugEventStateCreateShape {
    seq: number;
}

export class DebugEventState extends Entity<DebugEventStateShape> {
    get uid(): number { return this._rawValue.uid; }
    get seq(): number { return this._rawValue.seq; }
    set seq(value: number) {
        let normalized = this.descriptor.codec.fields.seq.normalize(value);
        if (this._rawValue.seq !== normalized) {
            this._rawValue.seq = normalized;
            this._updatedValues.seq = normalized;
            this.invalidate();
        }
    }
}

export class DebugEventStateFactory extends EntityFactory<DebugEventStateShape, DebugEventState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('debugEventState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'seq', type: { type: 'integer' }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            seq: c.integer,
        });
        let descriptor: EntityDescriptor<DebugEventStateShape> = {
            name: 'DebugEventState',
            storageKey: 'debugEventState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DebugEventStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DebugEventStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, uid: number, src: DebugEventStateCreateShape): Promise<DebugEventState> {
        return this._create(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, src: DebugEventStateCreateShape): DebugEventState {
        return this._create_UNSAFE(ctx, [uid], this.descriptor.codec.normalize({ uid, ...src }));
    }

    findById(ctx: Context, uid: number): Promise<DebugEventState | null> {
        return this._findById(ctx, [uid]);
    }

    watch(ctx: Context, uid: number): Watch {
        return this._watch(ctx, [uid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DebugEventStateShape>): DebugEventState {
        return new DebugEventState([value.uid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EntityCounterStateShape {
    id: string;
    cursor: string | null;
    lastId: any | null;
    count: number;
    version: number | null;
}

export interface EntityCounterStateCreateShape {
    cursor?: string | null | undefined;
    lastId?: any | null | undefined;
    count: number;
    version?: number | null | undefined;
}

export class EntityCounterState extends Entity<EntityCounterStateShape> {
    get id(): string { return this._rawValue.id; }
    get cursor(): string | null { return this._rawValue.cursor; }
    set cursor(value: string | null) {
        let normalized = this.descriptor.codec.fields.cursor.normalize(value);
        if (this._rawValue.cursor !== normalized) {
            this._rawValue.cursor = normalized;
            this._updatedValues.cursor = normalized;
            this.invalidate();
        }
    }
    get lastId(): any | null { return this._rawValue.lastId; }
    set lastId(value: any | null) {
        let normalized = this.descriptor.codec.fields.lastId.normalize(value);
        if (this._rawValue.lastId !== normalized) {
            this._rawValue.lastId = normalized;
            this._updatedValues.lastId = normalized;
            this.invalidate();
        }
    }
    get count(): number { return this._rawValue.count; }
    set count(value: number) {
        let normalized = this.descriptor.codec.fields.count.normalize(value);
        if (this._rawValue.count !== normalized) {
            this._rawValue.count = normalized;
            this._updatedValues.count = normalized;
            this.invalidate();
        }
    }
    get version(): number | null { return this._rawValue.version; }
    set version(value: number | null) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
}

export class EntityCounterStateFactory extends EntityFactory<EntityCounterStateShape, EntityCounterState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('entityCounterState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'cursor', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'lastId', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'count', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'version', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            cursor: c.optional(c.string),
            lastId: c.optional(c.any),
            count: c.integer,
            version: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<EntityCounterStateShape> = {
            name: 'EntityCounterState',
            storageKey: 'entityCounterState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EntityCounterStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EntityCounterStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: EntityCounterStateCreateShape): Promise<EntityCounterState> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: EntityCounterStateCreateShape): EntityCounterState {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<EntityCounterState | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EntityCounterStateShape>): EntityCounterState {
        return new EntityCounterState([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface GqlTraceShape {
    id: number;
    traceData: any;
}

export interface GqlTraceCreateShape {
    traceData: any;
}

export class GqlTrace extends Entity<GqlTraceShape> {
    get id(): number { return this._rawValue.id; }
    get traceData(): any { return this._rawValue.traceData; }
    set traceData(value: any) {
        let normalized = this.descriptor.codec.fields.traceData.normalize(value);
        if (this._rawValue.traceData !== normalized) {
            this._rawValue.traceData = normalized;
            this._updatedValues.traceData = normalized;
            this.invalidate();
        }
    }
}

export class GqlTraceFactory extends EntityFactory<GqlTraceShape, GqlTrace> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('gqlTrace');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'trace', storageKey: 'trace', type: { type: 'range', fields: [{ name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('gqlTrace', 'trace'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'traceData', type: { type: 'json' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            traceData: c.any,
        });
        let descriptor: EntityDescriptor<GqlTraceShape> = {
            name: 'GqlTrace',
            storageKey: 'gqlTrace',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new GqlTraceFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<GqlTraceShape>) {
        super(descriptor);
    }

    readonly trace = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    create(ctx: Context, id: number, src: GqlTraceCreateShape): Promise<GqlTrace> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: GqlTraceCreateShape): GqlTrace {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<GqlTrace | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<GqlTraceShape>): GqlTrace {
        return new GqlTrace([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EntityCleanerStateShape {
    id: string;
    lastId: any | null;
    deletedCount: number;
    brokenRecordsCount: number | null;
    version: number | null;
}

export interface EntityCleanerStateCreateShape {
    lastId?: any | null | undefined;
    deletedCount: number;
    brokenRecordsCount?: number | null | undefined;
    version?: number | null | undefined;
}

export class EntityCleanerState extends Entity<EntityCleanerStateShape> {
    get id(): string { return this._rawValue.id; }
    get lastId(): any | null { return this._rawValue.lastId; }
    set lastId(value: any | null) {
        let normalized = this.descriptor.codec.fields.lastId.normalize(value);
        if (this._rawValue.lastId !== normalized) {
            this._rawValue.lastId = normalized;
            this._updatedValues.lastId = normalized;
            this.invalidate();
        }
    }
    get deletedCount(): number { return this._rawValue.deletedCount; }
    set deletedCount(value: number) {
        let normalized = this.descriptor.codec.fields.deletedCount.normalize(value);
        if (this._rawValue.deletedCount !== normalized) {
            this._rawValue.deletedCount = normalized;
            this._updatedValues.deletedCount = normalized;
            this.invalidate();
        }
    }
    get brokenRecordsCount(): number | null { return this._rawValue.brokenRecordsCount; }
    set brokenRecordsCount(value: number | null) {
        let normalized = this.descriptor.codec.fields.brokenRecordsCount.normalize(value);
        if (this._rawValue.brokenRecordsCount !== normalized) {
            this._rawValue.brokenRecordsCount = normalized;
            this._updatedValues.brokenRecordsCount = normalized;
            this.invalidate();
        }
    }
    get version(): number | null { return this._rawValue.version; }
    set version(value: number | null) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
}

export class EntityCleanerStateFactory extends EntityFactory<EntityCleanerStateShape, EntityCleanerState> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('entityCleanerState');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'lastId', type: { type: 'optional', inner: { type: 'json' } }, secure: false });
        fields.push({ name: 'deletedCount', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'brokenRecordsCount', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'version', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        let codec = c.struct({
            id: c.string,
            lastId: c.optional(c.any),
            deletedCount: c.integer,
            brokenRecordsCount: c.optional(c.integer),
            version: c.optional(c.integer),
        });
        let descriptor: EntityDescriptor<EntityCleanerStateShape> = {
            name: 'EntityCleanerState',
            storageKey: 'entityCleanerState',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EntityCleanerStateFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EntityCleanerStateShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: EntityCleanerStateCreateShape): Promise<EntityCleanerState> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: string, src: EntityCleanerStateCreateShape): EntityCleanerState {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<EntityCleanerState | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: string): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EntityCleanerStateShape>): EntityCleanerState {
        return new EntityCleanerState([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EditorsChoiceChatsCollectionShape {
    id: number;
    createdBy: number;
    title: string;
    description: string | null;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null };
    chatIds: (number)[];
    deleted: boolean | null;
}

export interface EditorsChoiceChatsCollectionCreateShape {
    createdBy: number;
    title: string;
    description?: string | null | undefined;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined };
    chatIds: (number)[];
    deleted?: boolean | null | undefined;
}

export class EditorsChoiceChatsCollection extends Entity<EditorsChoiceChatsCollectionShape> {
    get id(): number { return this._rawValue.id; }
    get createdBy(): number { return this._rawValue.createdBy; }
    set createdBy(value: number) {
        let normalized = this.descriptor.codec.fields.createdBy.normalize(value);
        if (this._rawValue.createdBy !== normalized) {
            this._rawValue.createdBy = normalized;
            this._updatedValues.createdBy = normalized;
            this.invalidate();
        }
    }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get description(): string | null { return this._rawValue.description; }
    set description(value: string | null) {
        let normalized = this.descriptor.codec.fields.description.normalize(value);
        if (this._rawValue.description !== normalized) {
            this._rawValue.description = normalized;
            this._updatedValues.description = normalized;
            this.invalidate();
        }
    }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get chatIds(): (number)[] { return this._rawValue.chatIds; }
    set chatIds(value: (number)[]) {
        let normalized = this.descriptor.codec.fields.chatIds.normalize(value);
        if (this._rawValue.chatIds !== normalized) {
            this._rawValue.chatIds = normalized;
            this._updatedValues.chatIds = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class EditorsChoiceChatsCollectionFactory extends EntityFactory<EditorsChoiceChatsCollectionShape, EditorsChoiceChatsCollection> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('editorsChoiceChatsCollection');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'collection', storageKey: 'collection', type: { type: 'range', fields: [{ name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('editorsChoiceChatsCollection', 'collection'), condition: (src) => !src.deleted });
        secondaryIndexes.push({ name: 'created', storageKey: 'created', type: { type: 'range', fields: [{ name: 'id', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('editorsChoiceChatsCollection', 'created'), condition: (src) => !src.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'createdBy', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'description', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'image', type: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'chatIds', type: { type: 'array', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            createdBy: c.integer,
            title: c.string,
            description: c.optional(c.string),
            image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }),
            chatIds: c.array(c.integer),
            deleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<EditorsChoiceChatsCollectionShape> = {
            name: 'EditorsChoiceChatsCollection',
            storageKey: 'editorsChoiceChatsCollection',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EditorsChoiceChatsCollectionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EditorsChoiceChatsCollectionShape>) {
        super(descriptor);
    }

    readonly collection = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [], opts);
        },
    });

    readonly created = Object.freeze({
        findAll: async (ctx: Context, id: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [id])).items;
        },
        query: (ctx: Context, id: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [id], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (id: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [id], opts);
        },
        liveStream: (ctx: Context, id: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [id], opts);
        },
    });

    create(ctx: Context, id: number, src: EditorsChoiceChatsCollectionCreateShape): Promise<EditorsChoiceChatsCollection> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: EditorsChoiceChatsCollectionCreateShape): EditorsChoiceChatsCollection {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<EditorsChoiceChatsCollection | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EditorsChoiceChatsCollectionShape>): EditorsChoiceChatsCollection {
        return new EditorsChoiceChatsCollection([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface EditorsChoiceChatShape {
    id: number;
    createdBy: number;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null };
    cid: number;
    deleted: boolean | null;
}

export interface EditorsChoiceChatCreateShape {
    createdBy: number;
    image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined };
    cid: number;
    deleted?: boolean | null | undefined;
}

export class EditorsChoiceChat extends Entity<EditorsChoiceChatShape> {
    get id(): number { return this._rawValue.id; }
    get createdBy(): number { return this._rawValue.createdBy; }
    set createdBy(value: number) {
        let normalized = this.descriptor.codec.fields.createdBy.normalize(value);
        if (this._rawValue.createdBy !== normalized) {
            this._rawValue.createdBy = normalized;
            this._updatedValues.createdBy = normalized;
            this.invalidate();
        }
    }
    get image(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } { return this._rawValue.image; }
    set image(value: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }) {
        let normalized = this.descriptor.codec.fields.image.normalize(value);
        if (this._rawValue.image !== normalized) {
            this._rawValue.image = normalized;
            this._updatedValues.image = normalized;
            this.invalidate();
        }
    }
    get cid(): number { return this._rawValue.cid; }
    set cid(value: number) {
        let normalized = this.descriptor.codec.fields.cid.normalize(value);
        if (this._rawValue.cid !== normalized) {
            this._rawValue.cid = normalized;
            this._updatedValues.cid = normalized;
            this.invalidate();
        }
    }
    get deleted(): boolean | null { return this._rawValue.deleted; }
    set deleted(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.deleted.normalize(value);
        if (this._rawValue.deleted !== normalized) {
            this._rawValue.deleted = normalized;
            this._updatedValues.deleted = normalized;
            this.invalidate();
        }
    }
}

export class EditorsChoiceChatFactory extends EntityFactory<EditorsChoiceChatShape, EditorsChoiceChat> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('editorsChoiceChat');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'all', storageKey: 'all', type: { type: 'unique', fields: [{ name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('editorsChoiceChat', 'all'), condition: (src) => !src.deleted });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'createdBy', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'image', type: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, secure: false });
        fields.push({ name: 'cid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'deleted', type: { type: 'optional', inner: { type: 'boolean' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            createdBy: c.integer,
            image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }),
            cid: c.integer,
            deleted: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<EditorsChoiceChatShape> = {
            name: 'EditorsChoiceChat',
            storageKey: 'editorsChoiceChat',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new EditorsChoiceChatFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<EditorsChoiceChatShape>) {
        super(descriptor);
    }

    readonly all = Object.freeze({
        find: async (ctx: Context, id: number) => {
            return this._findFromUniqueIndex(ctx, [id], this.descriptor.secondaryIndexes[0]);
        },
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
    });

    create(ctx: Context, id: number, src: EditorsChoiceChatCreateShape): Promise<EditorsChoiceChat> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: EditorsChoiceChatCreateShape): EditorsChoiceChat {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<EditorsChoiceChat | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<EditorsChoiceChatShape>): EditorsChoiceChat {
        return new EditorsChoiceChat([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ClickHouseMigrationsShape {
    version: number;
    applied: (string)[];
}

export interface ClickHouseMigrationsCreateShape {
    applied: (string)[];
}

export class ClickHouseMigrations extends Entity<ClickHouseMigrationsShape> {
    get version(): number { return this._rawValue.version; }
    get applied(): (string)[] { return this._rawValue.applied; }
    set applied(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.applied.normalize(value);
        if (this._rawValue.applied !== normalized) {
            this._rawValue.applied = normalized;
            this._updatedValues.applied = normalized;
            this.invalidate();
        }
    }
}

export class ClickHouseMigrationsFactory extends EntityFactory<ClickHouseMigrationsShape, ClickHouseMigrations> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('clickHouseMigrations');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'version', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'applied', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            version: c.integer,
            applied: c.array(c.string),
        });
        let descriptor: EntityDescriptor<ClickHouseMigrationsShape> = {
            name: 'ClickHouseMigrations',
            storageKey: 'clickHouseMigrations',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ClickHouseMigrationsFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ClickHouseMigrationsShape>) {
        super(descriptor);
    }

    create(ctx: Context, version: number, src: ClickHouseMigrationsCreateShape): Promise<ClickHouseMigrations> {
        return this._create(ctx, [version], this.descriptor.codec.normalize({ version, ...src }));
    }

    create_UNSAFE(ctx: Context, version: number, src: ClickHouseMigrationsCreateShape): ClickHouseMigrations {
        return this._create_UNSAFE(ctx, [version], this.descriptor.codec.normalize({ version, ...src }));
    }

    findById(ctx: Context, version: number): Promise<ClickHouseMigrations | null> {
        return this._findById(ctx, [version]);
    }

    watch(ctx: Context, version: number): Watch {
        return this._watch(ctx, [version]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ClickHouseMigrationsShape>): ClickHouseMigrations {
        return new ClickHouseMigrations([value.version], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DiscussionHubShape {
    id: number;
    description: { type: 'personal', uid: number } | { type: 'public', title: string } | { type: 'system', title: string } | { type: 'secret', title: string, uid: number };
}

export interface DiscussionHubCreateShape {
    description: { type: 'personal', uid: number } | { type: 'public', title: string } | { type: 'system', title: string } | { type: 'secret', title: string, uid: number };
}

export class DiscussionHub extends Entity<DiscussionHubShape> {
    get id(): number { return this._rawValue.id; }
    get description(): { type: 'personal', uid: number } | { type: 'public', title: string } | { type: 'system', title: string } | { type: 'secret', title: string, uid: number } { return this._rawValue.description; }
    set description(value: { type: 'personal', uid: number } | { type: 'public', title: string } | { type: 'system', title: string } | { type: 'secret', title: string, uid: number }) {
        let normalized = this.descriptor.codec.fields.description.normalize(value);
        if (this._rawValue.description !== normalized) {
            this._rawValue.description = normalized;
            this._updatedValues.description = normalized;
            this.invalidate();
        }
    }
}

export class DiscussionHubFactory extends EntityFactory<DiscussionHubShape, DiscussionHub> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('discussionHub');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'description', type: { type: 'union', types: { personal: { uid: { type: 'integer' } }, public: { title: { type: 'string' } }, system: { title: { type: 'string' } }, secret: { title: { type: 'string' }, uid: { type: 'integer' } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            description: c.union({ personal: c.struct({ uid: c.integer }), public: c.struct({ title: c.string }), system: c.struct({ title: c.string }), secret: c.struct({ title: c.string, uid: c.integer }) }),
        });
        let descriptor: EntityDescriptor<DiscussionHubShape> = {
            name: 'DiscussionHub',
            storageKey: 'discussionHub',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DiscussionHubFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DiscussionHubShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: DiscussionHubCreateShape): Promise<DiscussionHub> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: DiscussionHubCreateShape): DiscussionHub {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<DiscussionHub | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DiscussionHubShape>): DiscussionHub {
        return new DiscussionHub([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DiscussionShape {
    id: number;
    uid: number;
    hubId: number | null;
    state: 'published' | 'archived';
    publishedAt: number | null;
    editedAt: number | null;
    archivedAt: number | null;
    version: number;
    title: string;
    content: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null;
}

export interface DiscussionCreateShape {
    uid: number;
    hubId?: number | null | undefined;
    state: 'published' | 'archived';
    publishedAt?: number | null | undefined;
    editedAt?: number | null | undefined;
    archivedAt?: number | null | undefined;
    version: number;
    title: string;
    content?: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null | undefined;
}

export class Discussion extends Entity<DiscussionShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get hubId(): number | null { return this._rawValue.hubId; }
    set hubId(value: number | null) {
        let normalized = this.descriptor.codec.fields.hubId.normalize(value);
        if (this._rawValue.hubId !== normalized) {
            this._rawValue.hubId = normalized;
            this._updatedValues.hubId = normalized;
            this.invalidate();
        }
    }
    get state(): 'published' | 'archived' { return this._rawValue.state; }
    set state(value: 'published' | 'archived') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get publishedAt(): number | null { return this._rawValue.publishedAt; }
    set publishedAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.publishedAt.normalize(value);
        if (this._rawValue.publishedAt !== normalized) {
            this._rawValue.publishedAt = normalized;
            this._updatedValues.publishedAt = normalized;
            this.invalidate();
        }
    }
    get editedAt(): number | null { return this._rawValue.editedAt; }
    set editedAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.editedAt.normalize(value);
        if (this._rawValue.editedAt !== normalized) {
            this._rawValue.editedAt = normalized;
            this._updatedValues.editedAt = normalized;
            this.invalidate();
        }
    }
    get archivedAt(): number | null { return this._rawValue.archivedAt; }
    set archivedAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.archivedAt.normalize(value);
        if (this._rawValue.archivedAt !== normalized) {
            this._rawValue.archivedAt = normalized;
            this._updatedValues.archivedAt = normalized;
            this.invalidate();
        }
    }
    get version(): number { return this._rawValue.version; }
    set version(value: number) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get content(): ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null { return this._rawValue.content; }
    set content(value: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null) {
        let normalized = this.descriptor.codec.fields.content.normalize(value);
        if (this._rawValue.content !== normalized) {
            this._rawValue.content = normalized;
            this._updatedValues.content = normalized;
            this.invalidate();
        }
    }

    delete(ctx: Context) {
        return this._delete(ctx);
    }
}

export class DiscussionFactory extends EntityFactory<DiscussionShape, Discussion> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('discussion');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'published', storageKey: 'published', type: { type: 'range', fields: [{ name: 'hubId', type: 'opt_integer' }, { name: 'publishedAt', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('discussion', 'published'), condition: (src) => src.state === 'published' });
        secondaryIndexes.push({ name: 'publishedAll', storageKey: 'publishedAll', type: { type: 'range', fields: [{ name: 'publishedAt', type: 'opt_integer' }] }, subspace: await storage.resolveEntityIndexDirectory('discussion', 'publishedAll'), condition: (src) => src.state === 'published' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'hubId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['published', 'archived'] }, secure: false });
        fields.push({ name: 'publishedAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'editedAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'archivedAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'version', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'content', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { text: { text: { type: 'string' }, spans: { type: 'array', inner: { type: 'union', types: { link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } } } } } }, image: { image: { type: 'struct', fields: { image: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, info: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } } }, h1: { text: { type: 'string' } }, h2: { text: { type: 'string' } } } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
            hubId: c.optional(c.integer),
            state: c.enum('published', 'archived'),
            publishedAt: c.optional(c.integer),
            editedAt: c.optional(c.integer),
            archivedAt: c.optional(c.integer),
            version: c.integer,
            title: c.string,
            content: c.optional(c.array(c.union({ text: c.struct({ text: c.string, spans: c.array(c.union({ link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }) })) }), image: c.struct({ image: c.struct({ image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }), info: c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string }) }) }), h1: c.struct({ text: c.string }), h2: c.struct({ text: c.string }) }))),
        });
        let descriptor: EntityDescriptor<DiscussionShape> = {
            name: 'Discussion',
            storageKey: 'discussion',
            allowDelete: true,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DiscussionFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DiscussionShape>) {
        super(descriptor);
    }

    readonly published = Object.freeze({
        findAll: async (ctx: Context, hubId: number | null) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [hubId])).items;
        },
        query: (ctx: Context, hubId: number | null, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [hubId], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (hubId: number | null, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [hubId], opts);
        },
        liveStream: (ctx: Context, hubId: number | null, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [hubId], opts);
        },
    });

    readonly publishedAll = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number | null>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: number, src: DiscussionCreateShape): Promise<Discussion> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: DiscussionCreateShape): Discussion {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<Discussion | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DiscussionShape>): Discussion {
        return new Discussion([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface DiscussionDraftShape {
    id: number;
    uid: number;
    hubId: number | null;
    state: 'draft' | 'archived';
    editedAt: number | null;
    archivedAt: number | null;
    version: number;
    title: string;
    content: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null;
}

export interface DiscussionDraftCreateShape {
    uid: number;
    hubId?: number | null | undefined;
    state: 'draft' | 'archived';
    editedAt?: number | null | undefined;
    archivedAt?: number | null | undefined;
    version: number;
    title: string;
    content?: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null | undefined, imageHeight: number | null | undefined, imageFormat: string | null | undefined, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null | undefined;
}

export class DiscussionDraft extends Entity<DiscussionDraftShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get hubId(): number | null { return this._rawValue.hubId; }
    set hubId(value: number | null) {
        let normalized = this.descriptor.codec.fields.hubId.normalize(value);
        if (this._rawValue.hubId !== normalized) {
            this._rawValue.hubId = normalized;
            this._updatedValues.hubId = normalized;
            this.invalidate();
        }
    }
    get state(): 'draft' | 'archived' { return this._rawValue.state; }
    set state(value: 'draft' | 'archived') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }
    get editedAt(): number | null { return this._rawValue.editedAt; }
    set editedAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.editedAt.normalize(value);
        if (this._rawValue.editedAt !== normalized) {
            this._rawValue.editedAt = normalized;
            this._updatedValues.editedAt = normalized;
            this.invalidate();
        }
    }
    get archivedAt(): number | null { return this._rawValue.archivedAt; }
    set archivedAt(value: number | null) {
        let normalized = this.descriptor.codec.fields.archivedAt.normalize(value);
        if (this._rawValue.archivedAt !== normalized) {
            this._rawValue.archivedAt = normalized;
            this._updatedValues.archivedAt = normalized;
            this.invalidate();
        }
    }
    get version(): number { return this._rawValue.version; }
    set version(value: number) {
        let normalized = this.descriptor.codec.fields.version.normalize(value);
        if (this._rawValue.version !== normalized) {
            this._rawValue.version = normalized;
            this._updatedValues.version = normalized;
            this.invalidate();
        }
    }
    get title(): string { return this._rawValue.title; }
    set title(value: string) {
        let normalized = this.descriptor.codec.fields.title.normalize(value);
        if (this._rawValue.title !== normalized) {
            this._rawValue.title = normalized;
            this._updatedValues.title = normalized;
            this.invalidate();
        }
    }
    get content(): ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null { return this._rawValue.content; }
    set content(value: ({ type: 'text', text: string, spans: ({ type: 'link', offset: number, length: number, url: string } | { type: 'bold_text', offset: number, length: number } | { type: 'italic_text', offset: number, length: number } | { type: 'irony_text', offset: number, length: number })[] } | { type: 'image', image: { image: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null }, info: { name: string, size: number, isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string } } } | { type: 'h1', text: string } | { type: 'h2', text: string })[] | null) {
        let normalized = this.descriptor.codec.fields.content.normalize(value);
        if (this._rawValue.content !== normalized) {
            this._rawValue.content = normalized;
            this._updatedValues.content = normalized;
            this.invalidate();
        }
    }

    delete(ctx: Context) {
        return this._delete(ctx);
    }
}

export class DiscussionDraftFactory extends EntityFactory<DiscussionDraftShape, DiscussionDraft> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('discussionDraft');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'draft', storageKey: 'draft', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('discussionDraft', 'draft'), condition: (src) => src.state === 'draft' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'hubId', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'state', type: { type: 'enum', values: ['draft', 'archived'] }, secure: false });
        fields.push({ name: 'editedAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'archivedAt', type: { type: 'optional', inner: { type: 'integer' } }, secure: false });
        fields.push({ name: 'version', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'title', type: { type: 'string' }, secure: false });
        fields.push({ name: 'content', type: { type: 'optional', inner: { type: 'array', inner: { type: 'union', types: { text: { text: { type: 'string' }, spans: { type: 'array', inner: { type: 'union', types: { link: { offset: { type: 'integer' }, length: { type: 'integer' }, url: { type: 'string' } }, bold_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, italic_text: { offset: { type: 'integer' }, length: { type: 'integer' } }, irony_text: { offset: { type: 'integer' }, length: { type: 'integer' } } } } } }, image: { image: { type: 'struct', fields: { image: { type: 'struct', fields: { uuid: { type: 'string' }, crop: { type: 'optional', inner: { type: 'struct', fields: { x: { type: 'integer' }, y: { type: 'integer' }, w: { type: 'integer' }, h: { type: 'integer' } } } } } }, info: { type: 'struct', fields: { name: { type: 'string' }, size: { type: 'integer' }, isImage: { type: 'boolean' }, isStored: { type: 'boolean' }, imageWidth: { type: 'optional', inner: { type: 'integer' } }, imageHeight: { type: 'optional', inner: { type: 'integer' } }, imageFormat: { type: 'optional', inner: { type: 'string' } }, mimeType: { type: 'string' } } } } } }, h1: { text: { type: 'string' } }, h2: { text: { type: 'string' } } } } } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
            hubId: c.optional(c.integer),
            state: c.enum('draft', 'archived'),
            editedAt: c.optional(c.integer),
            archivedAt: c.optional(c.integer),
            version: c.integer,
            title: c.string,
            content: c.optional(c.array(c.union({ text: c.struct({ text: c.string, spans: c.array(c.union({ link: c.struct({ offset: c.integer, length: c.integer, url: c.string }), bold_text: c.struct({ offset: c.integer, length: c.integer }), italic_text: c.struct({ offset: c.integer, length: c.integer }), irony_text: c.struct({ offset: c.integer, length: c.integer }) })) }), image: c.struct({ image: c.struct({ image: c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) }), info: c.struct({ name: c.string, size: c.integer, isImage: c.boolean, isStored: c.boolean, imageWidth: c.optional(c.integer), imageHeight: c.optional(c.integer), imageFormat: c.optional(c.string), mimeType: c.string }) }) }), h1: c.struct({ text: c.string }), h2: c.struct({ text: c.string }) }))),
        });
        let descriptor: EntityDescriptor<DiscussionDraftShape> = {
            name: 'DiscussionDraft',
            storageKey: 'discussionDraft',
            allowDelete: true,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new DiscussionDraftFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<DiscussionDraftShape>) {
        super(descriptor);
    }

    readonly draft = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, id: number, src: DiscussionDraftCreateShape): Promise<DiscussionDraft> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: DiscussionDraftCreateShape): DiscussionDraft {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<DiscussionDraft | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<DiscussionDraftShape>): DiscussionDraft {
        return new DiscussionDraft([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface ContactShape {
    uid: number;
    contactUid: number;
    state: 'active' | 'deleted';
}

export interface ContactCreateShape {
    state: 'active' | 'deleted';
}

export class Contact extends Entity<ContactShape> {
    get uid(): number { return this._rawValue.uid; }
    get contactUid(): number { return this._rawValue.contactUid; }
    get state(): 'active' | 'deleted' { return this._rawValue.state; }
    set state(value: 'active' | 'deleted') {
        let normalized = this.descriptor.codec.fields.state.normalize(value);
        if (this._rawValue.state !== normalized) {
            this._rawValue.state = normalized;
            this._updatedValues.state = normalized;
            this.invalidate();
        }
    }

    delete(ctx: Context) {
        return this._delete(ctx);
    }
}

export class ContactFactory extends EntityFactory<ContactShape, Contact> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('contact');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'createdAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('contact', 'user'), condition: (item) => item.state === 'active' });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'uid', type: 'integer' });
        primaryKeys.push({ name: 'contactUid', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'state', type: { type: 'enum', values: ['active', 'deleted'] }, secure: false });
        let codec = c.struct({
            uid: c.integer,
            contactUid: c.integer,
            state: c.enum('active', 'deleted'),
        });
        let descriptor: EntityDescriptor<ContactShape> = {
            name: 'Contact',
            storageKey: 'contact',
            allowDelete: true,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new ContactFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<ContactShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    create(ctx: Context, uid: number, contactUid: number, src: ContactCreateShape): Promise<Contact> {
        return this._create(ctx, [uid, contactUid], this.descriptor.codec.normalize({ uid, contactUid, ...src }));
    }

    create_UNSAFE(ctx: Context, uid: number, contactUid: number, src: ContactCreateShape): Contact {
        return this._create_UNSAFE(ctx, [uid, contactUid], this.descriptor.codec.normalize({ uid, contactUid, ...src }));
    }

    findById(ctx: Context, uid: number, contactUid: number): Promise<Contact | null> {
        return this._findById(ctx, [uid, contactUid]);
    }

    watch(ctx: Context, uid: number, contactUid: number): Watch {
        return this._watch(ctx, [uid, contactUid]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<ContactShape>): Contact {
        return new Contact([value.uid, value.contactUid], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

export interface PhonebookItemShape {
    id: number;
    uid: number;
    firstName: string;
    lastName: string | null;
    info: string | null;
    phones: (string)[];
}

export interface PhonebookItemCreateShape {
    uid: number;
    firstName: string;
    lastName?: string | null | undefined;
    info?: string | null | undefined;
    phones: (string)[];
}

export class PhonebookItem extends Entity<PhonebookItemShape> {
    get id(): number { return this._rawValue.id; }
    get uid(): number { return this._rawValue.uid; }
    set uid(value: number) {
        let normalized = this.descriptor.codec.fields.uid.normalize(value);
        if (this._rawValue.uid !== normalized) {
            this._rawValue.uid = normalized;
            this._updatedValues.uid = normalized;
            this.invalidate();
        }
    }
    get firstName(): string { return this._rawValue.firstName; }
    set firstName(value: string) {
        let normalized = this.descriptor.codec.fields.firstName.normalize(value);
        if (this._rawValue.firstName !== normalized) {
            this._rawValue.firstName = normalized;
            this._updatedValues.firstName = normalized;
            this.invalidate();
        }
    }
    get lastName(): string | null { return this._rawValue.lastName; }
    set lastName(value: string | null) {
        let normalized = this.descriptor.codec.fields.lastName.normalize(value);
        if (this._rawValue.lastName !== normalized) {
            this._rawValue.lastName = normalized;
            this._updatedValues.lastName = normalized;
            this.invalidate();
        }
    }
    get info(): string | null { return this._rawValue.info; }
    set info(value: string | null) {
        let normalized = this.descriptor.codec.fields.info.normalize(value);
        if (this._rawValue.info !== normalized) {
            this._rawValue.info = normalized;
            this._updatedValues.info = normalized;
            this.invalidate();
        }
    }
    get phones(): (string)[] { return this._rawValue.phones; }
    set phones(value: (string)[]) {
        let normalized = this.descriptor.codec.fields.phones.normalize(value);
        if (this._rawValue.phones !== normalized) {
            this._rawValue.phones = normalized;
            this._updatedValues.phones = normalized;
            this.invalidate();
        }
    }
}

export class PhonebookItemFactory extends EntityFactory<PhonebookItemShape, PhonebookItem> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('phonebookItem');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'user', storageKey: 'user', type: { type: 'range', fields: [{ name: 'uid', type: 'integer' }, { name: 'id', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('phonebookItem', 'user'), condition: undefined });
        secondaryIndexes.push({ name: 'updated', storageKey: 'updated', type: { type: 'range', fields: [{ name: 'updatedAt', type: 'integer' }] }, subspace: await storage.resolveEntityIndexDirectory('phonebookItem', 'updated'), condition: undefined });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'uid', type: { type: 'integer' }, secure: false });
        fields.push({ name: 'firstName', type: { type: 'string' }, secure: false });
        fields.push({ name: 'lastName', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'info', type: { type: 'optional', inner: { type: 'string' } }, secure: false });
        fields.push({ name: 'phones', type: { type: 'array', inner: { type: 'string' } }, secure: false });
        let codec = c.struct({
            id: c.integer,
            uid: c.integer,
            firstName: c.string,
            lastName: c.optional(c.string),
            info: c.optional(c.string),
            phones: c.array(c.string),
        });
        let descriptor: EntityDescriptor<PhonebookItemShape> = {
            name: 'PhonebookItem',
            storageKey: 'phonebookItem',
            allowDelete: false,
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new PhonebookItemFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<PhonebookItemShape>) {
        super(descriptor);
    }

    readonly user = Object.freeze({
        findAll: async (ctx: Context, uid: number) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[0], [uid])).items;
        },
        query: (ctx: Context, uid: number, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[0], [uid], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (uid: number, opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[0], [uid], opts);
        },
        liveStream: (ctx: Context, uid: number, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[0], [uid], opts);
        },
    });

    readonly updated = Object.freeze({
        findAll: async (ctx: Context) => {
            return (await this._query(ctx, this.descriptor.secondaryIndexes[1], [])).items;
        },
        query: (ctx: Context, opts?: RangeQueryOptions<number>) => {
            return this._query(ctx, this.descriptor.secondaryIndexes[1], [], { limit: opts && opts.limit, reverse: opts && opts.reverse, after: opts && opts.after ? [opts.after] : undefined, afterCursor: opts && opts.afterCursor ? opts.afterCursor : undefined });
        },
        stream: (opts?: StreamProps) => {
            return this._createStream(this.descriptor.secondaryIndexes[1], [], opts);
        },
        liveStream: (ctx: Context, opts?: StreamProps) => {
            return this._createLiveStream(ctx, this.descriptor.secondaryIndexes[1], [], opts);
        },
    });

    create(ctx: Context, id: number, src: PhonebookItemCreateShape): Promise<PhonebookItem> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    create_UNSAFE(ctx: Context, id: number, src: PhonebookItemCreateShape): PhonebookItem {
        return this._create_UNSAFE(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<PhonebookItem | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<PhonebookItemShape>): PhonebookItem {
        return new PhonebookItem([value.id], value, this.descriptor, this._flush, this._delete, ctx);
    }
}

const chatUpdatedEventCodec = c.struct({
    cid: c.integer,
    uid: c.integer,
});

interface ChatUpdatedEventShape {
    cid: number;
    uid: number;
}

export class ChatUpdatedEvent extends BaseEvent {

    static create(data: ChatUpdatedEventShape) {
        return new ChatUpdatedEvent(chatUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new ChatUpdatedEvent(chatUpdatedEventCodec.decode(data));
    }

    static encode(event: ChatUpdatedEvent) {
        return chatUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('chatUpdatedEvent', data);
    }

    get cid(): number { return this.raw.cid; }
    get uid(): number { return this.raw.uid; }
}

const messageReceivedEventCodec = c.struct({
    cid: c.integer,
    mid: c.integer,
    hiddenForUids: c.optional(c.array(c.integer)),
});

interface MessageReceivedEventShape {
    cid: number;
    mid: number;
    hiddenForUids?: (number)[] | null | undefined;
}

export class MessageReceivedEvent extends BaseEvent {

    static create(data: MessageReceivedEventShape) {
        return new MessageReceivedEvent(messageReceivedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new MessageReceivedEvent(messageReceivedEventCodec.decode(data));
    }

    static encode(event: MessageReceivedEvent) {
        return messageReceivedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('messageReceivedEvent', data);
    }

    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
    get hiddenForUids(): (number)[] | null { return this.raw.hiddenForUids; }
}

const messageUpdatedEventCodec = c.struct({
    cid: c.integer,
    mid: c.integer,
    hiddenForUids: c.optional(c.array(c.integer)),
});

interface MessageUpdatedEventShape {
    cid: number;
    mid: number;
    hiddenForUids?: (number)[] | null | undefined;
}

export class MessageUpdatedEvent extends BaseEvent {

    static create(data: MessageUpdatedEventShape) {
        return new MessageUpdatedEvent(messageUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new MessageUpdatedEvent(messageUpdatedEventCodec.decode(data));
    }

    static encode(event: MessageUpdatedEvent) {
        return messageUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('messageUpdatedEvent', data);
    }

    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
    get hiddenForUids(): (number)[] | null { return this.raw.hiddenForUids; }
}

const messageDeletedEventCodec = c.struct({
    cid: c.integer,
    mid: c.integer,
    hiddenForUids: c.optional(c.array(c.integer)),
});

interface MessageDeletedEventShape {
    cid: number;
    mid: number;
    hiddenForUids?: (number)[] | null | undefined;
}

export class MessageDeletedEvent extends BaseEvent {

    static create(data: MessageDeletedEventShape) {
        return new MessageDeletedEvent(messageDeletedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new MessageDeletedEvent(messageDeletedEventCodec.decode(data));
    }

    static encode(event: MessageDeletedEvent) {
        return messageDeletedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('messageDeletedEvent', data);
    }

    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
    get hiddenForUids(): (number)[] | null { return this.raw.hiddenForUids; }
}

const dialogNeedReindexEventCodec = c.struct({
    cid: c.integer,
    uid: c.integer,
});

interface DialogNeedReindexEventShape {
    cid: number;
    uid: number;
}

export class DialogNeedReindexEvent extends BaseEvent {

    static create(data: DialogNeedReindexEventShape) {
        return new DialogNeedReindexEvent(dialogNeedReindexEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new DialogNeedReindexEvent(dialogNeedReindexEventCodec.decode(data));
    }

    static encode(event: DialogNeedReindexEvent) {
        return dialogNeedReindexEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('dialogNeedReindexEvent', data);
    }

    get cid(): number { return this.raw.cid; }
    get uid(): number { return this.raw.uid; }
}

const userDialogMessageReceivedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    mid: c.integer,
});

interface UserDialogMessageReceivedEventShape {
    uid: number;
    cid: number;
    mid: number;
}

export class UserDialogMessageReceivedEvent extends BaseEvent {

    static create(data: UserDialogMessageReceivedEventShape) {
        return new UserDialogMessageReceivedEvent(userDialogMessageReceivedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogMessageReceivedEvent(userDialogMessageReceivedEventCodec.decode(data));
    }

    static encode(event: UserDialogMessageReceivedEvent) {
        return userDialogMessageReceivedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogMessageReceivedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
}

const userDialogMessageUpdatedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    mid: c.integer,
});

interface UserDialogMessageUpdatedEventShape {
    uid: number;
    cid: number;
    mid: number;
}

export class UserDialogMessageUpdatedEvent extends BaseEvent {

    static create(data: UserDialogMessageUpdatedEventShape) {
        return new UserDialogMessageUpdatedEvent(userDialogMessageUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogMessageUpdatedEvent(userDialogMessageUpdatedEventCodec.decode(data));
    }

    static encode(event: UserDialogMessageUpdatedEvent) {
        return userDialogMessageUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogMessageUpdatedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
}

const userDialogMessageDeletedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    mid: c.integer,
});

interface UserDialogMessageDeletedEventShape {
    uid: number;
    cid: number;
    mid: number;
}

export class UserDialogMessageDeletedEvent extends BaseEvent {

    static create(data: UserDialogMessageDeletedEventShape) {
        return new UserDialogMessageDeletedEvent(userDialogMessageDeletedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogMessageDeletedEvent(userDialogMessageDeletedEventCodec.decode(data));
    }

    static encode(event: UserDialogMessageDeletedEvent) {
        return userDialogMessageDeletedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogMessageDeletedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get mid(): number { return this.raw.mid; }
}

const userDialogMessageReadEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    mid: c.optional(c.integer),
});

interface UserDialogMessageReadEventShape {
    uid: number;
    cid: number;
    mid?: number | null | undefined;
}

export class UserDialogMessageReadEvent extends BaseEvent {

    static create(data: UserDialogMessageReadEventShape) {
        return new UserDialogMessageReadEvent(userDialogMessageReadEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogMessageReadEvent(userDialogMessageReadEventCodec.decode(data));
    }

    static encode(event: UserDialogMessageReadEvent) {
        return userDialogMessageReadEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogMessageReadEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get mid(): number | null { return this.raw.mid; }
}

const userDialogTitleUpdatedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    title: c.string,
});

interface UserDialogTitleUpdatedEventShape {
    uid: number;
    cid: number;
    title: string;
}

export class UserDialogTitleUpdatedEvent extends BaseEvent {

    static create(data: UserDialogTitleUpdatedEventShape) {
        return new UserDialogTitleUpdatedEvent(userDialogTitleUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogTitleUpdatedEvent(userDialogTitleUpdatedEventCodec.decode(data));
    }

    static encode(event: UserDialogTitleUpdatedEvent) {
        return userDialogTitleUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogTitleUpdatedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get title(): string { return this.raw.title; }
}

const userDialogDeletedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
});

interface UserDialogDeletedEventShape {
    uid: number;
    cid: number;
}

export class UserDialogDeletedEvent extends BaseEvent {

    static create(data: UserDialogDeletedEventShape) {
        return new UserDialogDeletedEvent(userDialogDeletedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogDeletedEvent(userDialogDeletedEventCodec.decode(data));
    }

    static encode(event: UserDialogDeletedEvent) {
        return userDialogDeletedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogDeletedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
}

const userDialogBumpEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
});

interface UserDialogBumpEventShape {
    uid: number;
    cid: number;
}

export class UserDialogBumpEvent extends BaseEvent {

    static create(data: UserDialogBumpEventShape) {
        return new UserDialogBumpEvent(userDialogBumpEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogBumpEvent(userDialogBumpEventCodec.decode(data));
    }

    static encode(event: UserDialogBumpEvent) {
        return userDialogBumpEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogBumpEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
}

const userDialogPhotoUpdatedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    photo: c.optional(c.struct({ uuid: c.string, crop: c.optional(c.struct({ x: c.integer, y: c.integer, w: c.integer, h: c.integer })) })),
});

interface UserDialogPhotoUpdatedEventShape {
    uid: number;
    cid: number;
    photo?: { uuid: string, crop: { x: number, y: number, w: number, h: number } | null | undefined } | null | undefined;
}

export class UserDialogPhotoUpdatedEvent extends BaseEvent {

    static create(data: UserDialogPhotoUpdatedEventShape) {
        return new UserDialogPhotoUpdatedEvent(userDialogPhotoUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogPhotoUpdatedEvent(userDialogPhotoUpdatedEventCodec.decode(data));
    }

    static encode(event: UserDialogPhotoUpdatedEvent) {
        return userDialogPhotoUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogPhotoUpdatedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get photo(): { uuid: string, crop: { x: number, y: number, w: number, h: number } | null } | null { return this.raw.photo; }
}

const userDialogMuteChangedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    mute: c.optional(c.boolean),
});

interface UserDialogMuteChangedEventShape {
    uid: number;
    cid: number;
    mute?: boolean | null | undefined;
}

export class UserDialogMuteChangedEvent extends BaseEvent {

    static create(data: UserDialogMuteChangedEventShape) {
        return new UserDialogMuteChangedEvent(userDialogMuteChangedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogMuteChangedEvent(userDialogMuteChangedEventCodec.decode(data));
    }

    static encode(event: UserDialogMuteChangedEvent) {
        return userDialogMuteChangedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogMuteChangedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get mute(): boolean | null { return this.raw.mute; }
}

const userDialogPeerUpdatedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
});

interface UserDialogPeerUpdatedEventShape {
    uid: number;
    cid: number;
}

export class UserDialogPeerUpdatedEvent extends BaseEvent {

    static create(data: UserDialogPeerUpdatedEventShape) {
        return new UserDialogPeerUpdatedEvent(userDialogPeerUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogPeerUpdatedEvent(userDialogPeerUpdatedEventCodec.decode(data));
    }

    static encode(event: UserDialogPeerUpdatedEvent) {
        return userDialogPeerUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogPeerUpdatedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
}

const userDialogCallStateChangedEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
    hasActiveCall: c.boolean,
});

interface UserDialogCallStateChangedEventShape {
    uid: number;
    cid: number;
    hasActiveCall: boolean;
}

export class UserDialogCallStateChangedEvent extends BaseEvent {

    static create(data: UserDialogCallStateChangedEventShape) {
        return new UserDialogCallStateChangedEvent(userDialogCallStateChangedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogCallStateChangedEvent(userDialogCallStateChangedEventCodec.decode(data));
    }

    static encode(event: UserDialogCallStateChangedEvent) {
        return userDialogCallStateChangedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogCallStateChangedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
    get hasActiveCall(): boolean { return this.raw.hasActiveCall; }
}

const userDialogGotAccessEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
});

interface UserDialogGotAccessEventShape {
    uid: number;
    cid: number;
}

export class UserDialogGotAccessEvent extends BaseEvent {

    static create(data: UserDialogGotAccessEventShape) {
        return new UserDialogGotAccessEvent(userDialogGotAccessEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogGotAccessEvent(userDialogGotAccessEventCodec.decode(data));
    }

    static encode(event: UserDialogGotAccessEvent) {
        return userDialogGotAccessEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogGotAccessEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
}

const userDialogLostAccessEventCodec = c.struct({
    uid: c.integer,
    cid: c.integer,
});

interface UserDialogLostAccessEventShape {
    uid: number;
    cid: number;
}

export class UserDialogLostAccessEvent extends BaseEvent {

    static create(data: UserDialogLostAccessEventShape) {
        return new UserDialogLostAccessEvent(userDialogLostAccessEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserDialogLostAccessEvent(userDialogLostAccessEventCodec.decode(data));
    }

    static encode(event: UserDialogLostAccessEvent) {
        return userDialogLostAccessEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userDialogLostAccessEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get cid(): number { return this.raw.cid; }
}

const feedItemReceivedEventCodec = c.struct({
    subscriberId: c.optional(c.integer),
    itemId: c.integer,
});

interface FeedItemReceivedEventShape {
    subscriberId?: number | null | undefined;
    itemId: number;
}

export class FeedItemReceivedEvent extends BaseEvent {

    static create(data: FeedItemReceivedEventShape) {
        return new FeedItemReceivedEvent(feedItemReceivedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new FeedItemReceivedEvent(feedItemReceivedEventCodec.decode(data));
    }

    static encode(event: FeedItemReceivedEvent) {
        return feedItemReceivedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('feedItemReceivedEvent', data);
    }

    get subscriberId(): number | null { return this.raw.subscriberId; }
    get itemId(): number { return this.raw.itemId; }
}

const feedItemUpdatedEventCodec = c.struct({
    subscriberId: c.optional(c.integer),
    itemId: c.integer,
});

interface FeedItemUpdatedEventShape {
    subscriberId?: number | null | undefined;
    itemId: number;
}

export class FeedItemUpdatedEvent extends BaseEvent {

    static create(data: FeedItemUpdatedEventShape) {
        return new FeedItemUpdatedEvent(feedItemUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new FeedItemUpdatedEvent(feedItemUpdatedEventCodec.decode(data));
    }

    static encode(event: FeedItemUpdatedEvent) {
        return feedItemUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('feedItemUpdatedEvent', data);
    }

    get subscriberId(): number | null { return this.raw.subscriberId; }
    get itemId(): number { return this.raw.itemId; }
}

const feedItemDeletedEventCodec = c.struct({
    subscriberId: c.optional(c.integer),
    itemId: c.integer,
});

interface FeedItemDeletedEventShape {
    subscriberId?: number | null | undefined;
    itemId: number;
}

export class FeedItemDeletedEvent extends BaseEvent {

    static create(data: FeedItemDeletedEventShape) {
        return new FeedItemDeletedEvent(feedItemDeletedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new FeedItemDeletedEvent(feedItemDeletedEventCodec.decode(data));
    }

    static encode(event: FeedItemDeletedEvent) {
        return feedItemDeletedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('feedItemDeletedEvent', data);
    }

    get subscriberId(): number | null { return this.raw.subscriberId; }
    get itemId(): number { return this.raw.itemId; }
}

const feedRebuildEventCodec = c.struct({
    subscriberId: c.optional(c.integer),
});

interface FeedRebuildEventShape {
    subscriberId?: number | null | undefined;
}

export class FeedRebuildEvent extends BaseEvent {

    static create(data: FeedRebuildEventShape) {
        return new FeedRebuildEvent(feedRebuildEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new FeedRebuildEvent(feedRebuildEventCodec.decode(data));
    }

    static encode(event: FeedRebuildEvent) {
        return feedRebuildEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('feedRebuildEvent', data);
    }

    get subscriberId(): number | null { return this.raw.subscriberId; }
}

const userLocationUpdatedEventCodec = c.struct({
    uid: c.integer,
    date: c.integer,
});

interface UserLocationUpdatedEventShape {
    uid: number;
    date: number;
}

export class UserLocationUpdatedEvent extends BaseEvent {

    static create(data: UserLocationUpdatedEventShape) {
        return new UserLocationUpdatedEvent(userLocationUpdatedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserLocationUpdatedEvent(userLocationUpdatedEventCodec.decode(data));
    }

    static encode(event: UserLocationUpdatedEvent) {
        return userLocationUpdatedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userLocationUpdatedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get date(): number { return this.raw.date; }
}

const userLocationStopSharingEventCodec = c.struct({
    uid: c.integer,
});

interface UserLocationStopSharingEventShape {
    uid: number;
}

export class UserLocationStopSharingEvent extends BaseEvent {

    static create(data: UserLocationStopSharingEventShape) {
        return new UserLocationStopSharingEvent(userLocationStopSharingEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new UserLocationStopSharingEvent(userLocationStopSharingEventCodec.decode(data));
    }

    static encode(event: UserLocationStopSharingEvent) {
        return userLocationStopSharingEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('userLocationStopSharingEvent', data);
    }

    get uid(): number { return this.raw.uid; }
}

const walletTransactionPendingCodec = c.struct({
    id: c.string,
});

interface WalletTransactionPendingShape {
    id: string;
}

export class WalletTransactionPending extends BaseEvent {

    static create(data: WalletTransactionPendingShape) {
        return new WalletTransactionPending(walletTransactionPendingCodec.normalize(data));
    }

    static decode(data: any) {
        return new WalletTransactionPending(walletTransactionPendingCodec.decode(data));
    }

    static encode(event: WalletTransactionPending) {
        return walletTransactionPendingCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('walletTransactionPending', data);
    }

    get id(): string { return this.raw.id; }
}

const walletTransactionSuccessCodec = c.struct({
    id: c.string,
});

interface WalletTransactionSuccessShape {
    id: string;
}

export class WalletTransactionSuccess extends BaseEvent {

    static create(data: WalletTransactionSuccessShape) {
        return new WalletTransactionSuccess(walletTransactionSuccessCodec.normalize(data));
    }

    static decode(data: any) {
        return new WalletTransactionSuccess(walletTransactionSuccessCodec.decode(data));
    }

    static encode(event: WalletTransactionSuccess) {
        return walletTransactionSuccessCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('walletTransactionSuccess', data);
    }

    get id(): string { return this.raw.id; }
}

const walletTransactionCanceledCodec = c.struct({
    id: c.string,
});

interface WalletTransactionCanceledShape {
    id: string;
}

export class WalletTransactionCanceled extends BaseEvent {

    static create(data: WalletTransactionCanceledShape) {
        return new WalletTransactionCanceled(walletTransactionCanceledCodec.normalize(data));
    }

    static decode(data: any) {
        return new WalletTransactionCanceled(walletTransactionCanceledCodec.decode(data));
    }

    static encode(event: WalletTransactionCanceled) {
        return walletTransactionCanceledCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('walletTransactionCanceled', data);
    }

    get id(): string { return this.raw.id; }
}

const paymentStatusChangedCodec = c.struct({
    id: c.string,
});

interface PaymentStatusChangedShape {
    id: string;
}

export class PaymentStatusChanged extends BaseEvent {

    static create(data: PaymentStatusChangedShape) {
        return new PaymentStatusChanged(paymentStatusChangedCodec.normalize(data));
    }

    static decode(data: any) {
        return new PaymentStatusChanged(paymentStatusChangedCodec.decode(data));
    }

    static encode(event: PaymentStatusChanged) {
        return paymentStatusChangedCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('paymentStatusChanged', data);
    }

    get id(): string { return this.raw.id; }
}

const walletBalanceChangedCodec = c.struct({
    amount: c.integer,
});

interface WalletBalanceChangedShape {
    amount: number;
}

export class WalletBalanceChanged extends BaseEvent {

    static create(data: WalletBalanceChangedShape) {
        return new WalletBalanceChanged(walletBalanceChangedCodec.normalize(data));
    }

    static decode(data: any) {
        return new WalletBalanceChanged(walletBalanceChangedCodec.decode(data));
    }

    static encode(event: WalletBalanceChanged) {
        return walletBalanceChangedCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('walletBalanceChanged', data);
    }

    get amount(): number { return this.raw.amount; }
}

const walletLockedChangedCodec = c.struct({
    isLocked: c.boolean,
    failingPaymentsCount: c.integer,
});

interface WalletLockedChangedShape {
    isLocked: boolean;
    failingPaymentsCount: number;
}

export class WalletLockedChanged extends BaseEvent {

    static create(data: WalletLockedChangedShape) {
        return new WalletLockedChanged(walletLockedChangedCodec.normalize(data));
    }

    static decode(data: any) {
        return new WalletLockedChanged(walletLockedChangedCodec.decode(data));
    }

    static encode(event: WalletLockedChanged) {
        return walletLockedChangedCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('walletLockedChanged', data);
    }

    get isLocked(): boolean { return this.raw.isLocked; }
    get failingPaymentsCount(): number { return this.raw.failingPaymentsCount; }
}

const stripeEventCreatedCodec = c.struct({
    id: c.string,
    eventType: c.string,
    eventDate: c.integer,
});

interface StripeEventCreatedShape {
    id: string;
    eventType: string;
    eventDate: number;
}

export class StripeEventCreated extends BaseEvent {

    static create(data: StripeEventCreatedShape) {
        return new StripeEventCreated(stripeEventCreatedCodec.normalize(data));
    }

    static decode(data: any) {
        return new StripeEventCreated(stripeEventCreatedCodec.decode(data));
    }

    static encode(event: StripeEventCreated) {
        return stripeEventCreatedCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('stripeEventCreated', data);
    }

    get id(): string { return this.raw.id; }
    get eventType(): string { return this.raw.eventType; }
    get eventDate(): number { return this.raw.eventDate; }
}

const hyperLogEventCodec = c.struct({
    id: c.string,
    eventType: c.string,
    date: c.integer,
    body: c.any,
});

interface HyperLogEventShape {
    id: string;
    eventType: string;
    date: number;
    body: any;
}

export class HyperLogEvent extends BaseEvent {

    static create(data: HyperLogEventShape) {
        return new HyperLogEvent(hyperLogEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new HyperLogEvent(hyperLogEventCodec.decode(data));
    }

    static encode(event: HyperLogEvent) {
        return hyperLogEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('hyperLogEvent', data);
    }

    get id(): string { return this.raw.id; }
    get eventType(): string { return this.raw.eventType; }
    get date(): number { return this.raw.date; }
    get body(): any { return this.raw.body; }
}

const hyperLogUserEventCodec = c.struct({
    id: c.string,
    eventType: c.string,
    date: c.integer,
    body: c.any,
});

interface HyperLogUserEventShape {
    id: string;
    eventType: string;
    date: number;
    body: any;
}

export class HyperLogUserEvent extends BaseEvent {

    static create(data: HyperLogUserEventShape) {
        return new HyperLogUserEvent(hyperLogUserEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new HyperLogUserEvent(hyperLogUserEventCodec.decode(data));
    }

    static encode(event: HyperLogUserEvent) {
        return hyperLogUserEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('hyperLogUserEvent', data);
    }

    get id(): string { return this.raw.id; }
    get eventType(): string { return this.raw.eventType; }
    get date(): number { return this.raw.date; }
    get body(): any { return this.raw.body; }
}

const contactAddedEventCodec = c.struct({
    uid: c.integer,
    contactUid: c.integer,
});

interface ContactAddedEventShape {
    uid: number;
    contactUid: number;
}

export class ContactAddedEvent extends BaseEvent {

    static create(data: ContactAddedEventShape) {
        return new ContactAddedEvent(contactAddedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new ContactAddedEvent(contactAddedEventCodec.decode(data));
    }

    static encode(event: ContactAddedEvent) {
        return contactAddedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('contactAddedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get contactUid(): number { return this.raw.contactUid; }
}

const contactRemovedEventCodec = c.struct({
    uid: c.integer,
    contactUid: c.integer,
});

interface ContactRemovedEventShape {
    uid: number;
    contactUid: number;
}

export class ContactRemovedEvent extends BaseEvent {

    static create(data: ContactRemovedEventShape) {
        return new ContactRemovedEvent(contactRemovedEventCodec.normalize(data));
    }

    static decode(data: any) {
        return new ContactRemovedEvent(contactRemovedEventCodec.decode(data));
    }

    static encode(event: ContactRemovedEvent) {
        return contactRemovedEventCodec.encode(event.raw);
    }

    private constructor(data: any) {
        super('contactRemovedEvent', data);
    }

    get uid(): number { return this.raw.uid; }
    get contactUid(): number { return this.raw.contactUid; }
}

export class ConversationEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('conversationEventStore');
        const descriptor = {
            name: 'ConversationEventStore',
            storageKey: 'conversationEventStore',
            subspace,
            storage,
            factory
        };
        return new ConversationEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, cid: number, event: BaseEvent) {
        this._post(ctx, [cid], event);
    }

    async findAll(ctx: Context, cid: number) {
        return this._findAll(ctx, [cid]);
    }

    createStream(cid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([cid], opts);
    }

    createLiveStream(ctx: Context, cid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [cid], opts);
    }
}

export class DialogIndexEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('dialogIndexEventStore');
        const descriptor = {
            name: 'DialogIndexEventStore',
            storageKey: 'dialogIndexEventStore',
            subspace,
            storage,
            factory
        };
        return new DialogIndexEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, event: BaseEvent) {
        this._post(ctx, [], event);
    }

    async findAll(ctx: Context) {
        return this._findAll(ctx, []);
    }

    createStream(opts?: { batchSize?: number, after?: string }) {
        return this._createStream([], opts);
    }

    createLiveStream(ctx: Context, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [], opts);
    }
}

export class UserDialogEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('userDialogEventStore');
        const descriptor = {
            name: 'UserDialogEventStore',
            storageKey: 'userDialogEventStore',
            subspace,
            storage,
            factory
        };
        return new UserDialogEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, uid: number, event: BaseEvent) {
        this._post(ctx, [uid], event);
    }

    async findAll(ctx: Context, uid: number) {
        return this._findAll(ctx, [uid]);
    }

    createStream(uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([uid], opts);
    }

    createLiveStream(ctx: Context, uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [uid], opts);
    }
}

export class FeedEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('feedEventStore');
        const descriptor = {
            name: 'FeedEventStore',
            storageKey: 'feedEventStore',
            subspace,
            storage,
            factory
        };
        return new FeedEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, subscriberId: number, event: BaseEvent) {
        this._post(ctx, [subscriberId], event);
    }

    async findAll(ctx: Context, subscriberId: number) {
        return this._findAll(ctx, [subscriberId]);
    }

    createStream(subscriberId: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([subscriberId], opts);
    }

    createLiveStream(ctx: Context, subscriberId: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [subscriberId], opts);
    }
}

export class FeedGlobalEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('feedGlobalEventStore');
        const descriptor = {
            name: 'FeedGlobalEventStore',
            storageKey: 'feedGlobalEventStore',
            subspace,
            storage,
            factory
        };
        return new FeedGlobalEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, event: BaseEvent) {
        this._post(ctx, [], event);
    }

    async findAll(ctx: Context) {
        return this._findAll(ctx, []);
    }

    createStream(opts?: { batchSize?: number, after?: string }) {
        return this._createStream([], opts);
    }

    createLiveStream(ctx: Context, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [], opts);
    }
}

export class UserLocationEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('userLocationEventStore');
        const descriptor = {
            name: 'UserLocationEventStore',
            storageKey: 'userLocationEventStore',
            subspace,
            storage,
            factory
        };
        return new UserLocationEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, uid: number, event: BaseEvent) {
        this._post(ctx, [uid], event);
    }

    async findAll(ctx: Context, uid: number) {
        return this._findAll(ctx, [uid]);
    }

    createStream(uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([uid], opts);
    }

    createLiveStream(ctx: Context, uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [uid], opts);
    }
}

export class UserWalletUpdates extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('userWalletUpdates');
        const descriptor = {
            name: 'UserWalletUpdates',
            storageKey: 'userWalletUpdates',
            subspace,
            storage,
            factory
        };
        return new UserWalletUpdates(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, uid: number, event: BaseEvent) {
        this._post(ctx, [uid], event);
    }

    async findAll(ctx: Context, uid: number) {
        return this._findAll(ctx, [uid]);
    }

    createStream(uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([uid], opts);
    }

    createLiveStream(ctx: Context, uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [uid], opts);
    }
}

export class StripeEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('stripeEventStore');
        const descriptor = {
            name: 'StripeEventStore',
            storageKey: 'stripeEventStore',
            subspace,
            storage,
            factory
        };
        return new StripeEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, liveMode: boolean, event: BaseEvent) {
        this._post(ctx, [liveMode], event);
    }

    async findAll(ctx: Context, liveMode: boolean) {
        return this._findAll(ctx, [liveMode]);
    }

    createStream(liveMode: boolean, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([liveMode], opts);
    }

    createLiveStream(ctx: Context, liveMode: boolean, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [liveMode], opts);
    }
}

export class HyperLogStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('hyperLogStore');
        const descriptor = {
            name: 'HyperLogStore',
            storageKey: 'hyperLogStore',
            subspace,
            storage,
            factory
        };
        return new HyperLogStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, event: BaseEvent) {
        this._post(ctx, [], event);
    }

    async findAll(ctx: Context) {
        return this._findAll(ctx, []);
    }

    createStream(opts?: { batchSize?: number, after?: string }) {
        return this._createStream([], opts);
    }

    createLiveStream(ctx: Context, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [], opts);
    }
}

export class UserContactsEventStore extends EventStore {

    static async open(storage: EntityStorage, factory: EventFactory) {
        let subspace = await storage.resolveEventStoreDirectory('userContactsEventStore');
        const descriptor = {
            name: 'UserContactsEventStore',
            storageKey: 'userContactsEventStore',
            subspace,
            storage,
            factory
        };
        return new UserContactsEventStore(descriptor);
    }

    private constructor(descriptor: EventStoreDescriptor) {
        super(descriptor);
    }

    post(ctx: Context, uid: number, event: BaseEvent) {
        this._post(ctx, [uid], event);
    }

    async findAll(ctx: Context, uid: number) {
        return this._findAll(ctx, [uid]);
    }

    createStream(uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createStream([uid], opts);
    }

    createLiveStream(ctx: Context, uid: number, opts?: { batchSize?: number, after?: string }) {
        return this._createLiveStream(ctx, [uid], opts);
    }
}

export interface Store extends BaseStore {
    readonly ConversationLastSeq: ConversationLastSeqFactory;
    readonly RoomParticipantsVersion: RoomParticipantsVersionFactory;
    readonly UserDialogReadMessageId: UserDialogReadMessageIdFactory;
    readonly FeedChannelMembersCount: FeedChannelMembersCountFactory;
    readonly FeedChannelPostsCount: FeedChannelPostsCountFactory;
    readonly UserCounter: UserCounterFactory;
    readonly UserMessagesSentCounter: UserMessagesSentCounterFactory;
    readonly UserMessagesSentWeeklyCounter: UserMessagesSentWeeklyCounterFactory;
    readonly UserMessagesSentInDirectChatTotalCounter: UserMessagesSentInDirectChatTotalCounterFactory;
    readonly UserMessagesReceivedCounter: UserMessagesReceivedCounterFactory;
    readonly UserMessagesChatsCounter: UserMessagesChatsCounterFactory;
    readonly UserMessagesChannelsCounter: UserMessagesChannelsCounterFactory;
    readonly UserMessagesDirectChatsCounter: UserMessagesDirectChatsCounterFactory;
    readonly UserSuccessfulInvitesCounter: UserSuccessfulInvitesCounterFactory;
    readonly UserSuccessfulInvitesPrevWeekCounter: UserSuccessfulInvitesPrevWeekCounterFactory;
    readonly UserEmailSentCounter: UserEmailSentCounterFactory;
    readonly UserBrowserPushSentCounter: UserBrowserPushSentCounterFactory;
    readonly UserMobilePushSentCounter: UserMobilePushSentCounterFactory;
    readonly UserEmailSentWeeklyCounter: UserEmailSentWeeklyCounterFactory;
    readonly UserBrowserPushSentWeeklyCounter: UserBrowserPushSentWeeklyCounterFactory;
    readonly UserMobilePushSentWeeklyCounter: UserMobilePushSentWeeklyCounterFactory;
    readonly UserDialogCounter: UserDialogCounterFactory;
    readonly UserDialogHaveMention: UserDialogHaveMentionFactory;
    readonly NotificationCenterCounter: NotificationCenterCounterFactory;
    readonly UserAudienceCounter: UserAudienceCounterFactory;
    readonly UserMessagesSentInDirectChatCounter: UserMessagesSentInDirectChatCounterFactory;
    readonly User2WayDirectChatsCounter: User2WayDirectChatsCounterFactory;
    readonly GlobalStatisticsCounters: GlobalStatisticsCountersFactory;
    readonly UserGlobalCounterAllUnreadMessages: UserGlobalCounterAllUnreadMessagesFactory;
    readonly UserGlobalCounterUnreadMessagesWithoutMuted: UserGlobalCounterUnreadMessagesWithoutMutedFactory;
    readonly UserGlobalCounterAllUnreadChats: UserGlobalCounterAllUnreadChatsFactory;
    readonly UserGlobalCounterUnreadChatsWithoutMuted: UserGlobalCounterUnreadChatsWithoutMutedFactory;
    readonly UserHasFilledAbout: UserHasFilledAboutFactory;
    readonly UserReactionsGot: UserReactionsGotFactory;
    readonly UserReactionsGiven: UserReactionsGivenFactory;
    readonly StatsRecords: StatsRecordsFactory;
    readonly RoomMessagesCounter: RoomMessagesCounterFactory;
    readonly RoomActiveMembersPrevWeekCounter: RoomActiveMembersPrevWeekCounterFactory;
    readonly ReaderEstimate: ReaderEstimateFactory;
    readonly LastAuthEmailSentTime: LastAuthEmailSentTimeFactory;
    readonly AuthEmailsSentCount: AuthEmailsSentCountFactory;
    readonly PhonebookJoinMessageSentForPhone: PhonebookJoinMessageSentForPhoneFactory;
    readonly PhonebookUserImportedContacts: PhonebookUserImportedContactsFactory;
    readonly User: UserFactory;
    readonly UserProfile: UserProfileFactory;
    readonly UserProfilePrefil: UserProfilePrefilFactory;
    readonly UserSettings: UserSettingsFactory;
    readonly UserIndexingQueue: UserIndexingQueueFactory;
    readonly Organization: OrganizationFactory;
    readonly OrganizationProfile: OrganizationProfileFactory;
    readonly OrganizationEditorial: OrganizationEditorialFactory;
    readonly OrganizationMember: OrganizationMemberFactory;
    readonly OrganizationIndexingQueue: OrganizationIndexingQueueFactory;
    readonly Online: OnlineFactory;
    readonly Presence: PresenceFactory;
    readonly Conversation: ConversationFactory;
    readonly ConversationPrivate: ConversationPrivateFactory;
    readonly ConversationOrganization: ConversationOrganizationFactory;
    readonly ConversationRoom: ConversationRoomFactory;
    readonly PremiumChatSettings: PremiumChatSettingsFactory;
    readonly PremiumChatUserPass: PremiumChatUserPassFactory;
    readonly RoomProfile: RoomProfileFactory;
    readonly RoomParticipant: RoomParticipantFactory;
    readonly Message: MessageFactory;
    readonly Comment: CommentFactory;
    readonly RichMessage: RichMessageFactory;
    readonly MessageDraft: MessageDraftFactory;
    readonly ConversationSeq: ConversationSeqFactory;
    readonly ConversationEvent: ConversationEventFactory;
    readonly UserDialog: UserDialogFactory;
    readonly UserDialogHandledMessage: UserDialogHandledMessageFactory;
    readonly UserDialogSettings: UserDialogSettingsFactory;
    readonly UserDialogEvent: UserDialogEventFactory;
    readonly CommentState: CommentStateFactory;
    readonly CommentSeq: CommentSeqFactory;
    readonly CommentEvent: CommentEventFactory;
    readonly CommentsSubscription: CommentsSubscriptionFactory;
    readonly CommentEventGlobal: CommentEventGlobalFactory;
    readonly ConferenceRoom: ConferenceRoomFactory;
    readonly ConferencePeer: ConferencePeerFactory;
    readonly ConferenceEndStream: ConferenceEndStreamFactory;
    readonly ConferenceMeshPeer: ConferenceMeshPeerFactory;
    readonly ConferenceMeshLink: ConferenceMeshLinkFactory;
    readonly ConferenceKitchenRouter: ConferenceKitchenRouterFactory;
    readonly ConferenceKitchenPeer: ConferenceKitchenPeerFactory;
    readonly ConferenceKitchenProducerTransport: ConferenceKitchenProducerTransportFactory;
    readonly ConferenceKitchenConsumerTransport: ConferenceKitchenConsumerTransportFactory;
    readonly KitchenWorker: KitchenWorkerFactory;
    readonly KitchenRouter: KitchenRouterFactory;
    readonly KitchenTransport: KitchenTransportFactory;
    readonly KitchenProducer: KitchenProducerFactory;
    readonly KitchenConsumer: KitchenConsumerFactory;
    readonly UserEdge: UserEdgeFactory;
    readonly UserGroupEdge: UserGroupEdgeFactory;
    readonly UserInfluencerUserIndex: UserInfluencerUserIndexFactory;
    readonly UserInfluencerIndex: UserInfluencerIndexFactory;
    readonly UserBadge: UserBadgeFactory;
    readonly UserRoomBadge: UserRoomBadgeFactory;
    readonly ShortnameReservation: ShortnameReservationFactory;
    readonly NotificationCenter: NotificationCenterFactory;
    readonly UserNotificationCenter: UserNotificationCenterFactory;
    readonly Notification: NotificationFactory;
    readonly NotificationCenterState: NotificationCenterStateFactory;
    readonly NotificationCenterEvent: NotificationCenterEventFactory;
    readonly UserMessagingState: UserMessagingStateFactory;
    readonly UserNotificationsState: UserNotificationsStateFactory;
    readonly FeedSubscriber: FeedSubscriberFactory;
    readonly FeedSubscription: FeedSubscriptionFactory;
    readonly FeedTopic: FeedTopicFactory;
    readonly FeedEvent: FeedEventFactory;
    readonly FeedChannel: FeedChannelFactory;
    readonly FeedChannelAdmin: FeedChannelAdminFactory;
    readonly FeedChannelIndexingQueue: FeedChannelIndexingQueueFactory;
    readonly UserFeedState: UserFeedStateFactory;
    readonly FeedChannelAutoSubscription: FeedChannelAutoSubscriptionFactory;
    readonly ChatAudienceCalculatingQueue: ChatAudienceCalculatingQueueFactory;
    readonly ChannelLink: ChannelLinkFactory;
    readonly AppInviteLink: AppInviteLinkFactory;
    readonly OrganizationPublicInviteLink: OrganizationPublicInviteLinkFactory;
    readonly OrganizationInviteLink: OrganizationInviteLinkFactory;
    readonly ChannelInvitation: ChannelInvitationFactory;
    readonly DiscoverUserPickedTags: DiscoverUserPickedTagsFactory;
    readonly DiscoverState: DiscoverStateFactory;
    readonly UserOnboardingState: UserOnboardingStateFactory;
    readonly PushFirebase: PushFirebaseFactory;
    readonly PushApple: PushAppleFactory;
    readonly PushSafari: PushSafariFactory;
    readonly PushWeb: PushWebFactory;
    readonly AppHook: AppHookFactory;
    readonly StickerPack: StickerPackFactory;
    readonly UserStickersState: UserStickersStateFactory;
    readonly Sticker: StickerFactory;
    readonly MatchmakingRoom: MatchmakingRoomFactory;
    readonly MatchmakingProfile: MatchmakingProfileFactory;
    readonly OauthApplication: OauthApplicationFactory;
    readonly OauthContext: OauthContextFactory;
    readonly OauthToken: OauthTokenFactory;
    readonly UserLocation: UserLocationFactory;
    readonly Powerup: PowerupFactory;
    readonly ChatPowerup: ChatPowerupFactory;
    readonly PermissionRequest: PermissionRequestFactory;
    readonly UserStorageNamespace: UserStorageNamespaceFactory;
    readonly UserStorageRecord: UserStorageRecordFactory;
    readonly UserStripeCustomer: UserStripeCustomerFactory;
    readonly UserStripeCard: UserStripeCardFactory;
    readonly Wallet: WalletFactory;
    readonly WalletTransaction: WalletTransactionFactory;
    readonly WalletDepositRequest: WalletDepositRequestFactory;
    readonly WalletTransferRequest: WalletTransferRequestFactory;
    readonly WalletPurchase: WalletPurchaseFactory;
    readonly WalletSubscription: WalletSubscriptionFactory;
    readonly WalletSubscriptionScheduling: WalletSubscriptionSchedulingFactory;
    readonly WalletSubscriptionPeriod: WalletSubscriptionPeriodFactory;
    readonly PaymentIntent: PaymentIntentFactory;
    readonly Payment: PaymentFactory;
    readonly PaymentScheduling: PaymentSchedulingFactory;
    readonly StripeEventsCursor: StripeEventsCursorFactory;
    readonly StripeEvent: StripeEventFactory;
    readonly Sequence: SequenceFactory;
    readonly Environment: EnvironmentFactory;
    readonly EnvironmentVariable: EnvironmentVariableFactory;
    readonly ServiceCache: ServiceCacheFactory;
    readonly ReaderState: ReaderStateFactory;
    readonly SuperAdmin: SuperAdminFactory;
    readonly AuthToken: AuthTokenFactory;
    readonly AuthCodeSession: AuthCodeSessionFactory;
    readonly FeatureFlag: FeatureFlagFactory;
    readonly OrganizationFeatures: OrganizationFeaturesFactory;
    readonly HyperLog: HyperLogFactory;
    readonly HyperLogType: HyperLogTypeFactory;
    readonly Task: TaskFactory;
    readonly DelayedTask: DelayedTaskFactory;
    readonly ServiceThrottle: ServiceThrottleFactory;
    readonly OneTimeCode: OneTimeCodeFactory;
    readonly DebugEvent: DebugEventFactory;
    readonly DebugEventState: DebugEventStateFactory;
    readonly EntityCounterState: EntityCounterStateFactory;
    readonly GqlTrace: GqlTraceFactory;
    readonly EntityCleanerState: EntityCleanerStateFactory;
    readonly EditorsChoiceChatsCollection: EditorsChoiceChatsCollectionFactory;
    readonly EditorsChoiceChat: EditorsChoiceChatFactory;
    readonly ClickHouseMigrations: ClickHouseMigrationsFactory;
    readonly DiscussionHub: DiscussionHubFactory;
    readonly Discussion: DiscussionFactory;
    readonly DiscussionDraft: DiscussionDraftFactory;
    readonly Contact: ContactFactory;
    readonly PhonebookItem: PhonebookItemFactory;
    readonly ConversationEventStore: ConversationEventStore;
    readonly DialogIndexEventStore: DialogIndexEventStore;
    readonly UserDialogEventStore: UserDialogEventStore;
    readonly FeedEventStore: FeedEventStore;
    readonly FeedGlobalEventStore: FeedGlobalEventStore;
    readonly UserLocationEventStore: UserLocationEventStore;
    readonly UserWalletUpdates: UserWalletUpdates;
    readonly StripeEventStore: StripeEventStore;
    readonly HyperLogStore: HyperLogStore;
    readonly UserContactsEventStore: UserContactsEventStore;
    readonly PresenceLogDirectory: Subspace;
    readonly RoomParticipantsActiveDirectory: Subspace;
    readonly MessageDeliveryDirectory: Subspace;
    readonly MessageDeliveryBatchDirectory: Subspace;
    readonly UserDialogIndexDirectory: Subspace;
    readonly UserCountersIndexDirectory: Subspace;
    readonly UserDialogMuteSettingDirectory: Subspace;
    readonly NotificationCenterNeedDeliveryFlagDirectory: Subspace;
    readonly NeedNotificationFlagDirectory: Subspace;
    readonly ImportedPhoneDirectory: Subspace;
    readonly PhoneImportedByUserDirectory: Subspace;
    readonly DeliveryFanOutQueue: QueueStorage;
    readonly DeliveryUserBatchQueue: QueueStorage;
    readonly PushDeliveryQueue: QueueStorage;
    readonly PushFirebaseDeliveryQueue: QueueStorage;
    readonly PushAppleDeliveryQueue: QueueStorage;
    readonly PushWebDeliveryQueue: QueueStorage;
    readonly EmailSendQueue: QueueStorage;
}

export async function openStore(storage: EntityStorage): Promise<Store> {
    const eventFactory = new EventFactory();
    eventFactory.registerEventType('chatUpdatedEvent', ChatUpdatedEvent.encode as any, ChatUpdatedEvent.decode);
    eventFactory.registerEventType('messageReceivedEvent', MessageReceivedEvent.encode as any, MessageReceivedEvent.decode);
    eventFactory.registerEventType('messageUpdatedEvent', MessageUpdatedEvent.encode as any, MessageUpdatedEvent.decode);
    eventFactory.registerEventType('messageDeletedEvent', MessageDeletedEvent.encode as any, MessageDeletedEvent.decode);
    eventFactory.registerEventType('dialogNeedReindexEvent', DialogNeedReindexEvent.encode as any, DialogNeedReindexEvent.decode);
    eventFactory.registerEventType('userDialogMessageReceivedEvent', UserDialogMessageReceivedEvent.encode as any, UserDialogMessageReceivedEvent.decode);
    eventFactory.registerEventType('userDialogMessageUpdatedEvent', UserDialogMessageUpdatedEvent.encode as any, UserDialogMessageUpdatedEvent.decode);
    eventFactory.registerEventType('userDialogMessageDeletedEvent', UserDialogMessageDeletedEvent.encode as any, UserDialogMessageDeletedEvent.decode);
    eventFactory.registerEventType('userDialogMessageReadEvent', UserDialogMessageReadEvent.encode as any, UserDialogMessageReadEvent.decode);
    eventFactory.registerEventType('userDialogTitleUpdatedEvent', UserDialogTitleUpdatedEvent.encode as any, UserDialogTitleUpdatedEvent.decode);
    eventFactory.registerEventType('userDialogDeletedEvent', UserDialogDeletedEvent.encode as any, UserDialogDeletedEvent.decode);
    eventFactory.registerEventType('userDialogBumpEvent', UserDialogBumpEvent.encode as any, UserDialogBumpEvent.decode);
    eventFactory.registerEventType('userDialogPhotoUpdatedEvent', UserDialogPhotoUpdatedEvent.encode as any, UserDialogPhotoUpdatedEvent.decode);
    eventFactory.registerEventType('userDialogMuteChangedEvent', UserDialogMuteChangedEvent.encode as any, UserDialogMuteChangedEvent.decode);
    eventFactory.registerEventType('userDialogPeerUpdatedEvent', UserDialogPeerUpdatedEvent.encode as any, UserDialogPeerUpdatedEvent.decode);
    eventFactory.registerEventType('userDialogCallStateChangedEvent', UserDialogCallStateChangedEvent.encode as any, UserDialogCallStateChangedEvent.decode);
    eventFactory.registerEventType('userDialogGotAccessEvent', UserDialogGotAccessEvent.encode as any, UserDialogGotAccessEvent.decode);
    eventFactory.registerEventType('userDialogLostAccessEvent', UserDialogLostAccessEvent.encode as any, UserDialogLostAccessEvent.decode);
    eventFactory.registerEventType('feedItemReceivedEvent', FeedItemReceivedEvent.encode as any, FeedItemReceivedEvent.decode);
    eventFactory.registerEventType('feedItemUpdatedEvent', FeedItemUpdatedEvent.encode as any, FeedItemUpdatedEvent.decode);
    eventFactory.registerEventType('feedItemDeletedEvent', FeedItemDeletedEvent.encode as any, FeedItemDeletedEvent.decode);
    eventFactory.registerEventType('feedRebuildEvent', FeedRebuildEvent.encode as any, FeedRebuildEvent.decode);
    eventFactory.registerEventType('userLocationUpdatedEvent', UserLocationUpdatedEvent.encode as any, UserLocationUpdatedEvent.decode);
    eventFactory.registerEventType('userLocationStopSharingEvent', UserLocationStopSharingEvent.encode as any, UserLocationStopSharingEvent.decode);
    eventFactory.registerEventType('walletTransactionPending', WalletTransactionPending.encode as any, WalletTransactionPending.decode);
    eventFactory.registerEventType('walletTransactionSuccess', WalletTransactionSuccess.encode as any, WalletTransactionSuccess.decode);
    eventFactory.registerEventType('walletTransactionCanceled', WalletTransactionCanceled.encode as any, WalletTransactionCanceled.decode);
    eventFactory.registerEventType('paymentStatusChanged', PaymentStatusChanged.encode as any, PaymentStatusChanged.decode);
    eventFactory.registerEventType('walletBalanceChanged', WalletBalanceChanged.encode as any, WalletBalanceChanged.decode);
    eventFactory.registerEventType('walletLockedChanged', WalletLockedChanged.encode as any, WalletLockedChanged.decode);
    eventFactory.registerEventType('stripeEventCreated', StripeEventCreated.encode as any, StripeEventCreated.decode);
    eventFactory.registerEventType('hyperLogEvent', HyperLogEvent.encode as any, HyperLogEvent.decode);
    eventFactory.registerEventType('hyperLogUserEvent', HyperLogUserEvent.encode as any, HyperLogUserEvent.decode);
    eventFactory.registerEventType('contactAddedEvent', ContactAddedEvent.encode as any, ContactAddedEvent.decode);
    eventFactory.registerEventType('contactRemovedEvent', ContactRemovedEvent.encode as any, ContactRemovedEvent.decode);
    let ConversationLastSeqPromise = ConversationLastSeqFactory.open(storage);
    let RoomParticipantsVersionPromise = RoomParticipantsVersionFactory.open(storage);
    let UserDialogReadMessageIdPromise = UserDialogReadMessageIdFactory.open(storage);
    let FeedChannelMembersCountPromise = FeedChannelMembersCountFactory.open(storage);
    let FeedChannelPostsCountPromise = FeedChannelPostsCountFactory.open(storage);
    let UserCounterPromise = UserCounterFactory.open(storage);
    let UserMessagesSentCounterPromise = UserMessagesSentCounterFactory.open(storage);
    let UserMessagesSentWeeklyCounterPromise = UserMessagesSentWeeklyCounterFactory.open(storage);
    let UserMessagesSentInDirectChatTotalCounterPromise = UserMessagesSentInDirectChatTotalCounterFactory.open(storage);
    let UserMessagesReceivedCounterPromise = UserMessagesReceivedCounterFactory.open(storage);
    let UserMessagesChatsCounterPromise = UserMessagesChatsCounterFactory.open(storage);
    let UserMessagesChannelsCounterPromise = UserMessagesChannelsCounterFactory.open(storage);
    let UserMessagesDirectChatsCounterPromise = UserMessagesDirectChatsCounterFactory.open(storage);
    let UserSuccessfulInvitesCounterPromise = UserSuccessfulInvitesCounterFactory.open(storage);
    let UserSuccessfulInvitesPrevWeekCounterPromise = UserSuccessfulInvitesPrevWeekCounterFactory.open(storage);
    let UserEmailSentCounterPromise = UserEmailSentCounterFactory.open(storage);
    let UserBrowserPushSentCounterPromise = UserBrowserPushSentCounterFactory.open(storage);
    let UserMobilePushSentCounterPromise = UserMobilePushSentCounterFactory.open(storage);
    let UserEmailSentWeeklyCounterPromise = UserEmailSentWeeklyCounterFactory.open(storage);
    let UserBrowserPushSentWeeklyCounterPromise = UserBrowserPushSentWeeklyCounterFactory.open(storage);
    let UserMobilePushSentWeeklyCounterPromise = UserMobilePushSentWeeklyCounterFactory.open(storage);
    let UserDialogCounterPromise = UserDialogCounterFactory.open(storage);
    let UserDialogHaveMentionPromise = UserDialogHaveMentionFactory.open(storage);
    let NotificationCenterCounterPromise = NotificationCenterCounterFactory.open(storage);
    let UserAudienceCounterPromise = UserAudienceCounterFactory.open(storage);
    let UserMessagesSentInDirectChatCounterPromise = UserMessagesSentInDirectChatCounterFactory.open(storage);
    let User2WayDirectChatsCounterPromise = User2WayDirectChatsCounterFactory.open(storage);
    let GlobalStatisticsCountersPromise = GlobalStatisticsCountersFactory.open(storage);
    let UserGlobalCounterAllUnreadMessagesPromise = UserGlobalCounterAllUnreadMessagesFactory.open(storage);
    let UserGlobalCounterUnreadMessagesWithoutMutedPromise = UserGlobalCounterUnreadMessagesWithoutMutedFactory.open(storage);
    let UserGlobalCounterAllUnreadChatsPromise = UserGlobalCounterAllUnreadChatsFactory.open(storage);
    let UserGlobalCounterUnreadChatsWithoutMutedPromise = UserGlobalCounterUnreadChatsWithoutMutedFactory.open(storage);
    let UserHasFilledAboutPromise = UserHasFilledAboutFactory.open(storage);
    let UserReactionsGotPromise = UserReactionsGotFactory.open(storage);
    let UserReactionsGivenPromise = UserReactionsGivenFactory.open(storage);
    let StatsRecordsPromise = StatsRecordsFactory.open(storage);
    let RoomMessagesCounterPromise = RoomMessagesCounterFactory.open(storage);
    let RoomActiveMembersPrevWeekCounterPromise = RoomActiveMembersPrevWeekCounterFactory.open(storage);
    let ReaderEstimatePromise = ReaderEstimateFactory.open(storage);
    let LastAuthEmailSentTimePromise = LastAuthEmailSentTimeFactory.open(storage);
    let AuthEmailsSentCountPromise = AuthEmailsSentCountFactory.open(storage);
    let PhonebookJoinMessageSentForPhonePromise = PhonebookJoinMessageSentForPhoneFactory.open(storage);
    let PhonebookUserImportedContactsPromise = PhonebookUserImportedContactsFactory.open(storage);
    let UserPromise = UserFactory.open(storage);
    let UserProfilePromise = UserProfileFactory.open(storage);
    let UserProfilePrefilPromise = UserProfilePrefilFactory.open(storage);
    let UserSettingsPromise = UserSettingsFactory.open(storage);
    let UserIndexingQueuePromise = UserIndexingQueueFactory.open(storage);
    let OrganizationPromise = OrganizationFactory.open(storage);
    let OrganizationProfilePromise = OrganizationProfileFactory.open(storage);
    let OrganizationEditorialPromise = OrganizationEditorialFactory.open(storage);
    let OrganizationMemberPromise = OrganizationMemberFactory.open(storage);
    let OrganizationIndexingQueuePromise = OrganizationIndexingQueueFactory.open(storage);
    let OnlinePromise = OnlineFactory.open(storage);
    let PresencePromise = PresenceFactory.open(storage);
    let ConversationPromise = ConversationFactory.open(storage);
    let ConversationPrivatePromise = ConversationPrivateFactory.open(storage);
    let ConversationOrganizationPromise = ConversationOrganizationFactory.open(storage);
    let ConversationRoomPromise = ConversationRoomFactory.open(storage);
    let PremiumChatSettingsPromise = PremiumChatSettingsFactory.open(storage);
    let PremiumChatUserPassPromise = PremiumChatUserPassFactory.open(storage);
    let RoomProfilePromise = RoomProfileFactory.open(storage);
    let RoomParticipantPromise = RoomParticipantFactory.open(storage);
    let MessagePromise = MessageFactory.open(storage);
    let CommentPromise = CommentFactory.open(storage);
    let RichMessagePromise = RichMessageFactory.open(storage);
    let MessageDraftPromise = MessageDraftFactory.open(storage);
    let ConversationSeqPromise = ConversationSeqFactory.open(storage);
    let ConversationEventPromise = ConversationEventFactory.open(storage);
    let UserDialogPromise = UserDialogFactory.open(storage);
    let UserDialogHandledMessagePromise = UserDialogHandledMessageFactory.open(storage);
    let UserDialogSettingsPromise = UserDialogSettingsFactory.open(storage);
    let UserDialogEventPromise = UserDialogEventFactory.open(storage);
    let CommentStatePromise = CommentStateFactory.open(storage);
    let CommentSeqPromise = CommentSeqFactory.open(storage);
    let CommentEventPromise = CommentEventFactory.open(storage);
    let CommentsSubscriptionPromise = CommentsSubscriptionFactory.open(storage);
    let CommentEventGlobalPromise = CommentEventGlobalFactory.open(storage);
    let ConferenceRoomPromise = ConferenceRoomFactory.open(storage);
    let ConferencePeerPromise = ConferencePeerFactory.open(storage);
    let ConferenceEndStreamPromise = ConferenceEndStreamFactory.open(storage);
    let ConferenceMeshPeerPromise = ConferenceMeshPeerFactory.open(storage);
    let ConferenceMeshLinkPromise = ConferenceMeshLinkFactory.open(storage);
    let ConferenceKitchenRouterPromise = ConferenceKitchenRouterFactory.open(storage);
    let ConferenceKitchenPeerPromise = ConferenceKitchenPeerFactory.open(storage);
    let ConferenceKitchenProducerTransportPromise = ConferenceKitchenProducerTransportFactory.open(storage);
    let ConferenceKitchenConsumerTransportPromise = ConferenceKitchenConsumerTransportFactory.open(storage);
    let KitchenWorkerPromise = KitchenWorkerFactory.open(storage);
    let KitchenRouterPromise = KitchenRouterFactory.open(storage);
    let KitchenTransportPromise = KitchenTransportFactory.open(storage);
    let KitchenProducerPromise = KitchenProducerFactory.open(storage);
    let KitchenConsumerPromise = KitchenConsumerFactory.open(storage);
    let UserEdgePromise = UserEdgeFactory.open(storage);
    let UserGroupEdgePromise = UserGroupEdgeFactory.open(storage);
    let UserInfluencerUserIndexPromise = UserInfluencerUserIndexFactory.open(storage);
    let UserInfluencerIndexPromise = UserInfluencerIndexFactory.open(storage);
    let UserBadgePromise = UserBadgeFactory.open(storage);
    let UserRoomBadgePromise = UserRoomBadgeFactory.open(storage);
    let ShortnameReservationPromise = ShortnameReservationFactory.open(storage);
    let NotificationCenterPromise = NotificationCenterFactory.open(storage);
    let UserNotificationCenterPromise = UserNotificationCenterFactory.open(storage);
    let NotificationPromise = NotificationFactory.open(storage);
    let NotificationCenterStatePromise = NotificationCenterStateFactory.open(storage);
    let NotificationCenterEventPromise = NotificationCenterEventFactory.open(storage);
    let UserMessagingStatePromise = UserMessagingStateFactory.open(storage);
    let UserNotificationsStatePromise = UserNotificationsStateFactory.open(storage);
    let FeedSubscriberPromise = FeedSubscriberFactory.open(storage);
    let FeedSubscriptionPromise = FeedSubscriptionFactory.open(storage);
    let FeedTopicPromise = FeedTopicFactory.open(storage);
    let FeedEventPromise = FeedEventFactory.open(storage);
    let FeedChannelPromise = FeedChannelFactory.open(storage);
    let FeedChannelAdminPromise = FeedChannelAdminFactory.open(storage);
    let FeedChannelIndexingQueuePromise = FeedChannelIndexingQueueFactory.open(storage);
    let UserFeedStatePromise = UserFeedStateFactory.open(storage);
    let FeedChannelAutoSubscriptionPromise = FeedChannelAutoSubscriptionFactory.open(storage);
    let ChatAudienceCalculatingQueuePromise = ChatAudienceCalculatingQueueFactory.open(storage);
    let ChannelLinkPromise = ChannelLinkFactory.open(storage);
    let AppInviteLinkPromise = AppInviteLinkFactory.open(storage);
    let OrganizationPublicInviteLinkPromise = OrganizationPublicInviteLinkFactory.open(storage);
    let OrganizationInviteLinkPromise = OrganizationInviteLinkFactory.open(storage);
    let ChannelInvitationPromise = ChannelInvitationFactory.open(storage);
    let DiscoverUserPickedTagsPromise = DiscoverUserPickedTagsFactory.open(storage);
    let DiscoverStatePromise = DiscoverStateFactory.open(storage);
    let UserOnboardingStatePromise = UserOnboardingStateFactory.open(storage);
    let PushFirebasePromise = PushFirebaseFactory.open(storage);
    let PushApplePromise = PushAppleFactory.open(storage);
    let PushSafariPromise = PushSafariFactory.open(storage);
    let PushWebPromise = PushWebFactory.open(storage);
    let AppHookPromise = AppHookFactory.open(storage);
    let StickerPackPromise = StickerPackFactory.open(storage);
    let UserStickersStatePromise = UserStickersStateFactory.open(storage);
    let StickerPromise = StickerFactory.open(storage);
    let MatchmakingRoomPromise = MatchmakingRoomFactory.open(storage);
    let MatchmakingProfilePromise = MatchmakingProfileFactory.open(storage);
    let OauthApplicationPromise = OauthApplicationFactory.open(storage);
    let OauthContextPromise = OauthContextFactory.open(storage);
    let OauthTokenPromise = OauthTokenFactory.open(storage);
    let UserLocationPromise = UserLocationFactory.open(storage);
    let PowerupPromise = PowerupFactory.open(storage);
    let ChatPowerupPromise = ChatPowerupFactory.open(storage);
    let PermissionRequestPromise = PermissionRequestFactory.open(storage);
    let UserStorageNamespacePromise = UserStorageNamespaceFactory.open(storage);
    let UserStorageRecordPromise = UserStorageRecordFactory.open(storage);
    let UserStripeCustomerPromise = UserStripeCustomerFactory.open(storage);
    let UserStripeCardPromise = UserStripeCardFactory.open(storage);
    let WalletPromise = WalletFactory.open(storage);
    let WalletTransactionPromise = WalletTransactionFactory.open(storage);
    let WalletDepositRequestPromise = WalletDepositRequestFactory.open(storage);
    let WalletTransferRequestPromise = WalletTransferRequestFactory.open(storage);
    let WalletPurchasePromise = WalletPurchaseFactory.open(storage);
    let WalletSubscriptionPromise = WalletSubscriptionFactory.open(storage);
    let WalletSubscriptionSchedulingPromise = WalletSubscriptionSchedulingFactory.open(storage);
    let WalletSubscriptionPeriodPromise = WalletSubscriptionPeriodFactory.open(storage);
    let PaymentIntentPromise = PaymentIntentFactory.open(storage);
    let PaymentPromise = PaymentFactory.open(storage);
    let PaymentSchedulingPromise = PaymentSchedulingFactory.open(storage);
    let StripeEventsCursorPromise = StripeEventsCursorFactory.open(storage);
    let StripeEventPromise = StripeEventFactory.open(storage);
    let SequencePromise = SequenceFactory.open(storage);
    let EnvironmentPromise = EnvironmentFactory.open(storage);
    let EnvironmentVariablePromise = EnvironmentVariableFactory.open(storage);
    let ServiceCachePromise = ServiceCacheFactory.open(storage);
    let ReaderStatePromise = ReaderStateFactory.open(storage);
    let SuperAdminPromise = SuperAdminFactory.open(storage);
    let AuthTokenPromise = AuthTokenFactory.open(storage);
    let AuthCodeSessionPromise = AuthCodeSessionFactory.open(storage);
    let FeatureFlagPromise = FeatureFlagFactory.open(storage);
    let OrganizationFeaturesPromise = OrganizationFeaturesFactory.open(storage);
    let HyperLogPromise = HyperLogFactory.open(storage);
    let HyperLogTypePromise = HyperLogTypeFactory.open(storage);
    let TaskPromise = TaskFactory.open(storage);
    let DelayedTaskPromise = DelayedTaskFactory.open(storage);
    let ServiceThrottlePromise = ServiceThrottleFactory.open(storage);
    let OneTimeCodePromise = OneTimeCodeFactory.open(storage);
    let DebugEventPromise = DebugEventFactory.open(storage);
    let DebugEventStatePromise = DebugEventStateFactory.open(storage);
    let EntityCounterStatePromise = EntityCounterStateFactory.open(storage);
    let GqlTracePromise = GqlTraceFactory.open(storage);
    let EntityCleanerStatePromise = EntityCleanerStateFactory.open(storage);
    let EditorsChoiceChatsCollectionPromise = EditorsChoiceChatsCollectionFactory.open(storage);
    let EditorsChoiceChatPromise = EditorsChoiceChatFactory.open(storage);
    let ClickHouseMigrationsPromise = ClickHouseMigrationsFactory.open(storage);
    let DiscussionHubPromise = DiscussionHubFactory.open(storage);
    let DiscussionPromise = DiscussionFactory.open(storage);
    let DiscussionDraftPromise = DiscussionDraftFactory.open(storage);
    let ContactPromise = ContactFactory.open(storage);
    let PhonebookItemPromise = PhonebookItemFactory.open(storage);
    let PresenceLogDirectoryPromise = storage.resolveCustomDirectory('presenceLog');
    let RoomParticipantsActiveDirectoryPromise = storage.resolveCustomDirectory('roomParticipantsActive');
    let MessageDeliveryDirectoryPromise = storage.resolveCustomDirectory('messageDelivery');
    let MessageDeliveryBatchDirectoryPromise = storage.resolveCustomDirectory('messageDeliveryBatch');
    let UserDialogIndexDirectoryPromise = storage.resolveCustomDirectory('userDialogIndex');
    let UserCountersIndexDirectoryPromise = storage.resolveCustomDirectory('userCountersIndex');
    let UserDialogMuteSettingDirectoryPromise = storage.resolveCustomDirectory('userDialogMuteSetting');
    let NotificationCenterNeedDeliveryFlagDirectoryPromise = storage.resolveCustomDirectory('notificationCenterNeedDeliveryFlag');
    let NeedNotificationFlagDirectoryPromise = storage.resolveCustomDirectory('needNotificationFlag');
    let ImportedPhoneDirectoryPromise = storage.resolveCustomDirectory('importedPhone');
    let PhoneImportedByUserDirectoryPromise = storage.resolveCustomDirectory('phoneImportedByUser');
    let ConversationEventStorePromise = ConversationEventStore.open(storage, eventFactory);
    let DialogIndexEventStorePromise = DialogIndexEventStore.open(storage, eventFactory);
    let UserDialogEventStorePromise = UserDialogEventStore.open(storage, eventFactory);
    let FeedEventStorePromise = FeedEventStore.open(storage, eventFactory);
    let FeedGlobalEventStorePromise = FeedGlobalEventStore.open(storage, eventFactory);
    let UserLocationEventStorePromise = UserLocationEventStore.open(storage, eventFactory);
    let UserWalletUpdatesPromise = UserWalletUpdates.open(storage, eventFactory);
    let StripeEventStorePromise = StripeEventStore.open(storage, eventFactory);
    let HyperLogStorePromise = HyperLogStore.open(storage, eventFactory);
    let UserContactsEventStorePromise = UserContactsEventStore.open(storage, eventFactory);
    let DeliveryFanOutQueuePromise = QueueStorage.open('DeliveryFanOut', storage);
    let DeliveryUserBatchQueuePromise = QueueStorage.open('DeliveryUserBatch', storage);
    let PushDeliveryQueuePromise = QueueStorage.open('PushDelivery', storage);
    let PushFirebaseDeliveryQueuePromise = QueueStorage.open('PushFirebaseDelivery', storage);
    let PushAppleDeliveryQueuePromise = QueueStorage.open('PushAppleDelivery', storage);
    let PushWebDeliveryQueuePromise = QueueStorage.open('PushWebDelivery', storage);
    let EmailSendQueuePromise = QueueStorage.open('EmailSend', storage);
    return {
        storage,
        eventFactory,
        ConversationLastSeq: await ConversationLastSeqPromise,
        RoomParticipantsVersion: await RoomParticipantsVersionPromise,
        UserDialogReadMessageId: await UserDialogReadMessageIdPromise,
        FeedChannelMembersCount: await FeedChannelMembersCountPromise,
        FeedChannelPostsCount: await FeedChannelPostsCountPromise,
        UserCounter: await UserCounterPromise,
        UserMessagesSentCounter: await UserMessagesSentCounterPromise,
        UserMessagesSentWeeklyCounter: await UserMessagesSentWeeklyCounterPromise,
        UserMessagesSentInDirectChatTotalCounter: await UserMessagesSentInDirectChatTotalCounterPromise,
        UserMessagesReceivedCounter: await UserMessagesReceivedCounterPromise,
        UserMessagesChatsCounter: await UserMessagesChatsCounterPromise,
        UserMessagesChannelsCounter: await UserMessagesChannelsCounterPromise,
        UserMessagesDirectChatsCounter: await UserMessagesDirectChatsCounterPromise,
        UserSuccessfulInvitesCounter: await UserSuccessfulInvitesCounterPromise,
        UserSuccessfulInvitesPrevWeekCounter: await UserSuccessfulInvitesPrevWeekCounterPromise,
        UserEmailSentCounter: await UserEmailSentCounterPromise,
        UserBrowserPushSentCounter: await UserBrowserPushSentCounterPromise,
        UserMobilePushSentCounter: await UserMobilePushSentCounterPromise,
        UserEmailSentWeeklyCounter: await UserEmailSentWeeklyCounterPromise,
        UserBrowserPushSentWeeklyCounter: await UserBrowserPushSentWeeklyCounterPromise,
        UserMobilePushSentWeeklyCounter: await UserMobilePushSentWeeklyCounterPromise,
        UserDialogCounter: await UserDialogCounterPromise,
        UserDialogHaveMention: await UserDialogHaveMentionPromise,
        NotificationCenterCounter: await NotificationCenterCounterPromise,
        UserAudienceCounter: await UserAudienceCounterPromise,
        UserMessagesSentInDirectChatCounter: await UserMessagesSentInDirectChatCounterPromise,
        User2WayDirectChatsCounter: await User2WayDirectChatsCounterPromise,
        GlobalStatisticsCounters: await GlobalStatisticsCountersPromise,
        UserGlobalCounterAllUnreadMessages: await UserGlobalCounterAllUnreadMessagesPromise,
        UserGlobalCounterUnreadMessagesWithoutMuted: await UserGlobalCounterUnreadMessagesWithoutMutedPromise,
        UserGlobalCounterAllUnreadChats: await UserGlobalCounterAllUnreadChatsPromise,
        UserGlobalCounterUnreadChatsWithoutMuted: await UserGlobalCounterUnreadChatsWithoutMutedPromise,
        UserHasFilledAbout: await UserHasFilledAboutPromise,
        UserReactionsGot: await UserReactionsGotPromise,
        UserReactionsGiven: await UserReactionsGivenPromise,
        StatsRecords: await StatsRecordsPromise,
        RoomMessagesCounter: await RoomMessagesCounterPromise,
        RoomActiveMembersPrevWeekCounter: await RoomActiveMembersPrevWeekCounterPromise,
        ReaderEstimate: await ReaderEstimatePromise,
        LastAuthEmailSentTime: await LastAuthEmailSentTimePromise,
        AuthEmailsSentCount: await AuthEmailsSentCountPromise,
        PhonebookJoinMessageSentForPhone: await PhonebookJoinMessageSentForPhonePromise,
        PhonebookUserImportedContacts: await PhonebookUserImportedContactsPromise,
        User: await UserPromise,
        UserProfile: await UserProfilePromise,
        UserProfilePrefil: await UserProfilePrefilPromise,
        UserSettings: await UserSettingsPromise,
        UserIndexingQueue: await UserIndexingQueuePromise,
        Organization: await OrganizationPromise,
        OrganizationProfile: await OrganizationProfilePromise,
        OrganizationEditorial: await OrganizationEditorialPromise,
        OrganizationMember: await OrganizationMemberPromise,
        OrganizationIndexingQueue: await OrganizationIndexingQueuePromise,
        Online: await OnlinePromise,
        Presence: await PresencePromise,
        Conversation: await ConversationPromise,
        ConversationPrivate: await ConversationPrivatePromise,
        ConversationOrganization: await ConversationOrganizationPromise,
        ConversationRoom: await ConversationRoomPromise,
        PremiumChatSettings: await PremiumChatSettingsPromise,
        PremiumChatUserPass: await PremiumChatUserPassPromise,
        RoomProfile: await RoomProfilePromise,
        RoomParticipant: await RoomParticipantPromise,
        Message: await MessagePromise,
        Comment: await CommentPromise,
        RichMessage: await RichMessagePromise,
        MessageDraft: await MessageDraftPromise,
        ConversationSeq: await ConversationSeqPromise,
        ConversationEvent: await ConversationEventPromise,
        UserDialog: await UserDialogPromise,
        UserDialogHandledMessage: await UserDialogHandledMessagePromise,
        UserDialogSettings: await UserDialogSettingsPromise,
        UserDialogEvent: await UserDialogEventPromise,
        CommentState: await CommentStatePromise,
        CommentSeq: await CommentSeqPromise,
        CommentEvent: await CommentEventPromise,
        CommentsSubscription: await CommentsSubscriptionPromise,
        CommentEventGlobal: await CommentEventGlobalPromise,
        ConferenceRoom: await ConferenceRoomPromise,
        ConferencePeer: await ConferencePeerPromise,
        ConferenceEndStream: await ConferenceEndStreamPromise,
        ConferenceMeshPeer: await ConferenceMeshPeerPromise,
        ConferenceMeshLink: await ConferenceMeshLinkPromise,
        ConferenceKitchenRouter: await ConferenceKitchenRouterPromise,
        ConferenceKitchenPeer: await ConferenceKitchenPeerPromise,
        ConferenceKitchenProducerTransport: await ConferenceKitchenProducerTransportPromise,
        ConferenceKitchenConsumerTransport: await ConferenceKitchenConsumerTransportPromise,
        KitchenWorker: await KitchenWorkerPromise,
        KitchenRouter: await KitchenRouterPromise,
        KitchenTransport: await KitchenTransportPromise,
        KitchenProducer: await KitchenProducerPromise,
        KitchenConsumer: await KitchenConsumerPromise,
        UserEdge: await UserEdgePromise,
        UserGroupEdge: await UserGroupEdgePromise,
        UserInfluencerUserIndex: await UserInfluencerUserIndexPromise,
        UserInfluencerIndex: await UserInfluencerIndexPromise,
        UserBadge: await UserBadgePromise,
        UserRoomBadge: await UserRoomBadgePromise,
        ShortnameReservation: await ShortnameReservationPromise,
        NotificationCenter: await NotificationCenterPromise,
        UserNotificationCenter: await UserNotificationCenterPromise,
        Notification: await NotificationPromise,
        NotificationCenterState: await NotificationCenterStatePromise,
        NotificationCenterEvent: await NotificationCenterEventPromise,
        UserMessagingState: await UserMessagingStatePromise,
        UserNotificationsState: await UserNotificationsStatePromise,
        FeedSubscriber: await FeedSubscriberPromise,
        FeedSubscription: await FeedSubscriptionPromise,
        FeedTopic: await FeedTopicPromise,
        FeedEvent: await FeedEventPromise,
        FeedChannel: await FeedChannelPromise,
        FeedChannelAdmin: await FeedChannelAdminPromise,
        FeedChannelIndexingQueue: await FeedChannelIndexingQueuePromise,
        UserFeedState: await UserFeedStatePromise,
        FeedChannelAutoSubscription: await FeedChannelAutoSubscriptionPromise,
        ChatAudienceCalculatingQueue: await ChatAudienceCalculatingQueuePromise,
        ChannelLink: await ChannelLinkPromise,
        AppInviteLink: await AppInviteLinkPromise,
        OrganizationPublicInviteLink: await OrganizationPublicInviteLinkPromise,
        OrganizationInviteLink: await OrganizationInviteLinkPromise,
        ChannelInvitation: await ChannelInvitationPromise,
        DiscoverUserPickedTags: await DiscoverUserPickedTagsPromise,
        DiscoverState: await DiscoverStatePromise,
        UserOnboardingState: await UserOnboardingStatePromise,
        PushFirebase: await PushFirebasePromise,
        PushApple: await PushApplePromise,
        PushSafari: await PushSafariPromise,
        PushWeb: await PushWebPromise,
        AppHook: await AppHookPromise,
        StickerPack: await StickerPackPromise,
        UserStickersState: await UserStickersStatePromise,
        Sticker: await StickerPromise,
        MatchmakingRoom: await MatchmakingRoomPromise,
        MatchmakingProfile: await MatchmakingProfilePromise,
        OauthApplication: await OauthApplicationPromise,
        OauthContext: await OauthContextPromise,
        OauthToken: await OauthTokenPromise,
        UserLocation: await UserLocationPromise,
        Powerup: await PowerupPromise,
        ChatPowerup: await ChatPowerupPromise,
        PermissionRequest: await PermissionRequestPromise,
        UserStorageNamespace: await UserStorageNamespacePromise,
        UserStorageRecord: await UserStorageRecordPromise,
        UserStripeCustomer: await UserStripeCustomerPromise,
        UserStripeCard: await UserStripeCardPromise,
        Wallet: await WalletPromise,
        WalletTransaction: await WalletTransactionPromise,
        WalletDepositRequest: await WalletDepositRequestPromise,
        WalletTransferRequest: await WalletTransferRequestPromise,
        WalletPurchase: await WalletPurchasePromise,
        WalletSubscription: await WalletSubscriptionPromise,
        WalletSubscriptionScheduling: await WalletSubscriptionSchedulingPromise,
        WalletSubscriptionPeriod: await WalletSubscriptionPeriodPromise,
        PaymentIntent: await PaymentIntentPromise,
        Payment: await PaymentPromise,
        PaymentScheduling: await PaymentSchedulingPromise,
        StripeEventsCursor: await StripeEventsCursorPromise,
        StripeEvent: await StripeEventPromise,
        Sequence: await SequencePromise,
        Environment: await EnvironmentPromise,
        EnvironmentVariable: await EnvironmentVariablePromise,
        ServiceCache: await ServiceCachePromise,
        ReaderState: await ReaderStatePromise,
        SuperAdmin: await SuperAdminPromise,
        AuthToken: await AuthTokenPromise,
        AuthCodeSession: await AuthCodeSessionPromise,
        FeatureFlag: await FeatureFlagPromise,
        OrganizationFeatures: await OrganizationFeaturesPromise,
        HyperLog: await HyperLogPromise,
        HyperLogType: await HyperLogTypePromise,
        Task: await TaskPromise,
        DelayedTask: await DelayedTaskPromise,
        ServiceThrottle: await ServiceThrottlePromise,
        OneTimeCode: await OneTimeCodePromise,
        DebugEvent: await DebugEventPromise,
        DebugEventState: await DebugEventStatePromise,
        EntityCounterState: await EntityCounterStatePromise,
        GqlTrace: await GqlTracePromise,
        EntityCleanerState: await EntityCleanerStatePromise,
        EditorsChoiceChatsCollection: await EditorsChoiceChatsCollectionPromise,
        EditorsChoiceChat: await EditorsChoiceChatPromise,
        ClickHouseMigrations: await ClickHouseMigrationsPromise,
        DiscussionHub: await DiscussionHubPromise,
        Discussion: await DiscussionPromise,
        DiscussionDraft: await DiscussionDraftPromise,
        Contact: await ContactPromise,
        PhonebookItem: await PhonebookItemPromise,
        PresenceLogDirectory: await PresenceLogDirectoryPromise,
        RoomParticipantsActiveDirectory: await RoomParticipantsActiveDirectoryPromise,
        MessageDeliveryDirectory: await MessageDeliveryDirectoryPromise,
        MessageDeliveryBatchDirectory: await MessageDeliveryBatchDirectoryPromise,
        UserDialogIndexDirectory: await UserDialogIndexDirectoryPromise,
        UserCountersIndexDirectory: await UserCountersIndexDirectoryPromise,
        UserDialogMuteSettingDirectory: await UserDialogMuteSettingDirectoryPromise,
        NotificationCenterNeedDeliveryFlagDirectory: await NotificationCenterNeedDeliveryFlagDirectoryPromise,
        NeedNotificationFlagDirectory: await NeedNotificationFlagDirectoryPromise,
        ImportedPhoneDirectory: await ImportedPhoneDirectoryPromise,
        PhoneImportedByUserDirectory: await PhoneImportedByUserDirectoryPromise,
        ConversationEventStore: await ConversationEventStorePromise,
        DialogIndexEventStore: await DialogIndexEventStorePromise,
        UserDialogEventStore: await UserDialogEventStorePromise,
        FeedEventStore: await FeedEventStorePromise,
        FeedGlobalEventStore: await FeedGlobalEventStorePromise,
        UserLocationEventStore: await UserLocationEventStorePromise,
        UserWalletUpdates: await UserWalletUpdatesPromise,
        StripeEventStore: await StripeEventStorePromise,
        HyperLogStore: await HyperLogStorePromise,
        UserContactsEventStore: await UserContactsEventStorePromise,
        DeliveryFanOutQueue: await DeliveryFanOutQueuePromise,
        DeliveryUserBatchQueue: await DeliveryUserBatchQueuePromise,
        PushDeliveryQueue: await PushDeliveryQueuePromise,
        PushFirebaseDeliveryQueue: await PushFirebaseDeliveryQueuePromise,
        PushAppleDeliveryQueue: await PushAppleDeliveryQueuePromise,
        PushWebDeliveryQueue: await PushWebDeliveryQueuePromise,
        EmailSendQueue: await EmailSendQueuePromise,
    };
}
