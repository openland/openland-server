// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
import { FDBInstance } from 'foundation-orm/FDBInstance';
import { FEntity } from 'foundation-orm/FEntity';
import { FEntitySchema } from 'foundation-orm/FEntitySchema';
import { FEntityIndex } from 'foundation-orm/FEntityIndex';
import { FNamespace } from 'foundation-orm/FNamespace';
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
import { FConnection } from 'foundation-orm/FConnection';
import { validators } from 'foundation-orm/utils/validators';

export interface OnlineShape {
    lastSeen: number;
}

export class Online extends FEntity {
    get uid(): number { return this._value.uid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
}

export class OnlineFactory extends FEntityFactory<Online> {
    static schema: FEntitySchema = {
        name: 'Online',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'lastSeen', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('lastSeen', src.lastSeen);
        validators.isNumber('lastSeen', src.lastSeen);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'online'),
            { enableVersioning: false, enableTimestamps: false, validator: OnlineFactory.validate, hasLiveStreams: false },
            [],
            'Online'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(uid: number) {
        return await this._findById([uid]);
    }
    async create(uid: number, shape: OnlineShape) {
        return await this._create([uid], { uid, ...shape });
    }
    watch(uid: number, cb: () => void) {
        return this._watch([uid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Online(this.connection, this.namespace, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'Online');
    }
}
export interface PresenceShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
}

export class Presence extends FEntity {
    get uid(): number { return this._value.uid; }
    get tid(): string { return this._value.tid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
    get lastSeenTimeout(): number {
        return this._value.lastSeenTimeout;
    }
    set lastSeenTimeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeenTimeout) { return; }
        this._value.lastSeenTimeout = value;
        this.markDirty();
    }
    get platform(): string {
        return this._value.platform;
    }
    set platform(value: string) {
        this._checkIsWritable();
        if (value === this._value.platform) { return; }
        this._value.platform = value;
        this.markDirty();
    }
}

export class PresenceFactory extends FEntityFactory<Presence> {
    static schema: FEntitySchema = {
        name: 'Presence',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
        ],
        fields: [
            { name: 'lastSeen', type: 'number' },
            { name: 'lastSeenTimeout', type: 'number' },
            { name: 'platform', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('lastSeen', src.lastSeen);
        validators.isNumber('lastSeen', src.lastSeen);
        validators.notNull('lastSeenTimeout', src.lastSeenTimeout);
        validators.isNumber('lastSeenTimeout', src.lastSeenTimeout);
        validators.notNull('platform', src.platform);
        validators.isString('platform', src.platform);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'presence'),
            { enableVersioning: false, enableTimestamps: false, validator: PresenceFactory.validate, hasLiveStreams: false },
            [],
            'Presence'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'tid': rawId[1] };
    }
    async findById(uid: number, tid: string) {
        return await this._findById([uid, tid]);
    }
    async create(uid: number, tid: string, shape: PresenceShape) {
        return await this._create([uid, tid], { uid, tid, ...shape });
    }
    watch(uid: number, tid: string, cb: () => void) {
        return this._watch([uid, tid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Presence(this.connection, this.namespace, this.directory, [value.uid, value.tid], value, this.options, isNew, this.indexes, 'Presence');
    }
}
export interface AuthTokenShape {
    salt: string;
    uid: number;
    lastIp: string;
}

export class AuthToken extends FEntity {
    get uuid(): string { return this._value.uuid; }
    get salt(): string {
        return this._value.salt;
    }
    set salt(value: string) {
        this._checkIsWritable();
        if (value === this._value.salt) { return; }
        this._value.salt = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get lastIp(): string {
        return this._value.lastIp;
    }
    set lastIp(value: string) {
        this._checkIsWritable();
        if (value === this._value.lastIp) { return; }
        this._value.lastIp = value;
        this.markDirty();
    }
}

export class AuthTokenFactory extends FEntityFactory<AuthToken> {
    static schema: FEntitySchema = {
        name: 'AuthToken',
        editable: false,
        primaryKeys: [
            { name: 'uuid', type: 'string' },
        ],
        fields: [
            { name: 'salt', type: 'string' },
            { name: 'uid', type: 'number' },
            { name: 'lastIp', type: 'string' },
        ],
        indexes: [
            { name: 'salt', type: 'unique', fields: ['salt'], displayName: 'authTokenBySalt' },
        ],
    };

    private static validate(src: any) {
        validators.notNull('uuid', src.uuid);
        validators.isString('uuid', src.uuid);
        validators.notNull('salt', src.salt);
        validators.isString('salt', src.salt);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('lastIp', src.lastIp);
        validators.isString('lastIp', src.lastIp);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'authToken'),
            { enableVersioning: true, enableTimestamps: true, validator: AuthTokenFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('salt', ['salt'], true)],
            'AuthToken'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uuid': rawId[0] };
    }
    async findById(uuid: string) {
        return await this._findById([uuid]);
    }
    async create(uuid: string, shape: AuthTokenShape) {
        return await this._create([uuid], { uuid, ...shape });
    }
    watch(uuid: string, cb: () => void) {
        return this._watch([uuid], cb);
    }
    async findFromSalt(salt: string) {
        return await this._findFromIndex(['__indexes', 'salt', salt]);
    }
    async rangeFromSalt(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'salt'], limit, reversed);
    }
    async rangeFromSaltWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'salt'], limit, after, reversed);
    }
    async allFromSalt() {
        return await this._findAll(['__indexes', 'salt']);
    }
    createSaltStream(limit: number, after?: string) {
        return this._createStream(['entity', 'authToken', '__indexes', 'salt'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new AuthToken(this.connection, this.namespace, this.directory, [value.uuid], value, this.options, isNew, this.indexes, 'AuthToken');
    }
}
export interface ServiceCacheShape {
    value: string;
}

export class ServiceCache extends FEntity {
    get service(): string { return this._value.service; }
    get key(): string { return this._value.key; }
    get value(): string {
        return this._value.value;
    }
    set value(value: string) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class ServiceCacheFactory extends FEntityFactory<ServiceCache> {
    static schema: FEntitySchema = {
        name: 'ServiceCache',
        editable: false,
        primaryKeys: [
            { name: 'service', type: 'string' },
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'value', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('service', src.service);
        validators.isString('service', src.service);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('value', src.value);
        validators.isString('value', src.value);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'serviceCache'),
            { enableVersioning: true, enableTimestamps: true, validator: ServiceCacheFactory.validate, hasLiveStreams: false },
            [],
            'ServiceCache'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'service': rawId[0], 'key': rawId[1] };
    }
    async findById(service: string, key: string) {
        return await this._findById([service, key]);
    }
    async create(service: string, key: string, shape: ServiceCacheShape) {
        return await this._create([service, key], { service, key, ...shape });
    }
    watch(service: string, key: string, cb: () => void) {
        return this._watch([service, key], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ServiceCache(this.connection, this.namespace, this.directory, [value.service, value.key], value, this.options, isNew, this.indexes, 'ServiceCache');
    }
}
export interface LockShape {
    seed: string;
    timeout: number;
    version: number;
    minVersion: number;
}

export class Lock extends FEntity {
    get key(): string { return this._value.key; }
    get seed(): string {
        return this._value.seed;
    }
    set seed(value: string) {
        this._checkIsWritable();
        if (value === this._value.seed) { return; }
        this._value.seed = value;
        this.markDirty();
    }
    get timeout(): number {
        return this._value.timeout;
    }
    set timeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.timeout) { return; }
        this._value.timeout = value;
        this.markDirty();
    }
    get version(): number {
        return this._value.version;
    }
    set version(value: number) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
    get minVersion(): number {
        return this._value.minVersion;
    }
    set minVersion(value: number) {
        this._checkIsWritable();
        if (value === this._value.minVersion) { return; }
        this._value.minVersion = value;
        this.markDirty();
    }
}

export class LockFactory extends FEntityFactory<Lock> {
    static schema: FEntitySchema = {
        name: 'Lock',
        editable: false,
        primaryKeys: [
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'seed', type: 'string' },
            { name: 'timeout', type: 'number' },
            { name: 'version', type: 'number' },
            { name: 'minVersion', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('seed', src.seed);
        validators.isString('seed', src.seed);
        validators.notNull('timeout', src.timeout);
        validators.isNumber('timeout', src.timeout);
        validators.notNull('version', src.version);
        validators.isNumber('version', src.version);
        validators.notNull('minVersion', src.minVersion);
        validators.isNumber('minVersion', src.minVersion);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'lock'),
            { enableVersioning: false, enableTimestamps: false, validator: LockFactory.validate, hasLiveStreams: false },
            [],
            'Lock'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'key': rawId[0] };
    }
    async findById(key: string) {
        return await this._findById([key]);
    }
    async create(key: string, shape: LockShape) {
        return await this._create([key], { key, ...shape });
    }
    watch(key: string, cb: () => void) {
        return this._watch([key], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Lock(this.connection, this.namespace, this.directory, [value.key], value, this.options, isNew, this.indexes, 'Lock');
    }
}
export interface TaskShape {
    arguments: any;
    result?: any| null;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureCount?: number| null;
    taskFailureTime?: number| null;
    taskLockSeed?: string| null;
    taskLockTimeout?: number| null;
    taskFailureMessage?: string| null;
}

export class Task extends FEntity {
    get taskType(): string { return this._value.taskType; }
    get uid(): string { return this._value.uid; }
    get arguments(): any {
        return this._value.arguments;
    }
    set arguments(value: any) {
        this._checkIsWritable();
        if (value === this._value.arguments) { return; }
        this._value.arguments = value;
        this.markDirty();
    }
    get result(): any | null {
        let res = this._value.result;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set result(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.result) { return; }
        this._value.result = value;
        this.markDirty();
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' {
        return this._value.taskStatus;
    }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.taskStatus) { return; }
        this._value.taskStatus = value;
        this.markDirty();
    }
    get taskFailureCount(): number | null {
        let res = this._value.taskFailureCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureCount) { return; }
        this._value.taskFailureCount = value;
        this.markDirty();
    }
    get taskFailureTime(): number | null {
        let res = this._value.taskFailureTime;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureTime(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureTime) { return; }
        this._value.taskFailureTime = value;
        this.markDirty();
    }
    get taskLockSeed(): string | null {
        let res = this._value.taskLockSeed;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskLockSeed(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockSeed) { return; }
        this._value.taskLockSeed = value;
        this.markDirty();
    }
    get taskLockTimeout(): number | null {
        let res = this._value.taskLockTimeout;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskLockTimeout(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockTimeout) { return; }
        this._value.taskLockTimeout = value;
        this.markDirty();
    }
    get taskFailureMessage(): string | null {
        let res = this._value.taskFailureMessage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureMessage(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureMessage) { return; }
        this._value.taskFailureMessage = value;
        this.markDirty();
    }
}

export class TaskFactory extends FEntityFactory<Task> {
    static schema: FEntitySchema = {
        name: 'Task',
        editable: false,
        primaryKeys: [
            { name: 'taskType', type: 'string' },
            { name: 'uid', type: 'string' },
        ],
        fields: [
            { name: 'arguments', type: 'json' },
            { name: 'result', type: 'json' },
            { name: 'taskStatus', type: 'enum', enumValues: ['pending', 'executing', 'failing', 'failed', 'completed'] },
            { name: 'taskFailureCount', type: 'number' },
            { name: 'taskFailureTime', type: 'number' },
            { name: 'taskLockSeed', type: 'string' },
            { name: 'taskLockTimeout', type: 'number' },
            { name: 'taskFailureMessage', type: 'string' },
        ],
        indexes: [
            { name: 'pending', type: 'range', fields: ['taskType', 'createdAt'], displayName: 'tasksPending' },
            { name: 'executing', type: 'range', fields: ['taskLockTimeout'], displayName: 'tasksExecuting' },
            { name: 'failing', type: 'range', fields: ['taskFailureTime'], displayName: 'tasksFailing' },
        ],
    };

    private static validate(src: any) {
        validators.notNull('taskType', src.taskType);
        validators.isString('taskType', src.taskType);
        validators.notNull('uid', src.uid);
        validators.isString('uid', src.uid);
        validators.notNull('arguments', src.arguments);
        validators.notNull('taskStatus', src.taskStatus);
        validators.isEnum('taskStatus', src.taskStatus, ['pending', 'executing', 'failing', 'failed', 'completed']);
        validators.isNumber('taskFailureCount', src.taskFailureCount);
        validators.isNumber('taskFailureTime', src.taskFailureTime);
        validators.isString('taskLockSeed', src.taskLockSeed);
        validators.isNumber('taskLockTimeout', src.taskLockTimeout);
        validators.isString('taskFailureMessage', src.taskFailureMessage);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'task'),
            { enableVersioning: true, enableTimestamps: true, validator: TaskFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('pending', ['taskType', 'createdAt'], false, (src) => src.taskStatus === 'pending'), new FEntityIndex('executing', ['taskLockTimeout'], false, (src) => src.taskStatus === 'executing'), new FEntityIndex('failing', ['taskFailureTime'], false, (src) => src.taskStatus === 'failing')],
            'Task'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'taskType': rawId[0], 'uid': rawId[1] };
    }
    async findById(taskType: string, uid: string) {
        return await this._findById([taskType, uid]);
    }
    async create(taskType: string, uid: string, shape: TaskShape) {
        return await this._create([taskType, uid], { taskType, uid, ...shape });
    }
    watch(taskType: string, uid: string, cb: () => void) {
        return this._watch([taskType, uid], cb);
    }
    async allFromPendingAfter(taskType: string, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'pending', taskType], after);
    }
    async rangeFromPendingAfter(taskType: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'pending', taskType], after, limit, reversed);
    }
    async rangeFromPending(taskType: string, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'pending', taskType], limit, reversed);
    }
    async rangeFromPendingWithCursor(taskType: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'pending', taskType], limit, after, reversed);
    }
    async allFromPending(taskType: string) {
        return await this._findAll(['__indexes', 'pending', taskType]);
    }
    createPendingStream(taskType: string, limit: number, after?: string) {
        return this._createStream(['entity', 'task', '__indexes', 'pending', taskType], limit, after); 
    }
    async rangeFromExecuting(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'executing'], limit, reversed);
    }
    async rangeFromExecutingWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'executing'], limit, after, reversed);
    }
    async allFromExecuting() {
        return await this._findAll(['__indexes', 'executing']);
    }
    createExecutingStream(limit: number, after?: string) {
        return this._createStream(['entity', 'task', '__indexes', 'executing'], limit, after); 
    }
    async rangeFromFailing(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'failing'], limit, reversed);
    }
    async rangeFromFailingWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'failing'], limit, after, reversed);
    }
    async allFromFailing() {
        return await this._findAll(['__indexes', 'failing']);
    }
    createFailingStream(limit: number, after?: string) {
        return this._createStream(['entity', 'task', '__indexes', 'failing'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Task(this.connection, this.namespace, this.directory, [value.taskType, value.uid], value, this.options, isNew, this.indexes, 'Task');
    }
}
export interface PushFirebaseShape {
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushFirebase extends FEntity {
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get token(): string {
        return this._value.token;
    }
    set token(value: string) {
        this._checkIsWritable();
        if (value === this._value.token) { return; }
        this._value.token = value;
        this.markDirty();
    }
    get packageId(): string {
        return this._value.packageId;
    }
    set packageId(value: string) {
        this._checkIsWritable();
        if (value === this._value.packageId) { return; }
        this._value.packageId = value;
        this.markDirty();
    }
    get sandbox(): boolean {
        return this._value.sandbox;
    }
    set sandbox(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.sandbox) { return; }
        this._value.sandbox = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushFirebaseFactory extends FEntityFactory<PushFirebase> {
    static schema: FEntitySchema = {
        name: 'PushFirebase',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'token', type: 'string', secure: true },
            { name: 'packageId', type: 'string' },
            { name: 'sandbox', type: 'boolean' },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'token', type: 'unique', fields: ['token'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('token', src.token);
        validators.isString('token', src.token);
        validators.notNull('packageId', src.packageId);
        validators.isString('packageId', src.packageId);
        validators.notNull('sandbox', src.sandbox);
        validators.isBoolean('sandbox', src.sandbox);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'pushFirebase'),
            { enableVersioning: true, enableTimestamps: true, validator: PushFirebaseFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['uid', 'id'], false), new FEntityIndex('token', ['token'], true, src => src.enabled)],
            'PushFirebase'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: PushFirebaseShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromUserAfter(uid: number, after: string) {
        return await this._findRangeAllAfter(['__indexes', 'user', uid], after);
    }
    async rangeFromUserAfter(uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', uid], after, limit, reversed);
    }
    async rangeFromUser(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', uid], limit, reversed);
    }
    async rangeFromUserWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', uid], limit, after, reversed);
    }
    async allFromUser(uid: number) {
        return await this._findAll(['__indexes', 'user', uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'pushFirebase', '__indexes', 'user', uid], limit, after); 
    }
    async findFromToken(token: string) {
        return await this._findFromIndex(['__indexes', 'token', token]);
    }
    async rangeFromToken(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'token'], limit, reversed);
    }
    async rangeFromTokenWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'token'], limit, after, reversed);
    }
    async allFromToken() {
        return await this._findAll(['__indexes', 'token']);
    }
    createTokenStream(limit: number, after?: string) {
        return this._createStream(['entity', 'pushFirebase', '__indexes', 'token'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new PushFirebase(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushFirebase');
    }
}
export interface PushAppleShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushApple extends FEntity {
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get token(): string {
        return this._value.token;
    }
    set token(value: string) {
        this._checkIsWritable();
        if (value === this._value.token) { return; }
        this._value.token = value;
        this.markDirty();
    }
    get bundleId(): string {
        return this._value.bundleId;
    }
    set bundleId(value: string) {
        this._checkIsWritable();
        if (value === this._value.bundleId) { return; }
        this._value.bundleId = value;
        this.markDirty();
    }
    get sandbox(): boolean {
        return this._value.sandbox;
    }
    set sandbox(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.sandbox) { return; }
        this._value.sandbox = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushAppleFactory extends FEntityFactory<PushApple> {
    static schema: FEntitySchema = {
        name: 'PushApple',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'token', type: 'string', secure: true },
            { name: 'bundleId', type: 'string' },
            { name: 'sandbox', type: 'boolean' },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'token', type: 'unique', fields: ['token'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('token', src.token);
        validators.isString('token', src.token);
        validators.notNull('bundleId', src.bundleId);
        validators.isString('bundleId', src.bundleId);
        validators.notNull('sandbox', src.sandbox);
        validators.isBoolean('sandbox', src.sandbox);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'pushApple'),
            { enableVersioning: true, enableTimestamps: true, validator: PushAppleFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['uid', 'id'], false), new FEntityIndex('token', ['token'], true, src => src.enabled)],
            'PushApple'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: PushAppleShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromUserAfter(uid: number, after: string) {
        return await this._findRangeAllAfter(['__indexes', 'user', uid], after);
    }
    async rangeFromUserAfter(uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', uid], after, limit, reversed);
    }
    async rangeFromUser(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', uid], limit, reversed);
    }
    async rangeFromUserWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', uid], limit, after, reversed);
    }
    async allFromUser(uid: number) {
        return await this._findAll(['__indexes', 'user', uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'pushApple', '__indexes', 'user', uid], limit, after); 
    }
    async findFromToken(token: string) {
        return await this._findFromIndex(['__indexes', 'token', token]);
    }
    async rangeFromToken(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'token'], limit, reversed);
    }
    async rangeFromTokenWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'token'], limit, after, reversed);
    }
    async allFromToken() {
        return await this._findAll(['__indexes', 'token']);
    }
    createTokenStream(limit: number, after?: string) {
        return this._createStream(['entity', 'pushApple', '__indexes', 'token'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new PushApple(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushApple');
    }
}
export interface PushWebShape {
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushWeb extends FEntity {
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get endpoint(): string {
        return this._value.endpoint;
    }
    set endpoint(value: string) {
        this._checkIsWritable();
        if (value === this._value.endpoint) { return; }
        this._value.endpoint = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushWebFactory extends FEntityFactory<PushWeb> {
    static schema: FEntitySchema = {
        name: 'PushWeb',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'endpoint', type: 'string', secure: true },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'endpoint', type: 'unique', fields: ['endpoint'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('endpoint', src.endpoint);
        validators.isString('endpoint', src.endpoint);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'pushWeb'),
            { enableVersioning: true, enableTimestamps: true, validator: PushWebFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['uid', 'id'], false), new FEntityIndex('endpoint', ['endpoint'], true, src => src.enabled)],
            'PushWeb'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: PushWebShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromUserAfter(uid: number, after: string) {
        return await this._findRangeAllAfter(['__indexes', 'user', uid], after);
    }
    async rangeFromUserAfter(uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', uid], after, limit, reversed);
    }
    async rangeFromUser(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', uid], limit, reversed);
    }
    async rangeFromUserWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', uid], limit, after, reversed);
    }
    async allFromUser(uid: number) {
        return await this._findAll(['__indexes', 'user', uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'pushWeb', '__indexes', 'user', uid], limit, after); 
    }
    async findFromEndpoint(endpoint: string) {
        return await this._findFromIndex(['__indexes', 'endpoint', endpoint]);
    }
    async rangeFromEndpoint(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'endpoint'], limit, reversed);
    }
    async rangeFromEndpointWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'endpoint'], limit, after, reversed);
    }
    async allFromEndpoint() {
        return await this._findAll(['__indexes', 'endpoint']);
    }
    createEndpointStream(limit: number, after?: string) {
        return this._createStream(['entity', 'pushWeb', '__indexes', 'endpoint'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new PushWeb(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushWeb');
    }
}
export interface UserProfilePrefilShape {
    firstName?: string| null;
    lastName?: string| null;
    picture?: string| null;
}

export class UserProfilePrefil extends FEntity {
    get id(): number { return this._value.id; }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get picture(): string | null {
        let res = this._value.picture;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set picture(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.picture) { return; }
        this._value.picture = value;
        this.markDirty();
    }
}

export class UserProfilePrefilFactory extends FEntityFactory<UserProfilePrefil> {
    static schema: FEntitySchema = {
        name: 'UserProfilePrefil',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'picture', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('picture', src.picture);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userProfilePrefil'),
            { enableVersioning: true, enableTimestamps: true, validator: UserProfilePrefilFactory.validate, hasLiveStreams: false },
            [],
            'UserProfilePrefil'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: UserProfilePrefilShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserProfilePrefil(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserProfilePrefil');
    }
}
export interface UserShape {
    authId: string;
    email: string;
    isBot: boolean;
    invitedBy?: number| null;
    botOwner?: number| null;
    status: 'pending' | 'activated' | 'suspended';
}

export class User extends FEntity {
    get id(): number { return this._value.id; }
    get authId(): string {
        return this._value.authId;
    }
    set authId(value: string) {
        this._checkIsWritable();
        if (value === this._value.authId) { return; }
        this._value.authId = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get isBot(): boolean {
        return this._value.isBot;
    }
    set isBot(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isBot) { return; }
        this._value.isBot = value;
        this.markDirty();
    }
    get invitedBy(): number | null {
        let res = this._value.invitedBy;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set invitedBy(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get botOwner(): number | null {
        let res = this._value.botOwner;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set botOwner(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.botOwner) { return; }
        this._value.botOwner = value;
        this.markDirty();
    }
    get status(): 'pending' | 'activated' | 'suspended' {
        return this._value.status;
    }
    set status(value: 'pending' | 'activated' | 'suspended') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class UserFactory extends FEntityFactory<User> {
    static schema: FEntitySchema = {
        name: 'User',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'authId', type: 'string' },
            { name: 'email', type: 'string' },
            { name: 'isBot', type: 'boolean' },
            { name: 'invitedBy', type: 'number' },
            { name: 'botOwner', type: 'number' },
            { name: 'status', type: 'enum', enumValues: ['pending', 'activated', 'suspended'] },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('authId', src.authId);
        validators.isString('authId', src.authId);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.notNull('isBot', src.isBot);
        validators.isBoolean('isBot', src.isBot);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.isNumber('botOwner', src.botOwner);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['pending', 'activated', 'suspended']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'user'),
            { enableVersioning: false, enableTimestamps: false, validator: UserFactory.validate, hasLiveStreams: false },
            [],
            'User'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: UserShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new User(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'User');
    }
}
export interface UserProfileShape {
    firstName: string;
    lastName?: string| null;
    phone?: string| null;
    about?: string| null;
    website?: string| null;
    location?: string| null;
    email?: string| null;
    picture?: any| null;
    linkedin?: string| null;
    twitter?: string| null;
    locations?: any| null;
    primaryOrganization?: number| null;
    role?: string| null;
}

export class UserProfile extends FEntity {
    get id(): number { return this._value.id; }
    get firstName(): string {
        return this._value.firstName;
    }
    set firstName(value: string) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get phone(): string | null {
        let res = this._value.phone;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set phone(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.phone) { return; }
        this._value.phone = value;
        this.markDirty();
    }
    get about(): string | null {
        let res = this._value.about;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set about(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.about) { return; }
        this._value.about = value;
        this.markDirty();
    }
    get website(): string | null {
        let res = this._value.website;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set website(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.website) { return; }
        this._value.website = value;
        this.markDirty();
    }
    get location(): string | null {
        let res = this._value.location;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set location(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.location) { return; }
        this._value.location = value;
        this.markDirty();
    }
    get email(): string | null {
        let res = this._value.email;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set email(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get picture(): any | null {
        let res = this._value.picture;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set picture(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.picture) { return; }
        this._value.picture = value;
        this.markDirty();
    }
    get linkedin(): string | null {
        let res = this._value.linkedin;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set linkedin(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.linkedin) { return; }
        this._value.linkedin = value;
        this.markDirty();
    }
    get twitter(): string | null {
        let res = this._value.twitter;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set twitter(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.twitter) { return; }
        this._value.twitter = value;
        this.markDirty();
    }
    get locations(): any | null {
        let res = this._value.locations;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set locations(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.locations) { return; }
        this._value.locations = value;
        this.markDirty();
    }
    get primaryOrganization(): number | null {
        let res = this._value.primaryOrganization;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set primaryOrganization(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.primaryOrganization) { return; }
        this._value.primaryOrganization = value;
        this.markDirty();
    }
    get role(): string | null {
        let res = this._value.role;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set role(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
}

export class UserProfileFactory extends FEntityFactory<UserProfile> {
    static schema: FEntitySchema = {
        name: 'UserProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'phone', type: 'string' },
            { name: 'about', type: 'string' },
            { name: 'website', type: 'string' },
            { name: 'location', type: 'string' },
            { name: 'email', type: 'string' },
            { name: 'picture', type: 'json' },
            { name: 'linkedin', type: 'string' },
            { name: 'twitter', type: 'string' },
            { name: 'locations', type: 'json' },
            { name: 'primaryOrganization', type: 'number' },
            { name: 'role', type: 'string' },
        ],
        indexes: [
            { name: 'byUpdatedAt', type: 'range', fields: ['updatedAt'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('firstName', src.firstName);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('phone', src.phone);
        validators.isString('about', src.about);
        validators.isString('website', src.website);
        validators.isString('location', src.location);
        validators.isString('email', src.email);
        validators.isString('linkedin', src.linkedin);
        validators.isString('twitter', src.twitter);
        validators.isNumber('primaryOrganization', src.primaryOrganization);
        validators.isString('role', src.role);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userProfile'),
            { enableVersioning: true, enableTimestamps: true, validator: UserProfileFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('byUpdatedAt', ['updatedAt'], false)],
            'UserProfile'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: UserProfileShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    async rangeFromByUpdatedAt(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'byUpdatedAt'], limit, reversed);
    }
    async rangeFromByUpdatedAtWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'byUpdatedAt'], limit, after, reversed);
    }
    async allFromByUpdatedAt() {
        return await this._findAll(['__indexes', 'byUpdatedAt']);
    }
    createByUpdatedAtStream(limit: number, after?: string) {
        return this._createStream(['entity', 'userProfile', '__indexes', 'byUpdatedAt'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserProfile(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserProfile');
    }
}
export interface OrganizationShape {
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended';
    kind: 'organization' | 'community';
    editorial: boolean;
}

export class Organization extends FEntity {
    get id(): number { return this._value.id; }
    get ownerId(): number {
        return this._value.ownerId;
    }
    set ownerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get status(): 'pending' | 'activated' | 'suspended' {
        return this._value.status;
    }
    set status(value: 'pending' | 'activated' | 'suspended') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
    get kind(): 'organization' | 'community' {
        return this._value.kind;
    }
    set kind(value: 'organization' | 'community') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get editorial(): boolean {
        return this._value.editorial;
    }
    set editorial(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.editorial) { return; }
        this._value.editorial = value;
        this.markDirty();
    }
}

export class OrganizationFactory extends FEntityFactory<Organization> {
    static schema: FEntitySchema = {
        name: 'Organization',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'ownerId', type: 'number' },
            { name: 'status', type: 'enum', enumValues: ['pending', 'activated', 'suspended'] },
            { name: 'kind', type: 'enum', enumValues: ['organization', 'community'] },
            { name: 'editorial', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('ownerId', src.ownerId);
        validators.isNumber('ownerId', src.ownerId);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['pending', 'activated', 'suspended']);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['organization', 'community']);
        validators.notNull('editorial', src.editorial);
        validators.isBoolean('editorial', src.editorial);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organization'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationFactory.validate, hasLiveStreams: false },
            [],
            'Organization'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: OrganizationShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Organization(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Organization');
    }
}
export interface OrganizationProfileShape {
    name: string;
    photo?: any| null;
    about?: string| null;
    twitter?: string| null;
    facebook?: string| null;
    linkedin?: string| null;
    website?: string| null;
}

export class OrganizationProfile extends FEntity {
    get id(): number { return this._value.id; }
    get name(): string {
        return this._value.name;
    }
    set name(value: string) {
        this._checkIsWritable();
        if (value === this._value.name) { return; }
        this._value.name = value;
        this.markDirty();
    }
    get photo(): any | null {
        let res = this._value.photo;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set photo(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.photo) { return; }
        this._value.photo = value;
        this.markDirty();
    }
    get about(): string | null {
        let res = this._value.about;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set about(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.about) { return; }
        this._value.about = value;
        this.markDirty();
    }
    get twitter(): string | null {
        let res = this._value.twitter;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set twitter(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.twitter) { return; }
        this._value.twitter = value;
        this.markDirty();
    }
    get facebook(): string | null {
        let res = this._value.facebook;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set facebook(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.facebook) { return; }
        this._value.facebook = value;
        this.markDirty();
    }
    get linkedin(): string | null {
        let res = this._value.linkedin;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set linkedin(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.linkedin) { return; }
        this._value.linkedin = value;
        this.markDirty();
    }
    get website(): string | null {
        let res = this._value.website;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set website(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.website) { return; }
        this._value.website = value;
        this.markDirty();
    }
}

export class OrganizationProfileFactory extends FEntityFactory<OrganizationProfile> {
    static schema: FEntitySchema = {
        name: 'OrganizationProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'name', type: 'string' },
            { name: 'photo', type: 'json' },
            { name: 'about', type: 'string' },
            { name: 'twitter', type: 'string' },
            { name: 'facebook', type: 'string' },
            { name: 'linkedin', type: 'string' },
            { name: 'website', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('name', src.name);
        validators.isString('name', src.name);
        validators.isString('about', src.about);
        validators.isString('twitter', src.twitter);
        validators.isString('facebook', src.facebook);
        validators.isString('linkedin', src.linkedin);
        validators.isString('website', src.website);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationProfile'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationProfileFactory.validate, hasLiveStreams: false },
            [],
            'OrganizationProfile'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: OrganizationProfileShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationProfile(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationProfile');
    }
}
export interface OrganizationEditorialShape {
    listed: boolean;
    featured: boolean;
}

export class OrganizationEditorial extends FEntity {
    get id(): number { return this._value.id; }
    get listed(): boolean {
        return this._value.listed;
    }
    set listed(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.listed) { return; }
        this._value.listed = value;
        this.markDirty();
    }
    get featured(): boolean {
        return this._value.featured;
    }
    set featured(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.featured) { return; }
        this._value.featured = value;
        this.markDirty();
    }
}

export class OrganizationEditorialFactory extends FEntityFactory<OrganizationEditorial> {
    static schema: FEntitySchema = {
        name: 'OrganizationEditorial',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'listed', type: 'boolean' },
            { name: 'featured', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('listed', src.listed);
        validators.isBoolean('listed', src.listed);
        validators.notNull('featured', src.featured);
        validators.isBoolean('featured', src.featured);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationEditorial'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationEditorialFactory.validate, hasLiveStreams: false },
            [],
            'OrganizationEditorial'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: OrganizationEditorialShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationEditorial(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationEditorial');
    }
}
export interface OrganizationMemberShape {
    invitedBy?: number| null;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export class OrganizationMember extends FEntity {
    get oid(): number { return this._value.oid; }
    get uid(): number { return this._value.uid; }
    get invitedBy(): number | null {
        let res = this._value.invitedBy;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set invitedBy(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get role(): 'admin' | 'member' {
        return this._value.role;
    }
    set role(value: 'admin' | 'member') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get status(): 'requested' | 'joined' | 'left' {
        return this._value.status;
    }
    set status(value: 'requested' | 'joined' | 'left') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class OrganizationMemberFactory extends FEntityFactory<OrganizationMember> {
    static schema: FEntitySchema = {
        name: 'OrganizationMember',
        editable: false,
        primaryKeys: [
            { name: 'oid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'invitedBy', type: 'number' },
            { name: 'role', type: 'enum', enumValues: ['admin', 'member'] },
            { name: 'status', type: 'enum', enumValues: ['requested', 'joined', 'left'] },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['status', 'oid', 'uid'] },
            { name: 'user', type: 'unique', fields: ['status', 'uid', 'oid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['admin', 'member']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['requested', 'joined', 'left']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationMember'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationMemberFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('organization', ['status', 'oid', 'uid'], true), new FEntityIndex('user', ['status', 'uid', 'oid'], true)],
            'OrganizationMember'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'oid': rawId[0], 'uid': rawId[1] };
    }
    async findById(oid: number, uid: number) {
        return await this._findById([oid, uid]);
    }
    async create(oid: number, uid: number, shape: OrganizationMemberShape) {
        return await this._create([oid, uid], { oid, uid, ...shape });
    }
    watch(oid: number, uid: number, cb: () => void) {
        return this._watch([oid, uid], cb);
    }
    async findFromOrganization(status: 'requested' | 'joined' | 'left', oid: number, uid: number) {
        return await this._findFromIndex(['__indexes', 'organization', status, oid, uid]);
    }
    async allFromOrganizationAfter(status: 'requested' | 'joined' | 'left', oid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'organization', status, oid], after);
    }
    async rangeFromOrganizationAfter(status: 'requested' | 'joined' | 'left', oid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'organization', status, oid], after, limit, reversed);
    }
    async rangeFromOrganization(status: 'requested' | 'joined' | 'left', oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'organization', status, oid], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(status: 'requested' | 'joined' | 'left', oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'organization', status, oid], limit, after, reversed);
    }
    async allFromOrganization(status: 'requested' | 'joined' | 'left', oid: number) {
        return await this._findAll(['__indexes', 'organization', status, oid]);
    }
    createOrganizationStream(status: 'requested' | 'joined' | 'left', oid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationMember', '__indexes', 'organization', status, oid], limit, after); 
    }
    async findFromUser(status: 'requested' | 'joined' | 'left', uid: number, oid: number) {
        return await this._findFromIndex(['__indexes', 'user', status, uid, oid]);
    }
    async allFromUserAfter(status: 'requested' | 'joined' | 'left', uid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'user', status, uid], after);
    }
    async rangeFromUserAfter(status: 'requested' | 'joined' | 'left', uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', status, uid], after, limit, reversed);
    }
    async rangeFromUser(status: 'requested' | 'joined' | 'left', uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', status, uid], limit, reversed);
    }
    async rangeFromUserWithCursor(status: 'requested' | 'joined' | 'left', uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', status, uid], limit, after, reversed);
    }
    async allFromUser(status: 'requested' | 'joined' | 'left', uid: number) {
        return await this._findAll(['__indexes', 'user', status, uid]);
    }
    createUserStream(status: 'requested' | 'joined' | 'left', uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationMember', '__indexes', 'user', status, uid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationMember(this.connection, this.namespace, this.directory, [value.oid, value.uid], value, this.options, isNew, this.indexes, 'OrganizationMember');
    }
}
export interface FeatureFlagShape {
    title: string;
}

export class FeatureFlag extends FEntity {
    get key(): string { return this._value.key; }
    get title(): string {
        return this._value.title;
    }
    set title(value: string) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
}

export class FeatureFlagFactory extends FEntityFactory<FeatureFlag> {
    static schema: FEntitySchema = {
        name: 'FeatureFlag',
        editable: false,
        primaryKeys: [
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'title', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('title', src.title);
        validators.isString('title', src.title);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'featureFlag'),
            { enableVersioning: true, enableTimestamps: true, validator: FeatureFlagFactory.validate, hasLiveStreams: false },
            [],
            'FeatureFlag'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'key': rawId[0] };
    }
    async findById(key: string) {
        return await this._findById([key]);
    }
    async create(key: string, shape: FeatureFlagShape) {
        return await this._create([key], { key, ...shape });
    }
    watch(key: string, cb: () => void) {
        return this._watch([key], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new FeatureFlag(this.connection, this.namespace, this.directory, [value.key], value, this.options, isNew, this.indexes, 'FeatureFlag');
    }
}
export interface OrganizationFeaturesShape {
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export class OrganizationFeatures extends FEntity {
    get id(): string { return this._value.id; }
    get featureKey(): string {
        return this._value.featureKey;
    }
    set featureKey(value: string) {
        this._checkIsWritable();
        if (value === this._value.featureKey) { return; }
        this._value.featureKey = value;
        this.markDirty();
    }
    get organizationId(): number {
        return this._value.organizationId;
    }
    set organizationId(value: number) {
        this._checkIsWritable();
        if (value === this._value.organizationId) { return; }
        this._value.organizationId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class OrganizationFeaturesFactory extends FEntityFactory<OrganizationFeatures> {
    static schema: FEntitySchema = {
        name: 'OrganizationFeatures',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'featureKey', type: 'string' },
            { name: 'organizationId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['organizationId', 'featureKey'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('featureKey', src.featureKey);
        validators.isString('featureKey', src.featureKey);
        validators.notNull('organizationId', src.organizationId);
        validators.isNumber('organizationId', src.organizationId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationFeatures'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationFeaturesFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('organization', ['organizationId', 'featureKey'], true)],
            'OrganizationFeatures'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: OrganizationFeaturesShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromOrganization(organizationId: number, featureKey: string) {
        return await this._findFromIndex(['__indexes', 'organization', organizationId, featureKey]);
    }
    async allFromOrganizationAfter(organizationId: number, after: string) {
        return await this._findRangeAllAfter(['__indexes', 'organization', organizationId], after);
    }
    async rangeFromOrganizationAfter(organizationId: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'organization', organizationId], after, limit, reversed);
    }
    async rangeFromOrganization(organizationId: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'organization', organizationId], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(organizationId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'organization', organizationId], limit, after, reversed);
    }
    async allFromOrganization(organizationId: number) {
        return await this._findAll(['__indexes', 'organization', organizationId]);
    }
    createOrganizationStream(organizationId: number, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationFeatures', '__indexes', 'organization', organizationId], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationFeatures(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationFeatures');
    }
}
export interface ReaderStateShape {
    cursor: string;
    version?: number| null;
}

export class ReaderState extends FEntity {
    get id(): string { return this._value.id; }
    get cursor(): string {
        return this._value.cursor;
    }
    set cursor(value: string) {
        this._checkIsWritable();
        if (value === this._value.cursor) { return; }
        this._value.cursor = value;
        this.markDirty();
    }
    get version(): number | null {
        let res = this._value.version;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set version(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
}

export class ReaderStateFactory extends FEntityFactory<ReaderState> {
    static schema: FEntitySchema = {
        name: 'ReaderState',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'cursor', type: 'string' },
            { name: 'version', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('cursor', src.cursor);
        validators.isString('cursor', src.cursor);
        validators.isNumber('version', src.version);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'readerState'),
            { enableVersioning: true, enableTimestamps: true, validator: ReaderStateFactory.validate, hasLiveStreams: false },
            [],
            'ReaderState'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: ReaderStateShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ReaderState(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ReaderState');
    }
}
export interface SuperAdminShape {
    role: string;
    enabled: boolean;
}

export class SuperAdmin extends FEntity {
    get id(): number { return this._value.id; }
    get role(): string {
        return this._value.role;
    }
    set role(value: string) {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class SuperAdminFactory extends FEntityFactory<SuperAdmin> {
    static schema: FEntitySchema = {
        name: 'SuperAdmin',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'role', type: 'string' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('role', src.role);
        validators.isString('role', src.role);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'superAdmin'),
            { enableVersioning: false, enableTimestamps: false, validator: SuperAdminFactory.validate, hasLiveStreams: false },
            [],
            'SuperAdmin'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: SuperAdminShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new SuperAdmin(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'SuperAdmin');
    }
}
export interface UserSettingsShape {
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    mobileAlert?: boolean| null;
    mobileIncludeText?: boolean| null;
    notificationsDelay?: 'none' | '1min' | '15min'| null;
}

export class UserSettings extends FEntity {
    get id(): number { return this._value.id; }
    get emailFrequency(): '1hour' | '15min' | 'never' | '24hour' | '1week' {
        return this._value.emailFrequency;
    }
    set emailFrequency(value: '1hour' | '15min' | 'never' | '24hour' | '1week') {
        this._checkIsWritable();
        if (value === this._value.emailFrequency) { return; }
        this._value.emailFrequency = value;
        this.markDirty();
    }
    get desktopNotifications(): 'all' | 'direct' | 'none' {
        return this._value.desktopNotifications;
    }
    set desktopNotifications(value: 'all' | 'direct' | 'none') {
        this._checkIsWritable();
        if (value === this._value.desktopNotifications) { return; }
        this._value.desktopNotifications = value;
        this.markDirty();
    }
    get mobileNotifications(): 'all' | 'direct' | 'none' {
        return this._value.mobileNotifications;
    }
    set mobileNotifications(value: 'all' | 'direct' | 'none') {
        this._checkIsWritable();
        if (value === this._value.mobileNotifications) { return; }
        this._value.mobileNotifications = value;
        this.markDirty();
    }
    get mobileAlert(): boolean | null {
        let res = this._value.mobileAlert;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mobileAlert(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.mobileAlert) { return; }
        this._value.mobileAlert = value;
        this.markDirty();
    }
    get mobileIncludeText(): boolean | null {
        let res = this._value.mobileIncludeText;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mobileIncludeText(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.mobileIncludeText) { return; }
        this._value.mobileIncludeText = value;
        this.markDirty();
    }
    get notificationsDelay(): 'none' | '1min' | '15min' | null {
        let res = this._value.notificationsDelay;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set notificationsDelay(value: 'none' | '1min' | '15min' | null) {
        this._checkIsWritable();
        if (value === this._value.notificationsDelay) { return; }
        this._value.notificationsDelay = value;
        this.markDirty();
    }
}

export class UserSettingsFactory extends FEntityFactory<UserSettings> {
    static schema: FEntitySchema = {
        name: 'UserSettings',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'emailFrequency', type: 'enum', enumValues: ['1hour', '15min', 'never', '24hour', '1week'] },
            { name: 'desktopNotifications', type: 'enum', enumValues: ['all', 'direct', 'none'] },
            { name: 'mobileNotifications', type: 'enum', enumValues: ['all', 'direct', 'none'] },
            { name: 'mobileAlert', type: 'boolean' },
            { name: 'mobileIncludeText', type: 'boolean' },
            { name: 'notificationsDelay', type: 'enum', enumValues: ['none', '1min', '15min'] },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('emailFrequency', src.emailFrequency);
        validators.isEnum('emailFrequency', src.emailFrequency, ['1hour', '15min', 'never', '24hour', '1week']);
        validators.notNull('desktopNotifications', src.desktopNotifications);
        validators.isEnum('desktopNotifications', src.desktopNotifications, ['all', 'direct', 'none']);
        validators.notNull('mobileNotifications', src.mobileNotifications);
        validators.isEnum('mobileNotifications', src.mobileNotifications, ['all', 'direct', 'none']);
        validators.isBoolean('mobileAlert', src.mobileAlert);
        validators.isBoolean('mobileIncludeText', src.mobileIncludeText);
        validators.isEnum('notificationsDelay', src.notificationsDelay, ['none', '1min', '15min']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userSettings'),
            { enableVersioning: true, enableTimestamps: true, validator: UserSettingsFactory.validate, hasLiveStreams: false },
            [],
            'UserSettings'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: UserSettingsShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserSettings(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserSettings');
    }
}
export interface ShortnameReservationShape {
    ownerType: 'org' | 'user';
    ownerId: number;
    enabled: boolean;
}

export class ShortnameReservation extends FEntity {
    get shortname(): string { return this._value.shortname; }
    get ownerType(): 'org' | 'user' {
        return this._value.ownerType;
    }
    set ownerType(value: 'org' | 'user') {
        this._checkIsWritable();
        if (value === this._value.ownerType) { return; }
        this._value.ownerType = value;
        this.markDirty();
    }
    get ownerId(): number {
        return this._value.ownerId;
    }
    set ownerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ShortnameReservationFactory extends FEntityFactory<ShortnameReservation> {
    static schema: FEntitySchema = {
        name: 'ShortnameReservation',
        editable: false,
        primaryKeys: [
            { name: 'shortname', type: 'string' },
        ],
        fields: [
            { name: 'ownerType', type: 'enum', enumValues: ['org', 'user'] },
            { name: 'ownerId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['ownerId'] },
            { name: 'org', type: 'unique', fields: ['ownerId'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('shortname', src.shortname);
        validators.isString('shortname', src.shortname);
        validators.notNull('ownerType', src.ownerType);
        validators.isEnum('ownerType', src.ownerType, ['org', 'user']);
        validators.notNull('ownerId', src.ownerId);
        validators.isNumber('ownerId', src.ownerId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'shortnameReservation'),
            { enableVersioning: true, enableTimestamps: true, validator: ShortnameReservationFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['ownerId'], true, (src) => src.ownerType === 'user' && src.enabled), new FEntityIndex('org', ['ownerId'], true, (src) => src.ownerType === 'org' && src.enabled)],
            'ShortnameReservation'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'shortname': rawId[0] };
    }
    async findById(shortname: string) {
        return await this._findById([shortname]);
    }
    async create(shortname: string, shape: ShortnameReservationShape) {
        return await this._create([shortname], { shortname, ...shape });
    }
    watch(shortname: string, cb: () => void) {
        return this._watch([shortname], cb);
    }
    async findFromUser(ownerId: number) {
        return await this._findFromIndex(['__indexes', 'user', ownerId]);
    }
    async rangeFromUser(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user'], limit, reversed);
    }
    async rangeFromUserWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user'], limit, after, reversed);
    }
    async allFromUser() {
        return await this._findAll(['__indexes', 'user']);
    }
    createUserStream(limit: number, after?: string) {
        return this._createStream(['entity', 'shortnameReservation', '__indexes', 'user'], limit, after); 
    }
    async findFromOrg(ownerId: number) {
        return await this._findFromIndex(['__indexes', 'org', ownerId]);
    }
    async rangeFromOrg(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'org'], limit, reversed);
    }
    async rangeFromOrgWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'org'], limit, after, reversed);
    }
    async allFromOrg() {
        return await this._findAll(['__indexes', 'org']);
    }
    createOrgStream(limit: number, after?: string) {
        return this._createStream(['entity', 'shortnameReservation', '__indexes', 'org'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ShortnameReservation(this.connection, this.namespace, this.directory, [value.shortname], value, this.options, isNew, this.indexes, 'ShortnameReservation');
    }
}
export interface AuthCodeSessionShape {
    code: string;
    expires: number;
    email: string;
    tokenId?: string| null;
    enabled: boolean;
}

export class AuthCodeSession extends FEntity {
    get uid(): string { return this._value.uid; }
    get code(): string {
        return this._value.code;
    }
    set code(value: string) {
        this._checkIsWritable();
        if (value === this._value.code) { return; }
        this._value.code = value;
        this.markDirty();
    }
    get expires(): number {
        return this._value.expires;
    }
    set expires(value: number) {
        this._checkIsWritable();
        if (value === this._value.expires) { return; }
        this._value.expires = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get tokenId(): string | null {
        let res = this._value.tokenId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set tokenId(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.tokenId) { return; }
        this._value.tokenId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class AuthCodeSessionFactory extends FEntityFactory<AuthCodeSession> {
    static schema: FEntitySchema = {
        name: 'AuthCodeSession',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'string' },
        ],
        fields: [
            { name: 'code', type: 'string', secure: true },
            { name: 'expires', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'tokenId', type: 'string', secure: true },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isString('uid', src.uid);
        validators.notNull('code', src.code);
        validators.isString('code', src.code);
        validators.notNull('expires', src.expires);
        validators.isNumber('expires', src.expires);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.isString('tokenId', src.tokenId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'authCodeSession'),
            { enableVersioning: true, enableTimestamps: true, validator: AuthCodeSessionFactory.validate, hasLiveStreams: false },
            [],
            'AuthCodeSession'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(uid: string) {
        return await this._findById([uid]);
    }
    async create(uid: string, shape: AuthCodeSessionShape) {
        return await this._create([uid], { uid, ...shape });
    }
    watch(uid: string, cb: () => void) {
        return this._watch([uid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new AuthCodeSession(this.connection, this.namespace, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'AuthCodeSession');
    }
}
export interface ConversationShape {
    kind: 'private' | 'organization' | 'room';
}

export class Conversation extends FEntity {
    get id(): number { return this._value.id; }
    get kind(): 'private' | 'organization' | 'room' {
        return this._value.kind;
    }
    set kind(value: 'private' | 'organization' | 'room') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class ConversationFactory extends FEntityFactory<Conversation> {
    static schema: FEntitySchema = {
        name: 'Conversation',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['private', 'organization', 'room'] },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['private', 'organization', 'room']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversation'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationFactory.validate, hasLiveStreams: false },
            [],
            'Conversation'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: ConversationShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Conversation(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Conversation');
    }
}
export interface ConversationPrivateShape {
    uid1: number;
    uid2: number;
}

export class ConversationPrivate extends FEntity {
    get id(): number { return this._value.id; }
    get uid1(): number {
        return this._value.uid1;
    }
    set uid1(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid1) { return; }
        this._value.uid1 = value;
        this.markDirty();
    }
    get uid2(): number {
        return this._value.uid2;
    }
    set uid2(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid2) { return; }
        this._value.uid2 = value;
        this.markDirty();
    }
}

export class ConversationPrivateFactory extends FEntityFactory<ConversationPrivate> {
    static schema: FEntitySchema = {
        name: 'ConversationPrivate',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'uid1', type: 'number' },
            { name: 'uid2', type: 'number' },
        ],
        indexes: [
            { name: 'users', type: 'unique', fields: ['uid1', 'uid2'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('uid1', src.uid1);
        validators.isNumber('uid1', src.uid1);
        validators.notNull('uid2', src.uid2);
        validators.isNumber('uid2', src.uid2);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationPrivate'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationPrivateFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('users', ['uid1', 'uid2'], true)],
            'ConversationPrivate'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: ConversationPrivateShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromUsers(uid1: number, uid2: number) {
        return await this._findFromIndex(['__indexes', 'users', uid1, uid2]);
    }
    async allFromUsersAfter(uid1: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'users', uid1], after);
    }
    async rangeFromUsersAfter(uid1: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'users', uid1], after, limit, reversed);
    }
    async rangeFromUsers(uid1: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'users', uid1], limit, reversed);
    }
    async rangeFromUsersWithCursor(uid1: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'users', uid1], limit, after, reversed);
    }
    async allFromUsers(uid1: number) {
        return await this._findAll(['__indexes', 'users', uid1]);
    }
    createUsersStream(uid1: number, limit: number, after?: string) {
        return this._createStream(['entity', 'conversationPrivate', '__indexes', 'users', uid1], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationPrivate(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationPrivate');
    }
}
export interface ConversationOrganizationShape {
    oid: number;
}

export class ConversationOrganization extends FEntity {
    get id(): number { return this._value.id; }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
}

export class ConversationOrganizationFactory extends FEntityFactory<ConversationOrganization> {
    static schema: FEntitySchema = {
        name: 'ConversationOrganization',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'oid', type: 'number' },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['oid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationOrganization'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationOrganizationFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('organization', ['oid'], true)],
            'ConversationOrganization'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: ConversationOrganizationShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromOrganization(oid: number) {
        return await this._findFromIndex(['__indexes', 'organization', oid]);
    }
    async rangeFromOrganization(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'organization'], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'organization'], limit, after, reversed);
    }
    async allFromOrganization() {
        return await this._findAll(['__indexes', 'organization']);
    }
    createOrganizationStream(limit: number, after?: string) {
        return this._createStream(['entity', 'conversationOrganization', '__indexes', 'organization'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationOrganization(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationOrganization');
    }
}
export interface ConversationRoomShape {
    kind: 'organization' | 'internal' | 'public' | 'group';
    oid?: number| null;
    ownerId?: number| null;
    featured?: boolean| null;
    listed?: boolean| null;
}

export class ConversationRoom extends FEntity {
    get id(): number { return this._value.id; }
    get kind(): 'organization' | 'internal' | 'public' | 'group' {
        return this._value.kind;
    }
    set kind(value: 'organization' | 'internal' | 'public' | 'group') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get oid(): number | null {
        let res = this._value.oid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set oid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get ownerId(): number | null {
        let res = this._value.ownerId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set ownerId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get featured(): boolean | null {
        let res = this._value.featured;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set featured(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.featured) { return; }
        this._value.featured = value;
        this.markDirty();
    }
    get listed(): boolean | null {
        let res = this._value.listed;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set listed(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.listed) { return; }
        this._value.listed = value;
        this.markDirty();
    }
}

export class ConversationRoomFactory extends FEntityFactory<ConversationRoom> {
    static schema: FEntitySchema = {
        name: 'ConversationRoom',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['organization', 'internal', 'public', 'group'] },
            { name: 'oid', type: 'number' },
            { name: 'ownerId', type: 'number' },
            { name: 'featured', type: 'boolean' },
            { name: 'listed', type: 'boolean' },
        ],
        indexes: [
            { name: 'organization', type: 'range', fields: ['oid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['organization', 'internal', 'public', 'group']);
        validators.isNumber('oid', src.oid);
        validators.isNumber('ownerId', src.ownerId);
        validators.isBoolean('featured', src.featured);
        validators.isBoolean('listed', src.listed);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationRoom'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationRoomFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('organization', ['oid'], false, (v) => v.kind === 'public' || v.kind === 'internal')],
            'ConversationRoom'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: ConversationRoomShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    async rangeFromOrganization(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'organization'], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'organization'], limit, after, reversed);
    }
    async allFromOrganization() {
        return await this._findAll(['__indexes', 'organization']);
    }
    createOrganizationStream(limit: number, after?: string) {
        return this._createStream(['entity', 'conversationRoom', '__indexes', 'organization'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationRoom(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationRoom');
    }
}
export interface RoomProfileShape {
    title: string;
    image?: any| null;
    description?: string| null;
    socialImage?: any| null;
}

export class RoomProfile extends FEntity {
    get id(): number { return this._value.id; }
    get title(): string {
        return this._value.title;
    }
    set title(value: string) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get image(): any | null {
        let res = this._value.image;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set image(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.image) { return; }
        this._value.image = value;
        this.markDirty();
    }
    get description(): string | null {
        let res = this._value.description;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set description(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.description) { return; }
        this._value.description = value;
        this.markDirty();
    }
    get socialImage(): any | null {
        let res = this._value.socialImage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set socialImage(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.socialImage) { return; }
        this._value.socialImage = value;
        this.markDirty();
    }
}

export class RoomProfileFactory extends FEntityFactory<RoomProfile> {
    static schema: FEntitySchema = {
        name: 'RoomProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'title', type: 'string' },
            { name: 'image', type: 'json' },
            { name: 'description', type: 'string' },
            { name: 'socialImage', type: 'json' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('title', src.title);
        validators.isString('title', src.title);
        validators.isString('description', src.description);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'roomProfile'),
            { enableVersioning: true, enableTimestamps: true, validator: RoomProfileFactory.validate, hasLiveStreams: false },
            [],
            'RoomProfile'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: RoomProfileShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new RoomProfile(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'RoomProfile');
    }
}
export interface RoomParticipantShape {
    invitedBy: number;
    role: 'member' | 'admin' | 'owner';
    status: 'joined' | 'requested' | 'left' | 'kicked';
}

export class RoomParticipant extends FEntity {
    get cid(): number { return this._value.cid; }
    get uid(): number { return this._value.uid; }
    get invitedBy(): number {
        return this._value.invitedBy;
    }
    set invitedBy(value: number) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get role(): 'member' | 'admin' | 'owner' {
        return this._value.role;
    }
    set role(value: 'member' | 'admin' | 'owner') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get status(): 'joined' | 'requested' | 'left' | 'kicked' {
        return this._value.status;
    }
    set status(value: 'joined' | 'requested' | 'left' | 'kicked') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class RoomParticipantFactory extends FEntityFactory<RoomParticipant> {
    static schema: FEntitySchema = {
        name: 'RoomParticipant',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'invitedBy', type: 'number' },
            { name: 'role', type: 'enum', enumValues: ['member', 'admin', 'owner'] },
            { name: 'status', type: 'enum', enumValues: ['joined', 'requested', 'left', 'kicked'] },
        ],
        indexes: [
            { name: 'active', type: 'unique', fields: ['cid', 'uid'] },
            { name: 'requests', type: 'unique', fields: ['cid', 'uid'] },
            { name: 'userActive', type: 'unique', fields: ['uid', 'cid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('invitedBy', src.invitedBy);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['member', 'admin', 'owner']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['joined', 'requested', 'left', 'kicked']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'roomParticipant'),
            { enableVersioning: true, enableTimestamps: true, validator: RoomParticipantFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('active', ['cid', 'uid'], true, (src) => src.status === 'joined'), new FEntityIndex('requests', ['cid', 'uid'], true, (src) => src.status === 'requested'), new FEntityIndex('userActive', ['uid', 'cid'], true, (src) => src.status === 'joined')],
            'RoomParticipant'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'uid': rawId[1] };
    }
    async findById(cid: number, uid: number) {
        return await this._findById([cid, uid]);
    }
    async create(cid: number, uid: number, shape: RoomParticipantShape) {
        return await this._create([cid, uid], { cid, uid, ...shape });
    }
    watch(cid: number, uid: number, cb: () => void) {
        return this._watch([cid, uid], cb);
    }
    async findFromActive(cid: number, uid: number) {
        return await this._findFromIndex(['__indexes', 'active', cid, uid]);
    }
    async allFromActiveAfter(cid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'active', cid], after);
    }
    async rangeFromActiveAfter(cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'active', cid], after, limit, reversed);
    }
    async rangeFromActive(cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'active', cid], limit, reversed);
    }
    async rangeFromActiveWithCursor(cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'active', cid], limit, after, reversed);
    }
    async allFromActive(cid: number) {
        return await this._findAll(['__indexes', 'active', cid]);
    }
    createActiveStream(cid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'roomParticipant', '__indexes', 'active', cid], limit, after); 
    }
    async findFromRequests(cid: number, uid: number) {
        return await this._findFromIndex(['__indexes', 'requests', cid, uid]);
    }
    async allFromRequestsAfter(cid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'requests', cid], after);
    }
    async rangeFromRequestsAfter(cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'requests', cid], after, limit, reversed);
    }
    async rangeFromRequests(cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'requests', cid], limit, reversed);
    }
    async rangeFromRequestsWithCursor(cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'requests', cid], limit, after, reversed);
    }
    async allFromRequests(cid: number) {
        return await this._findAll(['__indexes', 'requests', cid]);
    }
    createRequestsStream(cid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'roomParticipant', '__indexes', 'requests', cid], limit, after); 
    }
    async findFromUserActive(uid: number, cid: number) {
        return await this._findFromIndex(['__indexes', 'userActive', uid, cid]);
    }
    async allFromUserActiveAfter(uid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'userActive', uid], after);
    }
    async rangeFromUserActiveAfter(uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'userActive', uid], after, limit, reversed);
    }
    async rangeFromUserActive(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'userActive', uid], limit, reversed);
    }
    async rangeFromUserActiveWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'userActive', uid], limit, after, reversed);
    }
    async allFromUserActive(uid: number) {
        return await this._findAll(['__indexes', 'userActive', uid]);
    }
    createUserActiveStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'roomParticipant', '__indexes', 'userActive', uid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new RoomParticipant(this.connection, this.namespace, this.directory, [value.cid, value.uid], value, this.options, isNew, this.indexes, 'RoomParticipant');
    }
}
export interface ConversationReceiverShape {
    enabled: boolean;
}

export class ConversationReceiver extends FEntity {
    get cid(): number { return this._value.cid; }
    get uid(): number { return this._value.uid; }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ConversationReceiverFactory extends FEntityFactory<ConversationReceiver> {
    static schema: FEntitySchema = {
        name: 'ConversationReceiver',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'conversation', type: 'unique', fields: ['cid', 'uid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationReceiver'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationReceiverFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('conversation', ['cid', 'uid'], true, (src) => src.enabled)],
            'ConversationReceiver'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'uid': rawId[1] };
    }
    async findById(cid: number, uid: number) {
        return await this._findById([cid, uid]);
    }
    async create(cid: number, uid: number, shape: ConversationReceiverShape) {
        return await this._create([cid, uid], { cid, uid, ...shape });
    }
    watch(cid: number, uid: number, cb: () => void) {
        return this._watch([cid, uid], cb);
    }
    async findFromConversation(cid: number, uid: number) {
        return await this._findFromIndex(['__indexes', 'conversation', cid, uid]);
    }
    async allFromConversationAfter(cid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'conversation', cid], after);
    }
    async rangeFromConversationAfter(cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'conversation', cid], after, limit, reversed);
    }
    async rangeFromConversation(cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'conversation', cid], limit, reversed);
    }
    async rangeFromConversationWithCursor(cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'conversation', cid], limit, after, reversed);
    }
    async allFromConversation(cid: number) {
        return await this._findAll(['__indexes', 'conversation', cid]);
    }
    createConversationStream(cid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'conversationReceiver', '__indexes', 'conversation', cid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationReceiver(this.connection, this.namespace, this.directory, [value.cid, value.uid], value, this.options, isNew, this.indexes, 'ConversationReceiver');
    }
}
export interface SequenceShape {
    value: number;
}

export class Sequence extends FEntity {
    get sequence(): string { return this._value.sequence; }
    get value(): number {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class SequenceFactory extends FEntityFactory<Sequence> {
    static schema: FEntitySchema = {
        name: 'Sequence',
        editable: false,
        primaryKeys: [
            { name: 'sequence', type: 'string' },
        ],
        fields: [
            { name: 'value', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('sequence', src.sequence);
        validators.isString('sequence', src.sequence);
        validators.notNull('value', src.value);
        validators.isNumber('value', src.value);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'sequence'),
            { enableVersioning: false, enableTimestamps: false, validator: SequenceFactory.validate, hasLiveStreams: false },
            [],
            'Sequence'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'sequence': rawId[0] };
    }
    async findById(sequence: string) {
        return await this._findById([sequence]);
    }
    async create(sequence: string, shape: SequenceShape) {
        return await this._create([sequence], { sequence, ...shape });
    }
    watch(sequence: string, cb: () => void) {
        return this._watch([sequence], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Sequence(this.connection, this.namespace, this.directory, [value.sequence], value, this.options, isNew, this.indexes, 'Sequence');
    }
}
export interface MessageShape {
    cid: number;
    uid: number;
    repeatKey?: string| null;
    text?: string| null;
    fileId?: string| null;
    fileMetadata?: any| null;
    filePreview?: string| null;
    mentions?: any| null;
    replyMessages?: any| null;
    augmentation?: any| null;
    serviceMetadata?: any| null;
    reactions?: any| null;
    edited?: boolean| null;
    isMuted: boolean;
    isService: boolean;
    deleted?: boolean| null;
}

export class Message extends FEntity {
    get id(): number { return this._value.id; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get repeatKey(): string | null {
        let res = this._value.repeatKey;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set repeatKey(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.repeatKey) { return; }
        this._value.repeatKey = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get fileId(): string | null {
        let res = this._value.fileId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileId(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.fileId) { return; }
        this._value.fileId = value;
        this.markDirty();
    }
    get fileMetadata(): any | null {
        let res = this._value.fileMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileMetadata(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.fileMetadata) { return; }
        this._value.fileMetadata = value;
        this.markDirty();
    }
    get filePreview(): string | null {
        let res = this._value.filePreview;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set filePreview(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.filePreview) { return; }
        this._value.filePreview = value;
        this.markDirty();
    }
    get mentions(): any | null {
        let res = this._value.mentions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mentions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.mentions) { return; }
        this._value.mentions = value;
        this.markDirty();
    }
    get replyMessages(): any | null {
        let res = this._value.replyMessages;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set replyMessages(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.replyMessages) { return; }
        this._value.replyMessages = value;
        this.markDirty();
    }
    get augmentation(): any | null {
        let res = this._value.augmentation;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set augmentation(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.augmentation) { return; }
        this._value.augmentation = value;
        this.markDirty();
    }
    get serviceMetadata(): any | null {
        let res = this._value.serviceMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set serviceMetadata(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.serviceMetadata) { return; }
        this._value.serviceMetadata = value;
        this.markDirty();
    }
    get reactions(): any | null {
        let res = this._value.reactions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set reactions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.reactions) { return; }
        this._value.reactions = value;
        this.markDirty();
    }
    get edited(): boolean | null {
        let res = this._value.edited;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set edited(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.edited) { return; }
        this._value.edited = value;
        this.markDirty();
    }
    get isMuted(): boolean {
        return this._value.isMuted;
    }
    set isMuted(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isMuted) { return; }
        this._value.isMuted = value;
        this.markDirty();
    }
    get isService(): boolean {
        return this._value.isService;
    }
    set isService(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isService) { return; }
        this._value.isService = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
}

export class MessageFactory extends FEntityFactory<Message> {
    static schema: FEntitySchema = {
        name: 'Message',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'repeatKey', type: 'string' },
            { name: 'text', type: 'string', secure: true },
            { name: 'fileId', type: 'string', secure: true },
            { name: 'fileMetadata', type: 'json', secure: true },
            { name: 'filePreview', type: 'string', secure: true },
            { name: 'mentions', type: 'json' },
            { name: 'replyMessages', type: 'json' },
            { name: 'augmentation', type: 'json' },
            { name: 'serviceMetadata', type: 'json' },
            { name: 'reactions', type: 'json', secure: true },
            { name: 'edited', type: 'boolean' },
            { name: 'isMuted', type: 'boolean' },
            { name: 'isService', type: 'boolean' },
            { name: 'deleted', type: 'boolean' },
        ],
        indexes: [
            { name: 'chat', type: 'range', fields: ['cid', 'id'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('repeatKey', src.repeatKey);
        validators.isString('text', src.text);
        validators.isString('fileId', src.fileId);
        validators.isString('filePreview', src.filePreview);
        validators.isBoolean('edited', src.edited);
        validators.notNull('isMuted', src.isMuted);
        validators.isBoolean('isMuted', src.isMuted);
        validators.notNull('isService', src.isService);
        validators.isBoolean('isService', src.isService);
        validators.isBoolean('deleted', src.deleted);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'message'),
            { enableVersioning: true, enableTimestamps: true, validator: MessageFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('chat', ['cid', 'id'], false, (src) => !src.deleted)],
            'Message'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: number) {
        return await this._findById([id]);
    }
    async create(id: number, shape: MessageShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: number, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromChatAfter(cid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'chat', cid], after);
    }
    async rangeFromChatAfter(cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'chat', cid], after, limit, reversed);
    }
    async rangeFromChat(cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'chat', cid], limit, reversed);
    }
    async rangeFromChatWithCursor(cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'chat', cid], limit, after, reversed);
    }
    async allFromChat(cid: number) {
        return await this._findAll(['__indexes', 'chat', cid]);
    }
    createChatStream(cid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'message', '__indexes', 'chat', cid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Message(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Message');
    }
}
export interface ConversationSeqShape {
    seq: number;
}

export class ConversationSeq extends FEntity {
    get cid(): number { return this._value.cid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class ConversationSeqFactory extends FEntityFactory<ConversationSeq> {
    static schema: FEntitySchema = {
        name: 'ConversationSeq',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationSeq'),
            { enableVersioning: false, enableTimestamps: false, validator: ConversationSeqFactory.validate, hasLiveStreams: false },
            [],
            'ConversationSeq'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0] };
    }
    async findById(cid: number) {
        return await this._findById([cid]);
    }
    async create(cid: number, shape: ConversationSeqShape) {
        return await this._create([cid], { cid, ...shape });
    }
    watch(cid: number, cb: () => void) {
        return this._watch([cid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationSeq(this.connection, this.namespace, this.directory, [value.cid], value, this.options, isNew, this.indexes, 'ConversationSeq');
    }
}
export interface ConversationEventShape {
    uid?: number| null;
    mid?: number| null;
    kind: 'message_received' | 'message_updated' | 'message_deleted';
}

export class ConversationEvent extends FEntity {
    get cid(): number { return this._value.cid; }
    get seq(): number { return this._value.seq; }
    get uid(): number | null {
        let res = this._value.uid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set uid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get mid(): number | null {
        let res = this._value.mid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.mid) { return; }
        this._value.mid = value;
        this.markDirty();
    }
    get kind(): 'message_received' | 'message_updated' | 'message_deleted' {
        return this._value.kind;
    }
    set kind(value: 'message_received' | 'message_updated' | 'message_deleted') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class ConversationEventFactory extends FEntityFactory<ConversationEvent> {
    static schema: FEntitySchema = {
        name: 'ConversationEvent',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'mid', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['message_received', 'message_updated', 'message_deleted'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['cid', 'seq'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('uid', src.uid);
        validators.isNumber('mid', src.mid);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['message_received', 'message_updated', 'message_deleted']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'conversationEvent'),
            { enableVersioning: true, enableTimestamps: true, validator: ConversationEventFactory.validate, hasLiveStreams: true },
            [new FEntityIndex('user', ['cid', 'seq'], false)],
            'ConversationEvent'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'seq': rawId[1] };
    }
    async findById(cid: number, seq: number) {
        return await this._findById([cid, seq]);
    }
    async create(cid: number, seq: number, shape: ConversationEventShape) {
        return await this._create([cid, seq], { cid, seq, ...shape });
    }
    watch(cid: number, seq: number, cb: () => void) {
        return this._watch([cid, seq], cb);
    }
    async allFromUserAfter(cid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'user', cid], after);
    }
    async rangeFromUserAfter(cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', cid], after, limit, reversed);
    }
    async rangeFromUser(cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', cid], limit, reversed);
    }
    async rangeFromUserWithCursor(cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', cid], limit, after, reversed);
    }
    async allFromUser(cid: number) {
        return await this._findAll(['__indexes', 'user', cid]);
    }
    createUserStream(cid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'conversationEvent', '__indexes', 'user', cid], limit, after); 
    }
    createUserLiveStream(cid: number, limit: number, after?: string) {
        return this._createLiveStream(['entity', 'conversationEvent', '__indexes', 'user', cid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ConversationEvent(this.connection, this.namespace, this.directory, [value.cid, value.seq], value, this.options, isNew, this.indexes, 'ConversationEvent');
    }
}
export interface UserDialogShape {
    unread: number;
    readMessageId?: number| null;
    date?: number| null;
}

export class UserDialog extends FEntity {
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get unread(): number {
        return this._value.unread;
    }
    set unread(value: number) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
    get readMessageId(): number | null {
        let res = this._value.readMessageId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readMessageId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readMessageId) { return; }
        this._value.readMessageId = value;
        this.markDirty();
    }
    get date(): number | null {
        let res = this._value.date;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set date(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.date) { return; }
        this._value.date = value;
        this.markDirty();
    }
}

export class UserDialogFactory extends FEntityFactory<UserDialog> {
    static schema: FEntitySchema = {
        name: 'UserDialog',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'unread', type: 'number' },
            { name: 'readMessageId', type: 'number' },
            { name: 'date', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'date'], displayName: 'dialogsForUser' },
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('unread', src.unread);
        validators.isNumber('unread', src.unread);
        validators.isNumber('readMessageId', src.readMessageId);
        validators.isNumber('date', src.date);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userDialog'),
            { enableVersioning: true, enableTimestamps: true, validator: UserDialogFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['uid', 'date'], false, (src) => !!src.date)],
            'UserDialog'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(uid: number, cid: number) {
        return await this._findById([uid, cid]);
    }
    async create(uid: number, cid: number, shape: UserDialogShape) {
        return await this._create([uid, cid], { uid, cid, ...shape });
    }
    watch(uid: number, cid: number, cb: () => void) {
        return this._watch([uid, cid], cb);
    }
    async allFromUserAfter(uid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'user', uid], after);
    }
    async rangeFromUserAfter(uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', uid], after, limit, reversed);
    }
    async rangeFromUser(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', uid], limit, reversed);
    }
    async rangeFromUserWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', uid], limit, after, reversed);
    }
    async allFromUser(uid: number) {
        return await this._findAll(['__indexes', 'user', uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'userDialog', '__indexes', 'user', uid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserDialog(this.connection, this.namespace, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'UserDialog');
    }
}
export interface UserDialogSettingsShape {
    mute: boolean;
}

export class UserDialogSettings extends FEntity {
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get mute(): boolean {
        return this._value.mute;
    }
    set mute(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.mute) { return; }
        this._value.mute = value;
        this.markDirty();
    }
}

export class UserDialogSettingsFactory extends FEntityFactory<UserDialogSettings> {
    static schema: FEntitySchema = {
        name: 'UserDialogSettings',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'mute', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('mute', src.mute);
        validators.isBoolean('mute', src.mute);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userDialogSettings'),
            { enableVersioning: true, enableTimestamps: true, validator: UserDialogSettingsFactory.validate, hasLiveStreams: false },
            [],
            'UserDialogSettings'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(uid: number, cid: number) {
        return await this._findById([uid, cid]);
    }
    async create(uid: number, cid: number, shape: UserDialogSettingsShape) {
        return await this._create([uid, cid], { uid, cid, ...shape });
    }
    watch(uid: number, cid: number, cb: () => void) {
        return this._watch([uid, cid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserDialogSettings(this.connection, this.namespace, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'UserDialogSettings');
    }
}
export interface UserDialogEventShape {
    cid?: number| null;
    mid?: number| null;
    allUnread?: number| null;
    unread?: number| null;
    title?: string| null;
    kind: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated';
}

export class UserDialogEvent extends FEntity {
    get uid(): number { return this._value.uid; }
    get seq(): number { return this._value.seq; }
    get cid(): number | null {
        let res = this._value.cid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set cid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get mid(): number | null {
        let res = this._value.mid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.mid) { return; }
        this._value.mid = value;
        this.markDirty();
    }
    get allUnread(): number | null {
        let res = this._value.allUnread;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set allUnread(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.allUnread) { return; }
        this._value.allUnread = value;
        this.markDirty();
    }
    get unread(): number | null {
        let res = this._value.unread;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set unread(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
    get title(): string | null {
        let res = this._value.title;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set title(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get kind(): 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' {
        return this._value.kind;
    }
    set kind(value: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class UserDialogEventFactory extends FEntityFactory<UserDialogEvent> {
    static schema: FEntitySchema = {
        name: 'UserDialogEvent',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'mid', type: 'number' },
            { name: 'allUnread', type: 'number' },
            { name: 'unread', type: 'number' },
            { name: 'title', type: 'string' },
            { name: 'kind', type: 'enum', enumValues: ['message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'seq'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('cid', src.cid);
        validators.isNumber('mid', src.mid);
        validators.isNumber('allUnread', src.allUnread);
        validators.isNumber('unread', src.unread);
        validators.isString('title', src.title);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userDialogEvent'),
            { enableVersioning: true, enableTimestamps: true, validator: UserDialogEventFactory.validate, hasLiveStreams: true },
            [new FEntityIndex('user', ['uid', 'seq'], false)],
            'UserDialogEvent'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'seq': rawId[1] };
    }
    async findById(uid: number, seq: number) {
        return await this._findById([uid, seq]);
    }
    async create(uid: number, seq: number, shape: UserDialogEventShape) {
        return await this._create([uid, seq], { uid, seq, ...shape });
    }
    watch(uid: number, seq: number, cb: () => void) {
        return this._watch([uid, seq], cb);
    }
    async allFromUserAfter(uid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'user', uid], after);
    }
    async rangeFromUserAfter(uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'user', uid], after, limit, reversed);
    }
    async rangeFromUser(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user', uid], limit, reversed);
    }
    async rangeFromUserWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user', uid], limit, after, reversed);
    }
    async allFromUser(uid: number) {
        return await this._findAll(['__indexes', 'user', uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'userDialogEvent', '__indexes', 'user', uid], limit, after); 
    }
    createUserLiveStream(uid: number, limit: number, after?: string) {
        return this._createLiveStream(['entity', 'userDialogEvent', '__indexes', 'user', uid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserDialogEvent(this.connection, this.namespace, this.directory, [value.uid, value.seq], value, this.options, isNew, this.indexes, 'UserDialogEvent');
    }
}
export interface UserMessagingStateShape {
    seq: number;
    unread: number;
}

export class UserMessagingState extends FEntity {
    get uid(): number { return this._value.uid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
    get unread(): number {
        return this._value.unread;
    }
    set unread(value: number) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
}

export class UserMessagingStateFactory extends FEntityFactory<UserMessagingState> {
    static schema: FEntitySchema = {
        name: 'UserMessagingState',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
            { name: 'unread', type: 'number' },
        ],
        indexes: [
            { name: 'hasUnread', type: 'range', fields: [] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.notNull('unread', src.unread);
        validators.isNumber('unread', src.unread);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userMessagingState'),
            { enableVersioning: true, enableTimestamps: true, validator: UserMessagingStateFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('hasUnread', [], false, (src) => src.unread && src.unread > 0)],
            'UserMessagingState'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(uid: number) {
        return await this._findById([uid]);
    }
    async create(uid: number, shape: UserMessagingStateShape) {
        return await this._create([uid], { uid, ...shape });
    }
    watch(uid: number, cb: () => void) {
        return this._watch([uid], cb);
    }
    async rangeFromHasUnread(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'hasUnread'], limit, reversed);
    }
    async rangeFromHasUnreadWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'hasUnread'], limit, after, reversed);
    }
    async allFromHasUnread() {
        return await this._findAll(['__indexes', 'hasUnread']);
    }
    createHasUnreadStream(limit: number, after?: string) {
        return this._createStream(['entity', 'userMessagingState', '__indexes', 'hasUnread'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserMessagingState(this.connection, this.namespace, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserMessagingState');
    }
}
export interface UserNotificationsStateShape {
    readSeq?: number| null;
    lastEmailNotification?: number| null;
    lastPushNotification?: number| null;
    lastEmailSeq?: number| null;
    lastPushSeq?: number| null;
}

export class UserNotificationsState extends FEntity {
    get uid(): number { return this._value.uid; }
    get readSeq(): number | null {
        let res = this._value.readSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readSeq) { return; }
        this._value.readSeq = value;
        this.markDirty();
    }
    get lastEmailNotification(): number | null {
        let res = this._value.lastEmailNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailNotification) { return; }
        this._value.lastEmailNotification = value;
        this.markDirty();
    }
    get lastPushNotification(): number | null {
        let res = this._value.lastPushNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushNotification) { return; }
        this._value.lastPushNotification = value;
        this.markDirty();
    }
    get lastEmailSeq(): number | null {
        let res = this._value.lastEmailSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailSeq) { return; }
        this._value.lastEmailSeq = value;
        this.markDirty();
    }
    get lastPushSeq(): number | null {
        let res = this._value.lastPushSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushSeq) { return; }
        this._value.lastPushSeq = value;
        this.markDirty();
    }
}

export class UserNotificationsStateFactory extends FEntityFactory<UserNotificationsState> {
    static schema: FEntitySchema = {
        name: 'UserNotificationsState',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'readSeq', type: 'number' },
            { name: 'lastEmailNotification', type: 'number' },
            { name: 'lastPushNotification', type: 'number' },
            { name: 'lastEmailSeq', type: 'number' },
            { name: 'lastPushSeq', type: 'number' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isNumber('readSeq', src.readSeq);
        validators.isNumber('lastEmailNotification', src.lastEmailNotification);
        validators.isNumber('lastPushNotification', src.lastPushNotification);
        validators.isNumber('lastEmailSeq', src.lastEmailSeq);
        validators.isNumber('lastPushSeq', src.lastPushSeq);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'userNotificationsState'),
            { enableVersioning: true, enableTimestamps: true, validator: UserNotificationsStateFactory.validate, hasLiveStreams: false },
            [],
            'UserNotificationsState'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(uid: number) {
        return await this._findById([uid]);
    }
    async create(uid: number, shape: UserNotificationsStateShape) {
        return await this._create([uid], { uid, ...shape });
    }
    watch(uid: number, cb: () => void) {
        return this._watch([uid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new UserNotificationsState(this.connection, this.namespace, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserNotificationsState');
    }
}
export interface HyperLogShape {
    type: string;
    date: number;
    body: any;
}

export class HyperLog extends FEntity {
    get id(): string { return this._value.id; }
    get type(): string {
        return this._value.type;
    }
    set type(value: string) {
        this._checkIsWritable();
        if (value === this._value.type) { return; }
        this._value.type = value;
        this.markDirty();
    }
    get date(): number {
        return this._value.date;
    }
    set date(value: number) {
        this._checkIsWritable();
        if (value === this._value.date) { return; }
        this._value.date = value;
        this.markDirty();
    }
    get body(): any {
        return this._value.body;
    }
    set body(value: any) {
        this._checkIsWritable();
        if (value === this._value.body) { return; }
        this._value.body = value;
        this.markDirty();
    }
}

export class HyperLogFactory extends FEntityFactory<HyperLog> {
    static schema: FEntitySchema = {
        name: 'HyperLog',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'type', type: 'string' },
            { name: 'date', type: 'number' },
            { name: 'body', type: 'json' },
        ],
        indexes: [
            { name: 'created', type: 'range', fields: ['createdAt'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('type', src.type);
        validators.isString('type', src.type);
        validators.notNull('date', src.date);
        validators.isNumber('date', src.date);
        validators.notNull('body', src.body);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'hyperLog'),
            { enableVersioning: false, enableTimestamps: true, validator: HyperLogFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('created', ['createdAt'], false)],
            'HyperLog'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: HyperLogShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async rangeFromCreated(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'created'], limit, reversed);
    }
    async rangeFromCreatedWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'created'], limit, after, reversed);
    }
    async allFromCreated() {
        return await this._findAll(['__indexes', 'created']);
    }
    createCreatedStream(limit: number, after?: string) {
        return this._createStream(['entity', 'hyperLog', '__indexes', 'created'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new HyperLog(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'HyperLog');
    }
}
export interface MessageDraftShape {
    contents: string;
}

export class MessageDraft extends FEntity {
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get contents(): string {
        return this._value.contents;
    }
    set contents(value: string) {
        this._checkIsWritable();
        if (value === this._value.contents) { return; }
        this._value.contents = value;
        this.markDirty();
    }
}

export class MessageDraftFactory extends FEntityFactory<MessageDraft> {
    static schema: FEntitySchema = {
        name: 'MessageDraft',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'contents', type: 'string', secure: true },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('contents', src.contents);
        validators.isString('contents', src.contents);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'messageDraft'),
            { enableVersioning: true, enableTimestamps: true, validator: MessageDraftFactory.validate, hasLiveStreams: false },
            [],
            'MessageDraft'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(uid: number, cid: number) {
        return await this._findById([uid, cid]);
    }
    async create(uid: number, cid: number, shape: MessageDraftShape) {
        return await this._create([uid, cid], { uid, cid, ...shape });
    }
    watch(uid: number, cid: number, cb: () => void) {
        return this._watch([uid, cid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new MessageDraft(this.connection, this.namespace, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'MessageDraft');
    }
}
export interface ChannelInvitationShape {
    creatorId: number;
    channelId: number;
    email: string;
    firstName?: string| null;
    lastName?: string| null;
    text?: string| null;
    acceptedById?: number| null;
    enabled: boolean;
}

export class ChannelInvitation extends FEntity {
    get id(): string { return this._value.id; }
    get creatorId(): number {
        return this._value.creatorId;
    }
    set creatorId(value: number) {
        this._checkIsWritable();
        if (value === this._value.creatorId) { return; }
        this._value.creatorId = value;
        this.markDirty();
    }
    get channelId(): number {
        return this._value.channelId;
    }
    set channelId(value: number) {
        this._checkIsWritable();
        if (value === this._value.channelId) { return; }
        this._value.channelId = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get acceptedById(): number | null {
        let res = this._value.acceptedById;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set acceptedById(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.acceptedById) { return; }
        this._value.acceptedById = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ChannelInvitationFactory extends FEntityFactory<ChannelInvitation> {
    static schema: FEntitySchema = {
        name: 'ChannelInvitation',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'creatorId', type: 'number' },
            { name: 'channelId', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'text', type: 'string' },
            { name: 'acceptedById', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'channel', type: 'range', fields: ['createdAt', 'channelId'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('creatorId', src.creatorId);
        validators.isNumber('creatorId', src.creatorId);
        validators.notNull('channelId', src.channelId);
        validators.isNumber('channelId', src.channelId);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('text', src.text);
        validators.isNumber('acceptedById', src.acceptedById);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'channelInvitation'),
            { enableVersioning: true, enableTimestamps: true, validator: ChannelInvitationFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('channel', ['createdAt', 'channelId'], false)],
            'ChannelInvitation'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: ChannelInvitationShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromChannelAfter(createdAt: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'channel', createdAt], after);
    }
    async rangeFromChannelAfter(createdAt: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'channel', createdAt], after, limit, reversed);
    }
    async rangeFromChannel(createdAt: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'channel', createdAt], limit, reversed);
    }
    async rangeFromChannelWithCursor(createdAt: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'channel', createdAt], limit, after, reversed);
    }
    async allFromChannel(createdAt: number) {
        return await this._findAll(['__indexes', 'channel', createdAt]);
    }
    createChannelStream(createdAt: number, limit: number, after?: string) {
        return this._createStream(['entity', 'channelInvitation', '__indexes', 'channel', createdAt], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ChannelInvitation(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ChannelInvitation');
    }
}
export interface ChannelLinkShape {
    creatorId: number;
    channelId: number;
    enabled: boolean;
}

export class ChannelLink extends FEntity {
    get id(): string { return this._value.id; }
    get creatorId(): number {
        return this._value.creatorId;
    }
    set creatorId(value: number) {
        this._checkIsWritable();
        if (value === this._value.creatorId) { return; }
        this._value.creatorId = value;
        this.markDirty();
    }
    get channelId(): number {
        return this._value.channelId;
    }
    set channelId(value: number) {
        this._checkIsWritable();
        if (value === this._value.channelId) { return; }
        this._value.channelId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ChannelLinkFactory extends FEntityFactory<ChannelLink> {
    static schema: FEntitySchema = {
        name: 'ChannelLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'creatorId', type: 'number' },
            { name: 'channelId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'channel', type: 'range', fields: ['createdAt', 'channelId'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('creatorId', src.creatorId);
        validators.isNumber('creatorId', src.creatorId);
        validators.notNull('channelId', src.channelId);
        validators.isNumber('channelId', src.channelId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'channelLink'),
            { enableVersioning: true, enableTimestamps: true, validator: ChannelLinkFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('channel', ['createdAt', 'channelId'], false)],
            'ChannelLink'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: ChannelLinkShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async allFromChannelAfter(createdAt: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'channel', createdAt], after);
    }
    async rangeFromChannelAfter(createdAt: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'channel', createdAt], after, limit, reversed);
    }
    async rangeFromChannel(createdAt: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'channel', createdAt], limit, reversed);
    }
    async rangeFromChannelWithCursor(createdAt: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'channel', createdAt], limit, after, reversed);
    }
    async allFromChannel(createdAt: number) {
        return await this._findAll(['__indexes', 'channel', createdAt]);
    }
    createChannelStream(createdAt: number, limit: number, after?: string) {
        return this._createStream(['entity', 'channelLink', '__indexes', 'channel', createdAt], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ChannelLink(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ChannelLink');
    }
}
export interface AppInviteLinkShape {
    uid: number;
}

export class AppInviteLink extends FEntity {
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
}

export class AppInviteLinkFactory extends FEntityFactory<AppInviteLink> {
    static schema: FEntitySchema = {
        name: 'AppInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['uid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'appInviteLink'),
            { enableVersioning: true, enableTimestamps: true, validator: AppInviteLinkFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('user', ['uid'], true)],
            'AppInviteLink'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: AppInviteLinkShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromUser(uid: number) {
        return await this._findFromIndex(['__indexes', 'user', uid]);
    }
    async rangeFromUser(limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'user'], limit, reversed);
    }
    async rangeFromUserWithCursor(limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'user'], limit, after, reversed);
    }
    async allFromUser() {
        return await this._findAll(['__indexes', 'user']);
    }
    createUserStream(limit: number, after?: string) {
        return this._createStream(['entity', 'appInviteLink', '__indexes', 'user'], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new AppInviteLink(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'AppInviteLink');
    }
}
export interface SampleEntityShape {
    data: string;
}

export class SampleEntity extends FEntity {
    get id(): string { return this._value.id; }
    get data(): string {
        return this._value.data;
    }
    set data(value: string) {
        this._checkIsWritable();
        if (value === this._value.data) { return; }
        this._value.data = value;
        this.markDirty();
    }
}

export class SampleEntityFactory extends FEntityFactory<SampleEntity> {
    static schema: FEntitySchema = {
        name: 'SampleEntity',
        editable: true,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'data', type: 'string' },
        ],
        indexes: [
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('data', src.data);
        validators.isString('data', src.data);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'sampleEntity'),
            { enableVersioning: true, enableTimestamps: true, validator: SampleEntityFactory.validate, hasLiveStreams: false },
            [],
            'SampleEntity'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: SampleEntityShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new SampleEntity(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'SampleEntity');
    }
}
export interface OrganizationPublicInviteLinkShape {
    uid: number;
    oid: number;
    enabled: boolean;
}

export class OrganizationPublicInviteLink extends FEntity {
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class OrganizationPublicInviteLinkFactory extends FEntityFactory<OrganizationPublicInviteLink> {
    static schema: FEntitySchema = {
        name: 'OrganizationPublicInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'oid', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'userInOrganization', type: 'unique', fields: ['uid', 'oid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationPublicInviteLink'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationPublicInviteLinkFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('userInOrganization', ['uid', 'oid'], true, src => src.enabled)],
            'OrganizationPublicInviteLink'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: OrganizationPublicInviteLinkShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromUserInOrganization(uid: number, oid: number) {
        return await this._findFromIndex(['__indexes', 'userInOrganization', uid, oid]);
    }
    async allFromUserInOrganizationAfter(uid: number, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'userInOrganization', uid], after);
    }
    async rangeFromUserInOrganizationAfter(uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'userInOrganization', uid], after, limit, reversed);
    }
    async rangeFromUserInOrganization(uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'userInOrganization', uid], limit, reversed);
    }
    async rangeFromUserInOrganizationWithCursor(uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'userInOrganization', uid], limit, after, reversed);
    }
    async allFromUserInOrganization(uid: number) {
        return await this._findAll(['__indexes', 'userInOrganization', uid]);
    }
    createUserInOrganizationStream(uid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationPublicInviteLink', '__indexes', 'userInOrganization', uid], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationPublicInviteLink(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationPublicInviteLink');
    }
}
export interface OrganizationInviteLinkShape {
    oid: number;
    email: string;
    uid: number;
    firstName?: string| null;
    lastName?: string| null;
    text?: string| null;
    ttl?: number| null;
    enabled: boolean;
    joined: boolean;
    role: 'MEMBER' | 'OWNER';
}

export class OrganizationInviteLink extends FEntity {
    get id(): string { return this._value.id; }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get ttl(): number | null {
        let res = this._value.ttl;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set ttl(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.ttl) { return; }
        this._value.ttl = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get joined(): boolean {
        return this._value.joined;
    }
    set joined(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.joined) { return; }
        this._value.joined = value;
        this.markDirty();
    }
    get role(): 'MEMBER' | 'OWNER' {
        return this._value.role;
    }
    set role(value: 'MEMBER' | 'OWNER') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
}

export class OrganizationInviteLinkFactory extends FEntityFactory<OrganizationInviteLink> {
    static schema: FEntitySchema = {
        name: 'OrganizationInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'oid', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'uid', type: 'number' },
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'text', type: 'string' },
            { name: 'ttl', type: 'number' },
            { name: 'enabled', type: 'boolean' },
            { name: 'joined', type: 'boolean' },
            { name: 'role', type: 'enum', enumValues: ['MEMBER', 'OWNER'] },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['oid', 'id'] },
            { name: 'emailInOrganization', type: 'unique', fields: ['email', 'oid'] },
        ],
    };

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('text', src.text);
        validators.isNumber('ttl', src.ttl);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.notNull('joined', src.joined);
        validators.isBoolean('joined', src.joined);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['MEMBER', 'OWNER']);
    }

    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'organizationInviteLink'),
            { enableVersioning: true, enableTimestamps: true, validator: OrganizationInviteLinkFactory.validate, hasLiveStreams: false },
            [new FEntityIndex('organization', ['oid', 'id'], true, src => src.enabled), new FEntityIndex('emailInOrganization', ['email', 'oid'], true, src => src.enabled)],
            'OrganizationInviteLink'
        );
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(id: string) {
        return await this._findById([id]);
    }
    async create(id: string, shape: OrganizationInviteLinkShape) {
        return await this._create([id], { id, ...shape });
    }
    watch(id: string, cb: () => void) {
        return this._watch([id], cb);
    }
    async findFromOrganization(oid: number, id: string) {
        return await this._findFromIndex(['__indexes', 'organization', oid, id]);
    }
    async allFromOrganizationAfter(oid: number, after: string) {
        return await this._findRangeAllAfter(['__indexes', 'organization', oid], after);
    }
    async rangeFromOrganizationAfter(oid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'organization', oid], after, limit, reversed);
    }
    async rangeFromOrganization(oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'organization', oid], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'organization', oid], limit, after, reversed);
    }
    async allFromOrganization(oid: number) {
        return await this._findAll(['__indexes', 'organization', oid]);
    }
    createOrganizationStream(oid: number, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationInviteLink', '__indexes', 'organization', oid], limit, after); 
    }
    async findFromEmailInOrganization(email: string, oid: number) {
        return await this._findFromIndex(['__indexes', 'emailInOrganization', email, oid]);
    }
    async allFromEmailInOrganizationAfter(email: string, after: number) {
        return await this._findRangeAllAfter(['__indexes', 'emailInOrganization', email], after);
    }
    async rangeFromEmailInOrganizationAfter(email: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(['__indexes', 'emailInOrganization', email], after, limit, reversed);
    }
    async rangeFromEmailInOrganization(email: string, limit: number, reversed?: boolean) {
        return await this._findRange(['__indexes', 'emailInOrganization', email], limit, reversed);
    }
    async rangeFromEmailInOrganizationWithCursor(email: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(['__indexes', 'emailInOrganization', email], limit, after, reversed);
    }
    async allFromEmailInOrganization(email: string) {
        return await this._findAll(['__indexes', 'emailInOrganization', email]);
    }
    createEmailInOrganizationStream(email: string, limit: number, after?: string) {
        return this._createStream(['entity', 'organizationInviteLink', '__indexes', 'emailInOrganization', email], limit, after); 
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new OrganizationInviteLink(this.connection, this.namespace, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationInviteLink');
    }
}

export class AllEntities extends FDBInstance {
    static readonly schema: FEntitySchema[] = [
        OnlineFactory.schema,
        PresenceFactory.schema,
        AuthTokenFactory.schema,
        ServiceCacheFactory.schema,
        LockFactory.schema,
        TaskFactory.schema,
        PushFirebaseFactory.schema,
        PushAppleFactory.schema,
        PushWebFactory.schema,
        UserProfilePrefilFactory.schema,
        UserFactory.schema,
        UserProfileFactory.schema,
        OrganizationFactory.schema,
        OrganizationProfileFactory.schema,
        OrganizationEditorialFactory.schema,
        OrganizationMemberFactory.schema,
        FeatureFlagFactory.schema,
        OrganizationFeaturesFactory.schema,
        ReaderStateFactory.schema,
        SuperAdminFactory.schema,
        UserSettingsFactory.schema,
        ShortnameReservationFactory.schema,
        AuthCodeSessionFactory.schema,
        ConversationFactory.schema,
        ConversationPrivateFactory.schema,
        ConversationOrganizationFactory.schema,
        ConversationRoomFactory.schema,
        RoomProfileFactory.schema,
        RoomParticipantFactory.schema,
        ConversationReceiverFactory.schema,
        SequenceFactory.schema,
        MessageFactory.schema,
        ConversationSeqFactory.schema,
        ConversationEventFactory.schema,
        UserDialogFactory.schema,
        UserDialogSettingsFactory.schema,
        UserDialogEventFactory.schema,
        UserMessagingStateFactory.schema,
        UserNotificationsStateFactory.schema,
        HyperLogFactory.schema,
        MessageDraftFactory.schema,
        ChannelInvitationFactory.schema,
        ChannelLinkFactory.schema,
        AppInviteLinkFactory.schema,
        SampleEntityFactory.schema,
        OrganizationPublicInviteLinkFactory.schema,
        OrganizationInviteLinkFactory.schema,
    ];
    allEntities: FEntityFactory<FEntity>[] = [];
    Online: OnlineFactory;
    Presence: PresenceFactory;
    AuthToken: AuthTokenFactory;
    ServiceCache: ServiceCacheFactory;
    Lock: LockFactory;
    Task: TaskFactory;
    PushFirebase: PushFirebaseFactory;
    PushApple: PushAppleFactory;
    PushWeb: PushWebFactory;
    UserProfilePrefil: UserProfilePrefilFactory;
    User: UserFactory;
    UserProfile: UserProfileFactory;
    Organization: OrganizationFactory;
    OrganizationProfile: OrganizationProfileFactory;
    OrganizationEditorial: OrganizationEditorialFactory;
    OrganizationMember: OrganizationMemberFactory;
    FeatureFlag: FeatureFlagFactory;
    OrganizationFeatures: OrganizationFeaturesFactory;
    ReaderState: ReaderStateFactory;
    SuperAdmin: SuperAdminFactory;
    UserSettings: UserSettingsFactory;
    ShortnameReservation: ShortnameReservationFactory;
    AuthCodeSession: AuthCodeSessionFactory;
    Conversation: ConversationFactory;
    ConversationPrivate: ConversationPrivateFactory;
    ConversationOrganization: ConversationOrganizationFactory;
    ConversationRoom: ConversationRoomFactory;
    RoomProfile: RoomProfileFactory;
    RoomParticipant: RoomParticipantFactory;
    ConversationReceiver: ConversationReceiverFactory;
    Sequence: SequenceFactory;
    Message: MessageFactory;
    ConversationSeq: ConversationSeqFactory;
    ConversationEvent: ConversationEventFactory;
    UserDialog: UserDialogFactory;
    UserDialogSettings: UserDialogSettingsFactory;
    UserDialogEvent: UserDialogEventFactory;
    UserMessagingState: UserMessagingStateFactory;
    UserNotificationsState: UserNotificationsStateFactory;
    HyperLog: HyperLogFactory;
    MessageDraft: MessageDraftFactory;
    ChannelInvitation: ChannelInvitationFactory;
    ChannelLink: ChannelLinkFactory;
    AppInviteLink: AppInviteLinkFactory;
    SampleEntity: SampleEntityFactory;
    OrganizationPublicInviteLink: OrganizationPublicInviteLinkFactory;
    OrganizationInviteLink: OrganizationInviteLinkFactory;

    constructor(connection: FConnection) {
        super(connection);
        this.Online = new OnlineFactory(connection);
        this.allEntities.push(this.Online);
        this.Presence = new PresenceFactory(connection);
        this.allEntities.push(this.Presence);
        this.AuthToken = new AuthTokenFactory(connection);
        this.allEntities.push(this.AuthToken);
        this.ServiceCache = new ServiceCacheFactory(connection);
        this.allEntities.push(this.ServiceCache);
        this.Lock = new LockFactory(connection);
        this.allEntities.push(this.Lock);
        this.Task = new TaskFactory(connection);
        this.allEntities.push(this.Task);
        this.PushFirebase = new PushFirebaseFactory(connection);
        this.allEntities.push(this.PushFirebase);
        this.PushApple = new PushAppleFactory(connection);
        this.allEntities.push(this.PushApple);
        this.PushWeb = new PushWebFactory(connection);
        this.allEntities.push(this.PushWeb);
        this.UserProfilePrefil = new UserProfilePrefilFactory(connection);
        this.allEntities.push(this.UserProfilePrefil);
        this.User = new UserFactory(connection);
        this.allEntities.push(this.User);
        this.UserProfile = new UserProfileFactory(connection);
        this.allEntities.push(this.UserProfile);
        this.Organization = new OrganizationFactory(connection);
        this.allEntities.push(this.Organization);
        this.OrganizationProfile = new OrganizationProfileFactory(connection);
        this.allEntities.push(this.OrganizationProfile);
        this.OrganizationEditorial = new OrganizationEditorialFactory(connection);
        this.allEntities.push(this.OrganizationEditorial);
        this.OrganizationMember = new OrganizationMemberFactory(connection);
        this.allEntities.push(this.OrganizationMember);
        this.FeatureFlag = new FeatureFlagFactory(connection);
        this.allEntities.push(this.FeatureFlag);
        this.OrganizationFeatures = new OrganizationFeaturesFactory(connection);
        this.allEntities.push(this.OrganizationFeatures);
        this.ReaderState = new ReaderStateFactory(connection);
        this.allEntities.push(this.ReaderState);
        this.SuperAdmin = new SuperAdminFactory(connection);
        this.allEntities.push(this.SuperAdmin);
        this.UserSettings = new UserSettingsFactory(connection);
        this.allEntities.push(this.UserSettings);
        this.ShortnameReservation = new ShortnameReservationFactory(connection);
        this.allEntities.push(this.ShortnameReservation);
        this.AuthCodeSession = new AuthCodeSessionFactory(connection);
        this.allEntities.push(this.AuthCodeSession);
        this.Conversation = new ConversationFactory(connection);
        this.allEntities.push(this.Conversation);
        this.ConversationPrivate = new ConversationPrivateFactory(connection);
        this.allEntities.push(this.ConversationPrivate);
        this.ConversationOrganization = new ConversationOrganizationFactory(connection);
        this.allEntities.push(this.ConversationOrganization);
        this.ConversationRoom = new ConversationRoomFactory(connection);
        this.allEntities.push(this.ConversationRoom);
        this.RoomProfile = new RoomProfileFactory(connection);
        this.allEntities.push(this.RoomProfile);
        this.RoomParticipant = new RoomParticipantFactory(connection);
        this.allEntities.push(this.RoomParticipant);
        this.ConversationReceiver = new ConversationReceiverFactory(connection);
        this.allEntities.push(this.ConversationReceiver);
        this.Sequence = new SequenceFactory(connection);
        this.allEntities.push(this.Sequence);
        this.Message = new MessageFactory(connection);
        this.allEntities.push(this.Message);
        this.ConversationSeq = new ConversationSeqFactory(connection);
        this.allEntities.push(this.ConversationSeq);
        this.ConversationEvent = new ConversationEventFactory(connection);
        this.allEntities.push(this.ConversationEvent);
        this.UserDialog = new UserDialogFactory(connection);
        this.allEntities.push(this.UserDialog);
        this.UserDialogSettings = new UserDialogSettingsFactory(connection);
        this.allEntities.push(this.UserDialogSettings);
        this.UserDialogEvent = new UserDialogEventFactory(connection);
        this.allEntities.push(this.UserDialogEvent);
        this.UserMessagingState = new UserMessagingStateFactory(connection);
        this.allEntities.push(this.UserMessagingState);
        this.UserNotificationsState = new UserNotificationsStateFactory(connection);
        this.allEntities.push(this.UserNotificationsState);
        this.HyperLog = new HyperLogFactory(connection);
        this.allEntities.push(this.HyperLog);
        this.MessageDraft = new MessageDraftFactory(connection);
        this.allEntities.push(this.MessageDraft);
        this.ChannelInvitation = new ChannelInvitationFactory(connection);
        this.allEntities.push(this.ChannelInvitation);
        this.ChannelLink = new ChannelLinkFactory(connection);
        this.allEntities.push(this.ChannelLink);
        this.AppInviteLink = new AppInviteLinkFactory(connection);
        this.allEntities.push(this.AppInviteLink);
        this.SampleEntity = new SampleEntityFactory(connection);
        this.allEntities.push(this.SampleEntity);
        this.OrganizationPublicInviteLink = new OrganizationPublicInviteLinkFactory(connection);
        this.allEntities.push(this.OrganizationPublicInviteLink);
        this.OrganizationInviteLink = new OrganizationInviteLinkFactory(connection);
        this.allEntities.push(this.OrganizationInviteLink);
    }
}
