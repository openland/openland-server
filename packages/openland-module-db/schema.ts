// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
import { FEntity } from 'foundation-orm/FEntity';
import { FNamespace } from 'foundation-orm/FNamespace';
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
import { FConnection } from 'foundation-orm/FConnection';

export interface OnlineShape {
    lastSeen: number;
}

export class Online extends FEntity {
    get uid() { return this._value.uid; }
    get lastSeen() {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
}

export class OnlineFactory extends FEntityFactory<Online, OnlineShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'online'), { enableVersioning: false, enableTimestamps: false });
    }
    async findById(uid: number) {
        return await this._findById([uid]);
    }
    createOrUpdate(uid: number, shape: OnlineShape) {
        return this._create([uid], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new Online(this.connection, this.namespace, id, value, this.options);
    }
}
export interface PresenceShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
}

export class Presence extends FEntity {
    get uid() { return this._value.uid; }
    get tid() { return this._value.tid; }
    get lastSeen() {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
    get lastSeenTimeout() {
        return this._value.lastSeenTimeout;
    }
    set lastSeenTimeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeenTimeout) { return; }
        this._value.lastSeenTimeout = value;
        this.markDirty();
    }
    get platform() {
        return this._value.platform;
    }
    set platform(value: string) {
        this._checkIsWritable();
        if (value === this._value.platform) { return; }
        this._value.platform = value;
        this.markDirty();
    }
}

export class PresenceFactory extends FEntityFactory<Presence, PresenceShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'presence'), { enableVersioning: false, enableTimestamps: false });
    }
    async findById(uid: number, tid: number) {
        return await this._findById([uid, tid]);
    }
    createOrUpdate(uid: number, tid: number, shape: PresenceShape) {
        return this._create([uid, tid], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new Presence(this.connection, this.namespace, id, value, this.options);
    }
}
export interface CounterShape {
    value: number;
}

export class Counter extends FEntity {
    get name() { return this._value.name; }
    get value() {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class CounterFactory extends FEntityFactory<Counter, CounterShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'counter'), { enableVersioning: false, enableTimestamps: false });
    }
    async findById(name: string) {
        return await this._findById([name]);
    }
    createOrUpdate(name: string, shape: CounterShape) {
        return this._create([name], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new Counter(this.connection, this.namespace, id, value, this.options);
    }
}
export interface UserTokenShape {
    uid: number;
    lastIp: string;
}

export class UserToken extends FEntity {
    get uuid() { return this._value.uuid; }
    get uid() {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get lastIp() {
        return this._value.lastIp;
    }
    set lastIp(value: string) {
        this._checkIsWritable();
        if (value === this._value.lastIp) { return; }
        this._value.lastIp = value;
        this.markDirty();
    }
}

export class UserTokenFactory extends FEntityFactory<UserToken, UserTokenShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'userToken'), { enableVersioning: true, enableTimestamps: true });
    }
    async findById(uuid: string) {
        return await this._findById([uuid]);
    }
    createOrUpdate(uuid: string, shape: UserTokenShape) {
        return this._create([uuid], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new UserToken(this.connection, this.namespace, id, value, this.options);
    }
}
export interface ServiceCacheShape {
    value: string;
}

export class ServiceCache extends FEntity {
    get service() { return this._value.service; }
    get key() { return this._value.key; }
    get value() {
        return this._value.value;
    }
    set value(value: string) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class ServiceCacheFactory extends FEntityFactory<ServiceCache, ServiceCacheShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'serviceCache'), { enableVersioning: true, enableTimestamps: true });
    }
    async findById(service: string, key: string) {
        return await this._findById([service, key]);
    }
    createOrUpdate(service: string, key: string, shape: ServiceCacheShape) {
        return this._create([service, key], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new ServiceCache(this.connection, this.namespace, id, value, this.options);
    }
}
export interface LockShape {
    seed: string;
    timeout: number;
    version: number;
    minVersion: number;
}

export class Lock extends FEntity {
    get key() { return this._value.key; }
    get seed() {
        return this._value.seed;
    }
    set seed(value: string) {
        this._checkIsWritable();
        if (value === this._value.seed) { return; }
        this._value.seed = value;
        this.markDirty();
    }
    get timeout() {
        return this._value.timeout;
    }
    set timeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.timeout) { return; }
        this._value.timeout = value;
        this.markDirty();
    }
    get version() {
        return this._value.version;
    }
    set version(value: number) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
    get minVersion() {
        return this._value.minVersion;
    }
    set minVersion(value: number) {
        this._checkIsWritable();
        if (value === this._value.minVersion) { return; }
        this._value.minVersion = value;
        this.markDirty();
    }
}

export class LockFactory extends FEntityFactory<Lock, LockShape> {
    constructor(connection: FConnection) {
        super(connection, new FNamespace('entity', 'lock'), { enableVersioning: false, enableTimestamps: false });
    }
    async findById(key: string) {
        return await this._findById([key]);
    }
    createOrUpdate(key: string, shape: LockShape) {
        return this._create([key], shape);
    }
    protected _createEntity(id: (string | number)[], value: any) {
        return new Lock(this.connection, this.namespace, id, value, this.options);
    }
}

export class AllEntities {
    Online: OnlineFactory;
    Presence: PresenceFactory;
    Counter: CounterFactory;
    UserToken: UserTokenFactory;
    ServiceCache: ServiceCacheFactory;
    Lock: LockFactory;

    constructor(connection: FConnection) {
        this.Online = new OnlineFactory(connection);
        this.Presence = new PresenceFactory(connection);
        this.Counter = new CounterFactory(connection);
        this.UserToken = new UserTokenFactory(connection);
        this.ServiceCache = new ServiceCacheFactory(connection);
        this.Lock = new LockFactory(connection);
    }
}
