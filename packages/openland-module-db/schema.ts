// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { EntitiesBase } from 'foundation-orm/EntitiesBase';
// @ts-ignore
import { Subspace, Directory } from '@openland/foundationdb';
// @ts-ignore
import { FEntity, FEntityOptions } from 'foundation-orm/FEntity';
// @ts-ignore
import { FEntitySchema } from 'foundation-orm/FEntitySchema';
// @ts-ignore
import { FEntityIndex } from 'foundation-orm/FEntityIndex';
// @ts-ignore
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
// @ts-ignore
import { FConnection } from 'foundation-orm/FConnection';
// @ts-ignore
import { validators } from 'foundation-orm/utils/validators';
// @ts-ignore
import { EntityLayer } from 'foundation-orm/EntityLayer';
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { json, jField, jNumber, jString, jBool, jVec, jEnum, jEnumString } from 'openland-utils/jsonSchema';

export interface EnvironmentShape {
    comment: string;
}

export class Environment extends FEntity {
    readonly entityName: 'Environment' = 'Environment';
    get production(): number { return this._value.production; }
    get comment(): string {
        return this._value.comment;
    }
    set comment(value: string) {
        this._checkIsWritable();
        if (value === this._value.comment) { return; }
        this._value.comment = value;
        this.markDirty();
    }
}

export class EnvironmentFactory extends FEntityFactory<Environment> {
    static schema: FEntitySchema = {
        name: 'Environment',
        editable: true,
        primaryKeys: [
            { name: 'production', type: 'number' },
        ],
        fields: [
            { name: 'comment', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('environment');
        let config = { enableVersioning: false, enableTimestamps: false, validator: EnvironmentFactory.validate, hasLiveStreams: false };
        return new EnvironmentFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('production', src.production);
        validators.isNumber('production', src.production);
        validators.notNull('comment', src.comment);
        validators.isString('comment', src.comment);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('Environment', 'environment', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'production': rawId[0] };
    }
    async findById(ctx: Context, production: number) {
        return await this._findById(ctx, [production]);
    }
    async create(ctx: Context, production: number, shape: EnvironmentShape) {
        return await this._create(ctx, [production], { production, ...shape });
    }
    async create_UNSAFE(ctx: Context, production: number, shape: EnvironmentShape) {
        return await this._create_UNSAFE(ctx, [production], { production, ...shape });
    }
    watch(ctx: Context, production: number) {
        return this._watch(ctx, [production]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Environment(ctx, this.layer, this.directory, [value.production], value, this.options, isNew, this.indexes, 'Environment');
    }
}
export interface EnvironmentVariableShape {
    value: string;
}

export class EnvironmentVariable extends FEntity {
    readonly entityName: 'EnvironmentVariable' = 'EnvironmentVariable';
    get name(): string { return this._value.name; }
    get value(): string {
        return this._value.value;
    }
    set value(value: string) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class EnvironmentVariableFactory extends FEntityFactory<EnvironmentVariable> {
    static schema: FEntitySchema = {
        name: 'EnvironmentVariable',
        editable: true,
        primaryKeys: [
            { name: 'name', type: 'string' },
        ],
        fields: [
            { name: 'value', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('environmentVariable');
        let config = { enableVersioning: true, enableTimestamps: true, validator: EnvironmentVariableFactory.validate, hasLiveStreams: false };
        return new EnvironmentVariableFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('name', src.name);
        validators.isString('name', src.name);
        validators.notNull('value', src.value);
        validators.isString('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('EnvironmentVariable', 'environmentVariable', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'name': rawId[0] };
    }
    async findById(ctx: Context, name: string) {
        return await this._findById(ctx, [name]);
    }
    async create(ctx: Context, name: string, shape: EnvironmentVariableShape) {
        return await this._create(ctx, [name], { name, ...shape });
    }
    async create_UNSAFE(ctx: Context, name: string, shape: EnvironmentVariableShape) {
        return await this._create_UNSAFE(ctx, [name], { name, ...shape });
    }
    watch(ctx: Context, name: string) {
        return this._watch(ctx, [name]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new EnvironmentVariable(ctx, this.layer, this.directory, [value.name], value, this.options, isNew, this.indexes, 'EnvironmentVariable');
    }
}
export interface OnlineShape {
    lastSeen: number;
    activeExpires?: number| null;
    active?: boolean| null;
}

export class Online extends FEntity {
    readonly entityName: 'Online' = 'Online';
    get uid(): number { return this._value.uid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
    get activeExpires(): number | null {
        let res = this._value.activeExpires;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set activeExpires(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.activeExpires) { return; }
        this._value.activeExpires = value;
        this.markDirty();
    }
    get active(): boolean | null {
        let res = this._value.active;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set active(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.active) { return; }
        this._value.active = value;
        this.markDirty();
    }
}

export class OnlineFactory extends FEntityFactory<Online> {
    static schema: FEntitySchema = {
        name: 'Online',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'lastSeen', type: 'number' },
            { name: 'activeExpires', type: 'number' },
            { name: 'active', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('online');
        let config = { enableVersioning: false, enableTimestamps: false, validator: OnlineFactory.validate, hasLiveStreams: false };
        return new OnlineFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('lastSeen', src.lastSeen);
        validators.isNumber('lastSeen', src.lastSeen);
        validators.isNumber('activeExpires', src.activeExpires);
        validators.isBoolean('active', src.active);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('Online', 'online', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: OnlineShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: OnlineShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Online(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'Online');
    }
}
export interface PresenceShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
    active?: boolean| null;
}

export class Presence extends FEntity {
    readonly entityName: 'Presence' = 'Presence';
    get uid(): number { return this._value.uid; }
    get tid(): string { return this._value.tid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
    get lastSeenTimeout(): number {
        return this._value.lastSeenTimeout;
    }
    set lastSeenTimeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeenTimeout) { return; }
        this._value.lastSeenTimeout = value;
        this.markDirty();
    }
    get platform(): string {
        return this._value.platform;
    }
    set platform(value: string) {
        this._checkIsWritable();
        if (value === this._value.platform) { return; }
        this._value.platform = value;
        this.markDirty();
    }
    get active(): boolean | null {
        let res = this._value.active;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set active(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.active) { return; }
        this._value.active = value;
        this.markDirty();
    }
}

export class PresenceFactory extends FEntityFactory<Presence> {
    static schema: FEntitySchema = {
        name: 'Presence',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
        ],
        fields: [
            { name: 'lastSeen', type: 'number' },
            { name: 'lastSeenTimeout', type: 'number' },
            { name: 'platform', type: 'string' },
            { name: 'active', type: 'boolean' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'lastSeen'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('presence');
        let config = { enableVersioning: false, enableTimestamps: false, validator: PresenceFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('presence', 'user'), 'user', ['uid', 'lastSeen'], false);
        let indexes = {
            user: indexUser,
        };
        return new PresenceFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('lastSeen', src.lastSeen);
        validators.isNumber('lastSeen', src.lastSeen);
        validators.notNull('lastSeenTimeout', src.lastSeenTimeout);
        validators.isNumber('lastSeenTimeout', src.lastSeenTimeout);
        validators.notNull('platform', src.platform);
        validators.isString('platform', src.platform);
        validators.isBoolean('active', src.active);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('Presence', 'presence', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'tid': rawId[1] };
    }
    async findById(ctx: Context, uid: number, tid: string) {
        return await this._findById(ctx, [uid, tid]);
    }
    async create(ctx: Context, uid: number, tid: string, shape: PresenceShape) {
        return await this._create(ctx, [uid, tid], { uid, tid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, tid: string, shape: PresenceShape) {
        return await this._create_UNSAFE(ctx, [uid, tid], { uid, tid, ...shape });
    }
    watch(ctx: Context, uid: number, tid: string) {
        return this._watch(ctx, [uid, tid]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Presence(ctx, this.layer, this.directory, [value.uid, value.tid], value, this.options, isNew, this.indexes, 'Presence');
    }
}
export interface AuthTokenShape {
    salt: string;
    uid: number;
    lastIp: string;
    enabled?: boolean| null;
}

export class AuthToken extends FEntity {
    readonly entityName: 'AuthToken' = 'AuthToken';
    get uuid(): string { return this._value.uuid; }
    get salt(): string {
        return this._value.salt;
    }
    set salt(value: string) {
        this._checkIsWritable();
        if (value === this._value.salt) { return; }
        this._value.salt = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get lastIp(): string {
        return this._value.lastIp;
    }
    set lastIp(value: string) {
        this._checkIsWritable();
        if (value === this._value.lastIp) { return; }
        this._value.lastIp = value;
        this.markDirty();
    }
    get enabled(): boolean | null {
        let res = this._value.enabled;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set enabled(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class AuthTokenFactory extends FEntityFactory<AuthToken> {
    static schema: FEntitySchema = {
        name: 'AuthToken',
        editable: false,
        primaryKeys: [
            { name: 'uuid', type: 'string' },
        ],
        fields: [
            { name: 'salt', type: 'string' },
            { name: 'uid', type: 'number' },
            { name: 'lastIp', type: 'string' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'salt', type: 'unique', fields: ['salt'], displayName: 'authTokenBySalt' },
            { name: 'user', type: 'range', fields: ['uid', 'uuid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('authToken');
        let config = { enableVersioning: true, enableTimestamps: true, validator: AuthTokenFactory.validate, hasLiveStreams: false };
        let indexSalt = new FEntityIndex(await layer.resolveEntityIndexDirectory('authToken', 'salt'), 'salt', ['salt'], true);
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('authToken', 'user'), 'user', ['uid', 'uuid'], false, src => src.enabled !== false);
        let indexes = {
            salt: indexSalt,
            user: indexUser,
        };
        return new AuthTokenFactory(layer, directory, config, indexes);
    }

    readonly indexSalt: FEntityIndex;
    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uuid', src.uuid);
        validators.isString('uuid', src.uuid);
        validators.notNull('salt', src.salt);
        validators.isString('salt', src.salt);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('lastIp', src.lastIp);
        validators.isString('lastIp', src.lastIp);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { salt: FEntityIndex, user: FEntityIndex }) {
        super('AuthToken', 'authToken', config, [indexes.salt, indexes.user], layer, directory);
        this.indexSalt = indexes.salt;
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uuid': rawId[0] };
    }
    async findById(ctx: Context, uuid: string) {
        return await this._findById(ctx, [uuid]);
    }
    async create(ctx: Context, uuid: string, shape: AuthTokenShape) {
        return await this._create(ctx, [uuid], { uuid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uuid: string, shape: AuthTokenShape) {
        return await this._create_UNSAFE(ctx, [uuid], { uuid, ...shape });
    }
    watch(ctx: Context, uuid: string) {
        return this._watch(ctx, [uuid]);
    }
    async findFromSalt(ctx: Context, salt: string) {
        return await this._findFromIndex(ctx, this.indexSalt.directory, [salt]);
    }
    async rangeFromSalt(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexSalt.directory, [], limit, reversed);
    }
    async rangeFromSaltWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexSalt.directory, [], limit, after, reversed);
    }
    async allFromSalt(ctx: Context, ) {
        return await this._findAll(ctx, this.indexSalt.directory, []);
    }
    createSaltStream(limit: number, after?: string) {
        return this._createStream(this.indexSalt.directory, [], limit, after); 
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new AuthToken(ctx, this.layer, this.directory, [value.uuid], value, this.options, isNew, this.indexes, 'AuthToken');
    }
}
export interface ServiceCacheShape {
    value?: string| null;
}

export class ServiceCache extends FEntity {
    readonly entityName: 'ServiceCache' = 'ServiceCache';
    get service(): string { return this._value.service; }
    get key(): string { return this._value.key; }
    get value(): string | null {
        let res = this._value.value;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set value(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class ServiceCacheFactory extends FEntityFactory<ServiceCache> {
    static schema: FEntitySchema = {
        name: 'ServiceCache',
        editable: false,
        primaryKeys: [
            { name: 'service', type: 'string' },
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'value', type: 'string' },
        ],
        indexes: [
            { name: 'fromService', type: 'range', fields: ['service', 'key'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('serviceCache');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ServiceCacheFactory.validate, hasLiveStreams: false };
        let indexFromService = new FEntityIndex(await layer.resolveEntityIndexDirectory('serviceCache', 'fromService'), 'fromService', ['service', 'key'], false);
        let indexes = {
            fromService: indexFromService,
        };
        return new ServiceCacheFactory(layer, directory, config, indexes);
    }

    readonly indexFromService: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('service', src.service);
        validators.isString('service', src.service);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.isString('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { fromService: FEntityIndex }) {
        super('ServiceCache', 'serviceCache', config, [indexes.fromService], layer, directory);
        this.indexFromService = indexes.fromService;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'service': rawId[0], 'key': rawId[1] };
    }
    async findById(ctx: Context, service: string, key: string) {
        return await this._findById(ctx, [service, key]);
    }
    async create(ctx: Context, service: string, key: string, shape: ServiceCacheShape) {
        return await this._create(ctx, [service, key], { service, key, ...shape });
    }
    async create_UNSAFE(ctx: Context, service: string, key: string, shape: ServiceCacheShape) {
        return await this._create_UNSAFE(ctx, [service, key], { service, key, ...shape });
    }
    watch(ctx: Context, service: string, key: string) {
        return this._watch(ctx, [service, key]);
    }
    async allFromFromServiceAfter(ctx: Context, service: string, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexFromService.directory, [service], after);
    }
    async rangeFromFromServiceAfter(ctx: Context, service: string, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexFromService.directory, [service], after, limit, reversed);
    }
    async rangeFromFromService(ctx: Context, service: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexFromService.directory, [service], limit, reversed);
    }
    async rangeFromFromServiceWithCursor(ctx: Context, service: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexFromService.directory, [service], limit, after, reversed);
    }
    async allFromFromService(ctx: Context, service: string) {
        return await this._findAll(ctx, this.indexFromService.directory, [service]);
    }
    createFromServiceStream(service: string, limit: number, after?: string) {
        return this._createStream(this.indexFromService.directory, [service], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ServiceCache(ctx, this.layer, this.directory, [value.service, value.key], value, this.options, isNew, this.indexes, 'ServiceCache');
    }
}
export interface LockShape {
    seed: string;
    timeout: number;
    version: number;
    minVersion: number;
}

export class Lock extends FEntity {
    readonly entityName: 'Lock' = 'Lock';
    get key(): string { return this._value.key; }
    get seed(): string {
        return this._value.seed;
    }
    set seed(value: string) {
        this._checkIsWritable();
        if (value === this._value.seed) { return; }
        this._value.seed = value;
        this.markDirty();
    }
    get timeout(): number {
        return this._value.timeout;
    }
    set timeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.timeout) { return; }
        this._value.timeout = value;
        this.markDirty();
    }
    get version(): number {
        return this._value.version;
    }
    set version(value: number) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
    get minVersion(): number {
        return this._value.minVersion;
    }
    set minVersion(value: number) {
        this._checkIsWritable();
        if (value === this._value.minVersion) { return; }
        this._value.minVersion = value;
        this.markDirty();
    }
}

export class LockFactory extends FEntityFactory<Lock> {
    static schema: FEntitySchema = {
        name: 'Lock',
        editable: false,
        primaryKeys: [
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'seed', type: 'string' },
            { name: 'timeout', type: 'number' },
            { name: 'version', type: 'number' },
            { name: 'minVersion', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('lock');
        let config = { enableVersioning: false, enableTimestamps: false, validator: LockFactory.validate, hasLiveStreams: false };
        return new LockFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('seed', src.seed);
        validators.isString('seed', src.seed);
        validators.notNull('timeout', src.timeout);
        validators.isNumber('timeout', src.timeout);
        validators.notNull('version', src.version);
        validators.isNumber('version', src.version);
        validators.notNull('minVersion', src.minVersion);
        validators.isNumber('minVersion', src.minVersion);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('Lock', 'lock', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'key': rawId[0] };
    }
    async findById(ctx: Context, key: string) {
        return await this._findById(ctx, [key]);
    }
    async create(ctx: Context, key: string, shape: LockShape) {
        return await this._create(ctx, [key], { key, ...shape });
    }
    async create_UNSAFE(ctx: Context, key: string, shape: LockShape) {
        return await this._create_UNSAFE(ctx, [key], { key, ...shape });
    }
    watch(ctx: Context, key: string) {
        return this._watch(ctx, [key]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Lock(ctx, this.layer, this.directory, [value.key], value, this.options, isNew, this.indexes, 'Lock');
    }
}
export interface TaskShape {
    arguments: any;
    result?: any| null;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureCount?: number| null;
    taskFailureTime?: number| null;
    taskLockSeed?: string| null;
    taskLockTimeout?: number| null;
    taskFailureMessage?: string| null;
}

export class Task extends FEntity {
    readonly entityName: 'Task' = 'Task';
    get taskType(): string { return this._value.taskType; }
    get uid(): string { return this._value.uid; }
    get arguments(): any {
        return this._value.arguments;
    }
    set arguments(value: any) {
        this._checkIsWritable();
        if (value === this._value.arguments) { return; }
        this._value.arguments = value;
        this.markDirty();
    }
    get result(): any | null {
        let res = this._value.result;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set result(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.result) { return; }
        this._value.result = value;
        this.markDirty();
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' {
        return this._value.taskStatus;
    }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.taskStatus) { return; }
        this._value.taskStatus = value;
        this.markDirty();
    }
    get taskFailureCount(): number | null {
        let res = this._value.taskFailureCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureCount) { return; }
        this._value.taskFailureCount = value;
        this.markDirty();
    }
    get taskFailureTime(): number | null {
        let res = this._value.taskFailureTime;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureTime(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureTime) { return; }
        this._value.taskFailureTime = value;
        this.markDirty();
    }
    get taskLockSeed(): string | null {
        let res = this._value.taskLockSeed;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskLockSeed(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockSeed) { return; }
        this._value.taskLockSeed = value;
        this.markDirty();
    }
    get taskLockTimeout(): number | null {
        let res = this._value.taskLockTimeout;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskLockTimeout(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockTimeout) { return; }
        this._value.taskLockTimeout = value;
        this.markDirty();
    }
    get taskFailureMessage(): string | null {
        let res = this._value.taskFailureMessage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureMessage(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureMessage) { return; }
        this._value.taskFailureMessage = value;
        this.markDirty();
    }
}

export class TaskFactory extends FEntityFactory<Task> {
    static schema: FEntitySchema = {
        name: 'Task',
        editable: false,
        primaryKeys: [
            { name: 'taskType', type: 'string' },
            { name: 'uid', type: 'string' },
        ],
        fields: [
            { name: 'arguments', type: 'json' },
            { name: 'result', type: 'json' },
            { name: 'taskStatus', type: 'enum', enumValues: ['pending', 'executing', 'failing', 'failed', 'completed'] },
            { name: 'taskFailureCount', type: 'number' },
            { name: 'taskFailureTime', type: 'number' },
            { name: 'taskLockSeed', type: 'string' },
            { name: 'taskLockTimeout', type: 'number' },
            { name: 'taskFailureMessage', type: 'string' },
        ],
        indexes: [
            { name: 'pending', type: 'range', fields: ['taskType', 'createdAt'], displayName: 'tasksPending' },
            { name: 'executing', type: 'range', fields: ['taskLockTimeout'], displayName: 'tasksExecuting' },
            { name: 'failing', type: 'range', fields: ['taskFailureTime'], displayName: 'tasksFailing' },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('task');
        let config = { enableVersioning: true, enableTimestamps: true, validator: TaskFactory.validate, hasLiveStreams: false };
        let indexPending = new FEntityIndex(await layer.resolveEntityIndexDirectory('task', 'pending'), 'pending', ['taskType', 'createdAt'], false, (src) => src.taskStatus === 'pending');
        let indexExecuting = new FEntityIndex(await layer.resolveEntityIndexDirectory('task', 'executing'), 'executing', ['taskLockTimeout'], false, (src) => src.taskStatus === 'executing');
        let indexFailing = new FEntityIndex(await layer.resolveEntityIndexDirectory('task', 'failing'), 'failing', ['taskFailureTime'], false, (src) => src.taskStatus === 'failing');
        let indexes = {
            pending: indexPending,
            executing: indexExecuting,
            failing: indexFailing,
        };
        return new TaskFactory(layer, directory, config, indexes);
    }

    readonly indexPending: FEntityIndex;
    readonly indexExecuting: FEntityIndex;
    readonly indexFailing: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('taskType', src.taskType);
        validators.isString('taskType', src.taskType);
        validators.notNull('uid', src.uid);
        validators.isString('uid', src.uid);
        validators.notNull('arguments', src.arguments);
        validators.notNull('taskStatus', src.taskStatus);
        validators.isEnum('taskStatus', src.taskStatus, ['pending', 'executing', 'failing', 'failed', 'completed']);
        validators.isNumber('taskFailureCount', src.taskFailureCount);
        validators.isNumber('taskFailureTime', src.taskFailureTime);
        validators.isString('taskLockSeed', src.taskLockSeed);
        validators.isNumber('taskLockTimeout', src.taskLockTimeout);
        validators.isString('taskFailureMessage', src.taskFailureMessage);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { pending: FEntityIndex, executing: FEntityIndex, failing: FEntityIndex }) {
        super('Task', 'task', config, [indexes.pending, indexes.executing, indexes.failing], layer, directory);
        this.indexPending = indexes.pending;
        this.indexExecuting = indexes.executing;
        this.indexFailing = indexes.failing;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'taskType': rawId[0], 'uid': rawId[1] };
    }
    async findById(ctx: Context, taskType: string, uid: string) {
        return await this._findById(ctx, [taskType, uid]);
    }
    async create(ctx: Context, taskType: string, uid: string, shape: TaskShape) {
        return await this._create(ctx, [taskType, uid], { taskType, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, taskType: string, uid: string, shape: TaskShape) {
        return await this._create_UNSAFE(ctx, [taskType, uid], { taskType, uid, ...shape });
    }
    watch(ctx: Context, taskType: string, uid: string) {
        return this._watch(ctx, [taskType, uid]);
    }
    async allFromPendingAfter(ctx: Context, taskType: string, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPending.directory, [taskType], after);
    }
    async rangeFromPendingAfter(ctx: Context, taskType: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPending.directory, [taskType], after, limit, reversed);
    }
    async rangeFromPending(ctx: Context, taskType: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPending.directory, [taskType], limit, reversed);
    }
    async rangeFromPendingWithCursor(ctx: Context, taskType: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPending.directory, [taskType], limit, after, reversed);
    }
    async allFromPending(ctx: Context, taskType: string) {
        return await this._findAll(ctx, this.indexPending.directory, [taskType]);
    }
    createPendingStream(taskType: string, limit: number, after?: string) {
        return this._createStream(this.indexPending.directory, [taskType], limit, after); 
    }
    async rangeFromExecuting(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexExecuting.directory, [], limit, reversed);
    }
    async rangeFromExecutingWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexExecuting.directory, [], limit, after, reversed);
    }
    async allFromExecuting(ctx: Context, ) {
        return await this._findAll(ctx, this.indexExecuting.directory, []);
    }
    createExecutingStream(limit: number, after?: string) {
        return this._createStream(this.indexExecuting.directory, [], limit, after); 
    }
    async rangeFromFailing(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexFailing.directory, [], limit, reversed);
    }
    async rangeFromFailingWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexFailing.directory, [], limit, after, reversed);
    }
    async allFromFailing(ctx: Context, ) {
        return await this._findAll(ctx, this.indexFailing.directory, []);
    }
    createFailingStream(limit: number, after?: string) {
        return this._createStream(this.indexFailing.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Task(ctx, this.layer, this.directory, [value.taskType, value.uid], value, this.options, isNew, this.indexes, 'Task');
    }
}
export interface DelayedTaskShape {
    delay: number;
    arguments: any;
    result?: any| null;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureTime?: number| null;
    taskFailureMessage?: string| null;
}

export class DelayedTask extends FEntity {
    readonly entityName: 'DelayedTask' = 'DelayedTask';
    get taskType(): string { return this._value.taskType; }
    get uid(): string { return this._value.uid; }
    get delay(): number {
        return this._value.delay;
    }
    set delay(value: number) {
        this._checkIsWritable();
        if (value === this._value.delay) { return; }
        this._value.delay = value;
        this.markDirty();
    }
    get arguments(): any {
        return this._value.arguments;
    }
    set arguments(value: any) {
        this._checkIsWritable();
        if (value === this._value.arguments) { return; }
        this._value.arguments = value;
        this.markDirty();
    }
    get result(): any | null {
        let res = this._value.result;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set result(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.result) { return; }
        this._value.result = value;
        this.markDirty();
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' {
        return this._value.taskStatus;
    }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.taskStatus) { return; }
        this._value.taskStatus = value;
        this.markDirty();
    }
    get taskFailureTime(): number | null {
        let res = this._value.taskFailureTime;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureTime(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureTime) { return; }
        this._value.taskFailureTime = value;
        this.markDirty();
    }
    get taskFailureMessage(): string | null {
        let res = this._value.taskFailureMessage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set taskFailureMessage(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureMessage) { return; }
        this._value.taskFailureMessage = value;
        this.markDirty();
    }
}

export class DelayedTaskFactory extends FEntityFactory<DelayedTask> {
    static schema: FEntitySchema = {
        name: 'DelayedTask',
        editable: false,
        primaryKeys: [
            { name: 'taskType', type: 'string' },
            { name: 'uid', type: 'string' },
        ],
        fields: [
            { name: 'delay', type: 'number' },
            { name: 'arguments', type: 'json' },
            { name: 'result', type: 'json' },
            { name: 'taskStatus', type: 'enum', enumValues: ['pending', 'executing', 'failing', 'failed', 'completed'] },
            { name: 'taskFailureTime', type: 'number' },
            { name: 'taskFailureMessage', type: 'string' },
        ],
        indexes: [
            { name: 'pending', type: 'range', fields: ['taskType', 'delay'], displayName: 'tasksPending' },
            { name: 'executing', type: 'range', fields: ['taskLockTimeout'], displayName: 'tasksExecuting' },
            { name: 'failing', type: 'range', fields: ['taskFailureTime'], displayName: 'tasksFailing' },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('delayedTask');
        let config = { enableVersioning: true, enableTimestamps: true, validator: DelayedTaskFactory.validate, hasLiveStreams: false };
        let indexPending = new FEntityIndex(await layer.resolveEntityIndexDirectory('delayedTask', 'pending'), 'pending', ['taskType', 'delay'], false, (src) => src.taskStatus === 'pending');
        let indexExecuting = new FEntityIndex(await layer.resolveEntityIndexDirectory('delayedTask', 'executing'), 'executing', ['taskLockTimeout'], false, (src) => src.taskStatus === 'executing');
        let indexFailing = new FEntityIndex(await layer.resolveEntityIndexDirectory('delayedTask', 'failing'), 'failing', ['taskFailureTime'], false, (src) => src.taskStatus === 'failing');
        let indexes = {
            pending: indexPending,
            executing: indexExecuting,
            failing: indexFailing,
        };
        return new DelayedTaskFactory(layer, directory, config, indexes);
    }

    readonly indexPending: FEntityIndex;
    readonly indexExecuting: FEntityIndex;
    readonly indexFailing: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('taskType', src.taskType);
        validators.isString('taskType', src.taskType);
        validators.notNull('uid', src.uid);
        validators.isString('uid', src.uid);
        validators.notNull('delay', src.delay);
        validators.isNumber('delay', src.delay);
        validators.notNull('arguments', src.arguments);
        validators.notNull('taskStatus', src.taskStatus);
        validators.isEnum('taskStatus', src.taskStatus, ['pending', 'executing', 'failing', 'failed', 'completed']);
        validators.isNumber('taskFailureTime', src.taskFailureTime);
        validators.isString('taskFailureMessage', src.taskFailureMessage);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { pending: FEntityIndex, executing: FEntityIndex, failing: FEntityIndex }) {
        super('DelayedTask', 'delayedTask', config, [indexes.pending, indexes.executing, indexes.failing], layer, directory);
        this.indexPending = indexes.pending;
        this.indexExecuting = indexes.executing;
        this.indexFailing = indexes.failing;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'taskType': rawId[0], 'uid': rawId[1] };
    }
    async findById(ctx: Context, taskType: string, uid: string) {
        return await this._findById(ctx, [taskType, uid]);
    }
    async create(ctx: Context, taskType: string, uid: string, shape: DelayedTaskShape) {
        return await this._create(ctx, [taskType, uid], { taskType, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, taskType: string, uid: string, shape: DelayedTaskShape) {
        return await this._create_UNSAFE(ctx, [taskType, uid], { taskType, uid, ...shape });
    }
    watch(ctx: Context, taskType: string, uid: string) {
        return this._watch(ctx, [taskType, uid]);
    }
    async allFromPendingAfter(ctx: Context, taskType: string, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPending.directory, [taskType], after);
    }
    async rangeFromPendingAfter(ctx: Context, taskType: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPending.directory, [taskType], after, limit, reversed);
    }
    async rangeFromPending(ctx: Context, taskType: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPending.directory, [taskType], limit, reversed);
    }
    async rangeFromPendingWithCursor(ctx: Context, taskType: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPending.directory, [taskType], limit, after, reversed);
    }
    async allFromPending(ctx: Context, taskType: string) {
        return await this._findAll(ctx, this.indexPending.directory, [taskType]);
    }
    createPendingStream(taskType: string, limit: number, after?: string) {
        return this._createStream(this.indexPending.directory, [taskType], limit, after); 
    }
    async rangeFromExecuting(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexExecuting.directory, [], limit, reversed);
    }
    async rangeFromExecutingWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexExecuting.directory, [], limit, after, reversed);
    }
    async allFromExecuting(ctx: Context, ) {
        return await this._findAll(ctx, this.indexExecuting.directory, []);
    }
    createExecutingStream(limit: number, after?: string) {
        return this._createStream(this.indexExecuting.directory, [], limit, after); 
    }
    async rangeFromFailing(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexFailing.directory, [], limit, reversed);
    }
    async rangeFromFailingWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexFailing.directory, [], limit, after, reversed);
    }
    async allFromFailing(ctx: Context, ) {
        return await this._findAll(ctx, this.indexFailing.directory, []);
    }
    createFailingStream(limit: number, after?: string) {
        return this._createStream(this.indexFailing.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new DelayedTask(ctx, this.layer, this.directory, [value.taskType, value.uid], value, this.options, isNew, this.indexes, 'DelayedTask');
    }
}
export interface PushFirebaseShape {
    uid: number;
    tid: string;
    token: string;
    packageId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushFirebase extends FEntity {
    readonly entityName: 'PushFirebase' = 'PushFirebase';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get token(): string {
        return this._value.token;
    }
    set token(value: string) {
        this._checkIsWritable();
        if (value === this._value.token) { return; }
        this._value.token = value;
        this.markDirty();
    }
    get packageId(): string {
        return this._value.packageId;
    }
    set packageId(value: string) {
        this._checkIsWritable();
        if (value === this._value.packageId) { return; }
        this._value.packageId = value;
        this.markDirty();
    }
    get sandbox(): boolean {
        return this._value.sandbox;
    }
    set sandbox(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.sandbox) { return; }
        this._value.sandbox = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushFirebaseFactory extends FEntityFactory<PushFirebase> {
    static schema: FEntitySchema = {
        name: 'PushFirebase',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'token', type: 'string', secure: true },
            { name: 'packageId', type: 'string' },
            { name: 'sandbox', type: 'boolean' },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'token', type: 'unique', fields: ['token'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('pushFirebase');
        let config = { enableVersioning: true, enableTimestamps: true, validator: PushFirebaseFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushFirebase', 'user'), 'user', ['uid', 'id'], false);
        let indexToken = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushFirebase', 'token'), 'token', ['token'], true, src => src.enabled);
        let indexes = {
            user: indexUser,
            token: indexToken,
        };
        return new PushFirebaseFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexToken: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('token', src.token);
        validators.isString('token', src.token);
        validators.notNull('packageId', src.packageId);
        validators.isString('packageId', src.packageId);
        validators.notNull('sandbox', src.sandbox);
        validators.isBoolean('sandbox', src.sandbox);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, token: FEntityIndex }) {
        super('PushFirebase', 'pushFirebase', config, [indexes.user, indexes.token], layer, directory);
        this.indexUser = indexes.user;
        this.indexToken = indexes.token;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: PushFirebaseShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: PushFirebaseShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    async findFromToken(ctx: Context, token: string) {
        return await this._findFromIndex(ctx, this.indexToken.directory, [token]);
    }
    async rangeFromToken(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexToken.directory, [], limit, reversed);
    }
    async rangeFromTokenWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexToken.directory, [], limit, after, reversed);
    }
    async allFromToken(ctx: Context, ) {
        return await this._findAll(ctx, this.indexToken.directory, []);
    }
    createTokenStream(limit: number, after?: string) {
        return this._createStream(this.indexToken.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new PushFirebase(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushFirebase');
    }
}
export interface PushAppleShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    sandbox: boolean;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushApple extends FEntity {
    readonly entityName: 'PushApple' = 'PushApple';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get token(): string {
        return this._value.token;
    }
    set token(value: string) {
        this._checkIsWritable();
        if (value === this._value.token) { return; }
        this._value.token = value;
        this.markDirty();
    }
    get bundleId(): string {
        return this._value.bundleId;
    }
    set bundleId(value: string) {
        this._checkIsWritable();
        if (value === this._value.bundleId) { return; }
        this._value.bundleId = value;
        this.markDirty();
    }
    get sandbox(): boolean {
        return this._value.sandbox;
    }
    set sandbox(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.sandbox) { return; }
        this._value.sandbox = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushAppleFactory extends FEntityFactory<PushApple> {
    static schema: FEntitySchema = {
        name: 'PushApple',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'token', type: 'string', secure: true },
            { name: 'bundleId', type: 'string' },
            { name: 'sandbox', type: 'boolean' },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'token', type: 'unique', fields: ['token'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('pushApple');
        let config = { enableVersioning: true, enableTimestamps: true, validator: PushAppleFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushApple', 'user'), 'user', ['uid', 'id'], false);
        let indexToken = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushApple', 'token'), 'token', ['token'], true, src => src.enabled);
        let indexes = {
            user: indexUser,
            token: indexToken,
        };
        return new PushAppleFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexToken: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('token', src.token);
        validators.isString('token', src.token);
        validators.notNull('bundleId', src.bundleId);
        validators.isString('bundleId', src.bundleId);
        validators.notNull('sandbox', src.sandbox);
        validators.isBoolean('sandbox', src.sandbox);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, token: FEntityIndex }) {
        super('PushApple', 'pushApple', config, [indexes.user, indexes.token], layer, directory);
        this.indexUser = indexes.user;
        this.indexToken = indexes.token;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: PushAppleShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: PushAppleShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    async findFromToken(ctx: Context, token: string) {
        return await this._findFromIndex(ctx, this.indexToken.directory, [token]);
    }
    async rangeFromToken(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexToken.directory, [], limit, reversed);
    }
    async rangeFromTokenWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexToken.directory, [], limit, after, reversed);
    }
    async allFromToken(ctx: Context, ) {
        return await this._findAll(ctx, this.indexToken.directory, []);
    }
    createTokenStream(limit: number, after?: string) {
        return this._createStream(this.indexToken.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new PushApple(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushApple');
    }
}
export interface PushWebShape {
    uid: number;
    tid: string;
    endpoint: string;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushWeb extends FEntity {
    readonly entityName: 'PushWeb' = 'PushWeb';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get endpoint(): string {
        return this._value.endpoint;
    }
    set endpoint(value: string) {
        this._checkIsWritable();
        if (value === this._value.endpoint) { return; }
        this._value.endpoint = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushWebFactory extends FEntityFactory<PushWeb> {
    static schema: FEntitySchema = {
        name: 'PushWeb',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'endpoint', type: 'string', secure: true },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'endpoint', type: 'unique', fields: ['endpoint'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('pushWeb');
        let config = { enableVersioning: true, enableTimestamps: true, validator: PushWebFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushWeb', 'user'), 'user', ['uid', 'id'], false);
        let indexEndpoint = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushWeb', 'endpoint'), 'endpoint', ['endpoint'], true, src => src.enabled);
        let indexes = {
            user: indexUser,
            endpoint: indexEndpoint,
        };
        return new PushWebFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexEndpoint: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('endpoint', src.endpoint);
        validators.isString('endpoint', src.endpoint);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, endpoint: FEntityIndex }) {
        super('PushWeb', 'pushWeb', config, [indexes.user, indexes.endpoint], layer, directory);
        this.indexUser = indexes.user;
        this.indexEndpoint = indexes.endpoint;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: PushWebShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: PushWebShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    async findFromEndpoint(ctx: Context, endpoint: string) {
        return await this._findFromIndex(ctx, this.indexEndpoint.directory, [endpoint]);
    }
    async rangeFromEndpoint(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexEndpoint.directory, [], limit, reversed);
    }
    async rangeFromEndpointWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexEndpoint.directory, [], limit, after, reversed);
    }
    async allFromEndpoint(ctx: Context, ) {
        return await this._findAll(ctx, this.indexEndpoint.directory, []);
    }
    createEndpointStream(limit: number, after?: string) {
        return this._createStream(this.indexEndpoint.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new PushWeb(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushWeb');
    }
}
export interface PushSafariShape {
    uid: number;
    tid: string;
    token: string;
    bundleId: string;
    enabled: boolean;
    failures?: number| null;
    failedFirstAt?: number| null;
    failedLastAt?: number| null;
    disabledAt?: number| null;
}

export class PushSafari extends FEntity {
    readonly entityName: 'PushSafari' = 'PushSafari';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get token(): string {
        return this._value.token;
    }
    set token(value: string) {
        this._checkIsWritable();
        if (value === this._value.token) { return; }
        this._value.token = value;
        this.markDirty();
    }
    get bundleId(): string {
        return this._value.bundleId;
    }
    set bundleId(value: string) {
        this._checkIsWritable();
        if (value === this._value.bundleId) { return; }
        this._value.bundleId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get failures(): number | null {
        let res = this._value.failures;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failures(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failures) { return; }
        this._value.failures = value;
        this.markDirty();
    }
    get failedFirstAt(): number | null {
        let res = this._value.failedFirstAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedFirstAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedFirstAt) { return; }
        this._value.failedFirstAt = value;
        this.markDirty();
    }
    get failedLastAt(): number | null {
        let res = this._value.failedLastAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set failedLastAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.failedLastAt) { return; }
        this._value.failedLastAt = value;
        this.markDirty();
    }
    get disabledAt(): number | null {
        let res = this._value.disabledAt;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disabledAt(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.disabledAt) { return; }
        this._value.disabledAt = value;
        this.markDirty();
    }
}

export class PushSafariFactory extends FEntityFactory<PushSafari> {
    static schema: FEntitySchema = {
        name: 'PushSafari',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'token', type: 'string', secure: true },
            { name: 'bundleId', type: 'string' },
            { name: 'enabled', type: 'boolean' },
            { name: 'failures', type: 'number' },
            { name: 'failedFirstAt', type: 'number' },
            { name: 'failedLastAt', type: 'number' },
            { name: 'disabledAt', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'id'] },
            { name: 'token', type: 'unique', fields: ['token'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('pushSafari');
        let config = { enableVersioning: true, enableTimestamps: true, validator: PushSafariFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushSafari', 'user'), 'user', ['uid', 'id'], false);
        let indexToken = new FEntityIndex(await layer.resolveEntityIndexDirectory('pushSafari', 'token'), 'token', ['token'], true, src => src.enabled);
        let indexes = {
            user: indexUser,
            token: indexToken,
        };
        return new PushSafariFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexToken: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('token', src.token);
        validators.isString('token', src.token);
        validators.notNull('bundleId', src.bundleId);
        validators.isString('bundleId', src.bundleId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.isNumber('failures', src.failures);
        validators.isNumber('failedFirstAt', src.failedFirstAt);
        validators.isNumber('failedLastAt', src.failedLastAt);
        validators.isNumber('disabledAt', src.disabledAt);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, token: FEntityIndex }) {
        super('PushSafari', 'pushSafari', config, [indexes.user, indexes.token], layer, directory);
        this.indexUser = indexes.user;
        this.indexToken = indexes.token;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: PushSafariShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: PushSafariShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    async findFromToken(ctx: Context, token: string) {
        return await this._findFromIndex(ctx, this.indexToken.directory, [token]);
    }
    async rangeFromToken(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexToken.directory, [], limit, reversed);
    }
    async rangeFromTokenWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexToken.directory, [], limit, after, reversed);
    }
    async allFromToken(ctx: Context, ) {
        return await this._findAll(ctx, this.indexToken.directory, []);
    }
    createTokenStream(limit: number, after?: string) {
        return this._createStream(this.indexToken.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new PushSafari(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'PushSafari');
    }
}
export interface UserProfilePrefilShape {
    firstName?: string| null;
    lastName?: string| null;
    picture?: string| null;
}

export class UserProfilePrefil extends FEntity {
    readonly entityName: 'UserProfilePrefil' = 'UserProfilePrefil';
    get id(): number { return this._value.id; }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get picture(): string | null {
        let res = this._value.picture;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set picture(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.picture) { return; }
        this._value.picture = value;
        this.markDirty();
    }
}

export class UserProfilePrefilFactory extends FEntityFactory<UserProfilePrefil> {
    static schema: FEntitySchema = {
        name: 'UserProfilePrefil',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'picture', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userProfilePrefil');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserProfilePrefilFactory.validate, hasLiveStreams: false };
        return new UserProfilePrefilFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('picture', src.picture);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserProfilePrefil', 'userProfilePrefil', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserProfilePrefilShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserProfilePrefilShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserProfilePrefil(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserProfilePrefil');
    }
}
export interface UserShape {
    authId: string;
    email: string;
    isBot: boolean;
    invitedBy?: number| null;
    botOwner?: number| null;
    isSuperBot?: boolean| null;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
}

export class User extends FEntity {
    readonly entityName: 'User' = 'User';
    get id(): number { return this._value.id; }
    get authId(): string {
        return this._value.authId;
    }
    set authId(value: string) {
        this._checkIsWritable();
        if (value === this._value.authId) { return; }
        this._value.authId = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get isBot(): boolean {
        return this._value.isBot;
    }
    set isBot(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isBot) { return; }
        this._value.isBot = value;
        this.markDirty();
    }
    get invitedBy(): number | null {
        let res = this._value.invitedBy;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set invitedBy(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get botOwner(): number | null {
        let res = this._value.botOwner;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set botOwner(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.botOwner) { return; }
        this._value.botOwner = value;
        this.markDirty();
    }
    get isSuperBot(): boolean | null {
        let res = this._value.isSuperBot;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set isSuperBot(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.isSuperBot) { return; }
        this._value.isSuperBot = value;
        this.markDirty();
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' {
        return this._value.status;
    }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class UserFactory extends FEntityFactory<User> {
    static schema: FEntitySchema = {
        name: 'User',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'authId', type: 'string' },
            { name: 'email', type: 'string' },
            { name: 'isBot', type: 'boolean' },
            { name: 'invitedBy', type: 'number' },
            { name: 'botOwner', type: 'number' },
            { name: 'isSuperBot', type: 'boolean' },
            { name: 'status', type: 'enum', enumValues: ['pending', 'activated', 'suspended', 'deleted'] },
        ],
        indexes: [
            { name: 'authId', type: 'unique', fields: ['authId'] },
            { name: 'email', type: 'unique', fields: ['email'] },
            { name: 'owner', type: 'range', fields: ['botOwner', 'id'] },
            { name: 'superBots', type: 'range', fields: [] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('user');
        let config = { enableVersioning: false, enableTimestamps: false, validator: UserFactory.validate, hasLiveStreams: false };
        let indexAuthId = new FEntityIndex(await layer.resolveEntityIndexDirectory('user', 'authId'), 'authId', ['authId'], true, src => src.status !== 'deleted');
        let indexEmail = new FEntityIndex(await layer.resolveEntityIndexDirectory('user', 'email'), 'email', ['email'], true, src => src.status !== 'deleted');
        let indexOwner = new FEntityIndex(await layer.resolveEntityIndexDirectory('user', 'owner'), 'owner', ['botOwner', 'id'], false, src => src.botOwner);
        let indexSuperBots = new FEntityIndex(await layer.resolveEntityIndexDirectory('user', 'superBots'), 'superBots', [], false, src => src.isBot === true && src.isSuperBot);
        let indexes = {
            authId: indexAuthId,
            email: indexEmail,
            owner: indexOwner,
            superBots: indexSuperBots,
        };
        return new UserFactory(layer, directory, config, indexes);
    }

    readonly indexAuthId: FEntityIndex;
    readonly indexEmail: FEntityIndex;
    readonly indexOwner: FEntityIndex;
    readonly indexSuperBots: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('authId', src.authId);
        validators.isString('authId', src.authId);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.notNull('isBot', src.isBot);
        validators.isBoolean('isBot', src.isBot);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.isNumber('botOwner', src.botOwner);
        validators.isBoolean('isSuperBot', src.isSuperBot);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['pending', 'activated', 'suspended', 'deleted']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { authId: FEntityIndex, email: FEntityIndex, owner: FEntityIndex, superBots: FEntityIndex }) {
        super('User', 'user', config, [indexes.authId, indexes.email, indexes.owner, indexes.superBots], layer, directory);
        this.indexAuthId = indexes.authId;
        this.indexEmail = indexes.email;
        this.indexOwner = indexes.owner;
        this.indexSuperBots = indexes.superBots;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromAuthId(ctx: Context, authId: string) {
        return await this._findFromIndex(ctx, this.indexAuthId.directory, [authId]);
    }
    async rangeFromAuthId(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexAuthId.directory, [], limit, reversed);
    }
    async rangeFromAuthIdWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexAuthId.directory, [], limit, after, reversed);
    }
    async allFromAuthId(ctx: Context, ) {
        return await this._findAll(ctx, this.indexAuthId.directory, []);
    }
    createAuthIdStream(limit: number, after?: string) {
        return this._createStream(this.indexAuthId.directory, [], limit, after); 
    }
    async findFromEmail(ctx: Context, email: string) {
        return await this._findFromIndex(ctx, this.indexEmail.directory, [email]);
    }
    async rangeFromEmail(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexEmail.directory, [], limit, reversed);
    }
    async rangeFromEmailWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexEmail.directory, [], limit, after, reversed);
    }
    async allFromEmail(ctx: Context, ) {
        return await this._findAll(ctx, this.indexEmail.directory, []);
    }
    createEmailStream(limit: number, after?: string) {
        return this._createStream(this.indexEmail.directory, [], limit, after); 
    }
    async allFromOwnerAfter(ctx: Context, botOwner: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexOwner.directory, [botOwner], after);
    }
    async rangeFromOwnerAfter(ctx: Context, botOwner: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexOwner.directory, [botOwner], after, limit, reversed);
    }
    async rangeFromOwner(ctx: Context, botOwner: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOwner.directory, [botOwner], limit, reversed);
    }
    async rangeFromOwnerWithCursor(ctx: Context, botOwner: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOwner.directory, [botOwner], limit, after, reversed);
    }
    async allFromOwner(ctx: Context, botOwner: number) {
        return await this._findAll(ctx, this.indexOwner.directory, [botOwner]);
    }
    createOwnerStream(botOwner: number, limit: number, after?: string) {
        return this._createStream(this.indexOwner.directory, [botOwner], limit, after); 
    }
    async rangeFromSuperBots(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexSuperBots.directory, [], limit, reversed);
    }
    async rangeFromSuperBotsWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexSuperBots.directory, [], limit, after, reversed);
    }
    async allFromSuperBots(ctx: Context, ) {
        return await this._findAll(ctx, this.indexSuperBots.directory, []);
    }
    createSuperBotsStream(limit: number, after?: string) {
        return this._createStream(this.indexSuperBots.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new User(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'User');
    }
}
export interface UserProfileShape {
    firstName: string;
    lastName?: string| null;
    phone?: string| null;
    about?: string| null;
    website?: string| null;
    location?: string| null;
    email?: string| null;
    picture?: any| null;
    linkedin?: string| null;
    twitter?: string| null;
    locations?: any| null;
    primaryOrganization?: number| null;
    role?: string| null;
}

export class UserProfile extends FEntity {
    readonly entityName: 'UserProfile' = 'UserProfile';
    get id(): number { return this._value.id; }
    get firstName(): string {
        return this._value.firstName;
    }
    set firstName(value: string) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get phone(): string | null {
        let res = this._value.phone;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set phone(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.phone) { return; }
        this._value.phone = value;
        this.markDirty();
    }
    get about(): string | null {
        let res = this._value.about;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set about(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.about) { return; }
        this._value.about = value;
        this.markDirty();
    }
    get website(): string | null {
        let res = this._value.website;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set website(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.website) { return; }
        this._value.website = value;
        this.markDirty();
    }
    get location(): string | null {
        let res = this._value.location;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set location(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.location) { return; }
        this._value.location = value;
        this.markDirty();
    }
    get email(): string | null {
        let res = this._value.email;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set email(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get picture(): any | null {
        let res = this._value.picture;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set picture(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.picture) { return; }
        this._value.picture = value;
        this.markDirty();
    }
    get linkedin(): string | null {
        let res = this._value.linkedin;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set linkedin(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.linkedin) { return; }
        this._value.linkedin = value;
        this.markDirty();
    }
    get twitter(): string | null {
        let res = this._value.twitter;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set twitter(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.twitter) { return; }
        this._value.twitter = value;
        this.markDirty();
    }
    get locations(): any | null {
        let res = this._value.locations;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set locations(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.locations) { return; }
        this._value.locations = value;
        this.markDirty();
    }
    get primaryOrganization(): number | null {
        let res = this._value.primaryOrganization;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set primaryOrganization(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.primaryOrganization) { return; }
        this._value.primaryOrganization = value;
        this.markDirty();
    }
    get role(): string | null {
        let res = this._value.role;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set role(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
}

export class UserProfileFactory extends FEntityFactory<UserProfile> {
    static schema: FEntitySchema = {
        name: 'UserProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'phone', type: 'string' },
            { name: 'about', type: 'string' },
            { name: 'website', type: 'string' },
            { name: 'location', type: 'string' },
            { name: 'email', type: 'string' },
            { name: 'picture', type: 'json' },
            { name: 'linkedin', type: 'string' },
            { name: 'twitter', type: 'string' },
            { name: 'locations', type: 'json' },
            { name: 'primaryOrganization', type: 'number' },
            { name: 'role', type: 'string' },
        ],
        indexes: [
            { name: 'byUpdatedAt', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userProfile');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserProfileFactory.validate, hasLiveStreams: false };
        let indexByUpdatedAt = new FEntityIndex(await layer.resolveEntityIndexDirectory('userProfile', 'byUpdatedAt'), 'byUpdatedAt', ['updatedAt'], false);
        let indexes = {
            byUpdatedAt: indexByUpdatedAt,
        };
        return new UserProfileFactory(layer, directory, config, indexes);
    }

    readonly indexByUpdatedAt: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('firstName', src.firstName);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('phone', src.phone);
        validators.isString('about', src.about);
        validators.isString('website', src.website);
        validators.isString('location', src.location);
        validators.isString('email', src.email);
        validators.isString('linkedin', src.linkedin);
        validators.isString('twitter', src.twitter);
        validators.isNumber('primaryOrganization', src.primaryOrganization);
        validators.isString('role', src.role);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { byUpdatedAt: FEntityIndex }) {
        super('UserProfile', 'userProfile', config, [indexes.byUpdatedAt], layer, directory);
        this.indexByUpdatedAt = indexes.byUpdatedAt;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserProfileShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserProfileShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromByUpdatedAt(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexByUpdatedAt.directory, [], limit, reversed);
    }
    async rangeFromByUpdatedAtWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexByUpdatedAt.directory, [], limit, after, reversed);
    }
    async allFromByUpdatedAt(ctx: Context, ) {
        return await this._findAll(ctx, this.indexByUpdatedAt.directory, []);
    }
    createByUpdatedAtStream(limit: number, after?: string) {
        return this._createStream(this.indexByUpdatedAt.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserProfile(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserProfile');
    }
}
export interface UserIndexingQueueShape {
}

export class UserIndexingQueue extends FEntity {
    readonly entityName: 'UserIndexingQueue' = 'UserIndexingQueue';
    get id(): number { return this._value.id; }
}

export class UserIndexingQueueFactory extends FEntityFactory<UserIndexingQueue> {
    static schema: FEntitySchema = {
        name: 'UserIndexingQueue',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
        ],
        indexes: [
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userIndexingQueue');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserIndexingQueueFactory.validate, hasLiveStreams: false };
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('userIndexingQueue', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            updated: indexUpdated,
        };
        return new UserIndexingQueueFactory(layer, directory, config, indexes);
    }

    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { updated: FEntityIndex }) {
        super('UserIndexingQueue', 'userIndexingQueue', config, [indexes.updated], layer, directory);
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserIndexingQueueShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserIndexingQueueShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserIndexingQueue(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserIndexingQueue');
    }
}
export interface OrganizationShape {
    ownerId: number;
    status: 'pending' | 'activated' | 'suspended' | 'deleted';
    kind: 'organization' | 'community';
    editorial: boolean;
    private?: boolean| null;
}

export class Organization extends FEntity {
    readonly entityName: 'Organization' = 'Organization';
    get id(): number { return this._value.id; }
    get ownerId(): number {
        return this._value.ownerId;
    }
    set ownerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get status(): 'pending' | 'activated' | 'suspended' | 'deleted' {
        return this._value.status;
    }
    set status(value: 'pending' | 'activated' | 'suspended' | 'deleted') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
    get kind(): 'organization' | 'community' {
        return this._value.kind;
    }
    set kind(value: 'organization' | 'community') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get editorial(): boolean {
        return this._value.editorial;
    }
    set editorial(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.editorial) { return; }
        this._value.editorial = value;
        this.markDirty();
    }
    get private(): boolean | null {
        let res = this._value.private;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set private(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.private) { return; }
        this._value.private = value;
        this.markDirty();
    }
}

export class OrganizationFactory extends FEntityFactory<Organization> {
    static schema: FEntitySchema = {
        name: 'Organization',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'ownerId', type: 'number' },
            { name: 'status', type: 'enum', enumValues: ['pending', 'activated', 'suspended', 'deleted'] },
            { name: 'kind', type: 'enum', enumValues: ['organization', 'community'] },
            { name: 'editorial', type: 'boolean' },
            { name: 'private', type: 'boolean' },
        ],
        indexes: [
            { name: 'community', type: 'range', fields: [] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organization');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationFactory.validate, hasLiveStreams: false };
        let indexCommunity = new FEntityIndex(await layer.resolveEntityIndexDirectory('organization', 'community'), 'community', [], false, (src) => src.kind === 'community' && src.status === 'activated');
        let indexes = {
            community: indexCommunity,
        };
        return new OrganizationFactory(layer, directory, config, indexes);
    }

    readonly indexCommunity: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('ownerId', src.ownerId);
        validators.isNumber('ownerId', src.ownerId);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['pending', 'activated', 'suspended', 'deleted']);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['organization', 'community']);
        validators.notNull('editorial', src.editorial);
        validators.isBoolean('editorial', src.editorial);
        validators.isBoolean('private', src.private);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { community: FEntityIndex }) {
        super('Organization', 'organization', config, [indexes.community], layer, directory);
        this.indexCommunity = indexes.community;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: OrganizationShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: OrganizationShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromCommunity(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexCommunity.directory, [], limit, reversed);
    }
    async rangeFromCommunityWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexCommunity.directory, [], limit, after, reversed);
    }
    async allFromCommunity(ctx: Context, ) {
        return await this._findAll(ctx, this.indexCommunity.directory, []);
    }
    createCommunityStream(limit: number, after?: string) {
        return this._createStream(this.indexCommunity.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Organization(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Organization');
    }
}
export interface OrganizationProfileShape {
    name: string;
    photo?: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, }| null;
    about?: string| null;
    twitter?: string| null;
    facebook?: string| null;
    linkedin?: string| null;
    website?: string| null;
    joinedMembersCount?: number| null;
}

export class OrganizationProfile extends FEntity {
    readonly entityName: 'OrganizationProfile' = 'OrganizationProfile';
    get id(): number { return this._value.id; }
    get name(): string {
        return this._value.name;
    }
    set name(value: string) {
        this._checkIsWritable();
        if (value === this._value.name) { return; }
        this._value.name = value;
        this.markDirty();
    }
    get photo(): { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null {
        let res = this._value.photo;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set photo(value: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null) {
        this._checkIsWritable();
        if (value === this._value.photo) { return; }
        this._value.photo = value;
        this.markDirty();
    }
    get about(): string | null {
        let res = this._value.about;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set about(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.about) { return; }
        this._value.about = value;
        this.markDirty();
    }
    get twitter(): string | null {
        let res = this._value.twitter;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set twitter(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.twitter) { return; }
        this._value.twitter = value;
        this.markDirty();
    }
    get facebook(): string | null {
        let res = this._value.facebook;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set facebook(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.facebook) { return; }
        this._value.facebook = value;
        this.markDirty();
    }
    get linkedin(): string | null {
        let res = this._value.linkedin;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set linkedin(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.linkedin) { return; }
        this._value.linkedin = value;
        this.markDirty();
    }
    get website(): string | null {
        let res = this._value.website;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set website(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.website) { return; }
        this._value.website = value;
        this.markDirty();
    }
    get joinedMembersCount(): number | null {
        let res = this._value.joinedMembersCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set joinedMembersCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.joinedMembersCount) { return; }
        this._value.joinedMembersCount = value;
        this.markDirty();
    }
}

export class OrganizationProfileFactory extends FEntityFactory<OrganizationProfile> {
    static schema: FEntitySchema = {
        name: 'OrganizationProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'name', type: 'string' },
            { name: 'photo', type: 'json' },
            { name: 'about', type: 'string' },
            { name: 'twitter', type: 'string' },
            { name: 'facebook', type: 'string' },
            { name: 'linkedin', type: 'string' },
            { name: 'website', type: 'string' },
            { name: 'joinedMembersCount', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationProfile');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationProfileFactory.validate, hasLiveStreams: false };
        return new OrganizationProfileFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('name', src.name);
        validators.isString('name', src.name);
        validators.isJson('photo', src.photo, json(() => {
            jField('uuid', jString());
            jField('crop', json(() => {
            jField('x', jNumber());
            jField('y', jNumber());
            jField('w', jNumber());
            jField('h', jNumber());
        })).nullable();
        }));
        validators.isString('about', src.about);
        validators.isString('twitter', src.twitter);
        validators.isString('facebook', src.facebook);
        validators.isString('linkedin', src.linkedin);
        validators.isString('website', src.website);
        validators.isNumber('joinedMembersCount', src.joinedMembersCount);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('OrganizationProfile', 'organizationProfile', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: OrganizationProfileShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: OrganizationProfileShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationProfile(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationProfile');
    }
}
export interface OrganizationEditorialShape {
    listed: boolean;
    featured: boolean;
}

export class OrganizationEditorial extends FEntity {
    readonly entityName: 'OrganizationEditorial' = 'OrganizationEditorial';
    get id(): number { return this._value.id; }
    get listed(): boolean {
        return this._value.listed;
    }
    set listed(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.listed) { return; }
        this._value.listed = value;
        this.markDirty();
    }
    get featured(): boolean {
        return this._value.featured;
    }
    set featured(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.featured) { return; }
        this._value.featured = value;
        this.markDirty();
    }
}

export class OrganizationEditorialFactory extends FEntityFactory<OrganizationEditorial> {
    static schema: FEntitySchema = {
        name: 'OrganizationEditorial',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'listed', type: 'boolean' },
            { name: 'featured', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationEditorial');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationEditorialFactory.validate, hasLiveStreams: false };
        return new OrganizationEditorialFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('listed', src.listed);
        validators.isBoolean('listed', src.listed);
        validators.notNull('featured', src.featured);
        validators.isBoolean('featured', src.featured);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('OrganizationEditorial', 'organizationEditorial', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: OrganizationEditorialShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: OrganizationEditorialShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationEditorial(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationEditorial');
    }
}
export interface OrganizationIndexingQueueShape {
}

export class OrganizationIndexingQueue extends FEntity {
    readonly entityName: 'OrganizationIndexingQueue' = 'OrganizationIndexingQueue';
    get id(): number { return this._value.id; }
}

export class OrganizationIndexingQueueFactory extends FEntityFactory<OrganizationIndexingQueue> {
    static schema: FEntitySchema = {
        name: 'OrganizationIndexingQueue',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
        ],
        indexes: [
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationIndexingQueue');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationIndexingQueueFactory.validate, hasLiveStreams: false };
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationIndexingQueue', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            updated: indexUpdated,
        };
        return new OrganizationIndexingQueueFactory(layer, directory, config, indexes);
    }

    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { updated: FEntityIndex }) {
        super('OrganizationIndexingQueue', 'organizationIndexingQueue', config, [indexes.updated], layer, directory);
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: OrganizationIndexingQueueShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: OrganizationIndexingQueueShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationIndexingQueue(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationIndexingQueue');
    }
}
export interface OrganizationMemberShape {
    invitedBy?: number| null;
    role: 'admin' | 'member';
    status: 'requested' | 'joined' | 'left';
}

export class OrganizationMember extends FEntity {
    readonly entityName: 'OrganizationMember' = 'OrganizationMember';
    get oid(): number { return this._value.oid; }
    get uid(): number { return this._value.uid; }
    get invitedBy(): number | null {
        let res = this._value.invitedBy;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set invitedBy(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get role(): 'admin' | 'member' {
        return this._value.role;
    }
    set role(value: 'admin' | 'member') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get status(): 'requested' | 'joined' | 'left' {
        return this._value.status;
    }
    set status(value: 'requested' | 'joined' | 'left') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class OrganizationMemberFactory extends FEntityFactory<OrganizationMember> {
    static schema: FEntitySchema = {
        name: 'OrganizationMember',
        editable: false,
        primaryKeys: [
            { name: 'oid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'invitedBy', type: 'number' },
            { name: 'role', type: 'enum', enumValues: ['admin', 'member'] },
            { name: 'status', type: 'enum', enumValues: ['requested', 'joined', 'left'] },
        ],
        indexes: [
            { name: 'ids', type: 'unique', fields: ['oid', 'uid'] },
            { name: 'organization', type: 'range', fields: ['status', 'oid', 'uid'], displayName: 'usersFromOrganization' },
            { name: 'user', type: 'range', fields: ['status', 'uid', 'oid'], displayName: 'organizationsFromUser' },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationMember');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationMemberFactory.validate, hasLiveStreams: false };
        let indexIds = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationMember', 'ids'), 'ids', ['oid', 'uid'], true);
        let indexOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationMember', 'organization'), 'organization', ['status', 'oid', 'uid'], false);
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationMember', 'user'), 'user', ['status', 'uid', 'oid'], false);
        let indexes = {
            ids: indexIds,
            organization: indexOrganization,
            user: indexUser,
        };
        return new OrganizationMemberFactory(layer, directory, config, indexes);
    }

    readonly indexIds: FEntityIndex;
    readonly indexOrganization: FEntityIndex;
    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['admin', 'member']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['requested', 'joined', 'left']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { ids: FEntityIndex, organization: FEntityIndex, user: FEntityIndex }) {
        super('OrganizationMember', 'organizationMember', config, [indexes.ids, indexes.organization, indexes.user], layer, directory);
        this.indexIds = indexes.ids;
        this.indexOrganization = indexes.organization;
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'oid': rawId[0], 'uid': rawId[1] };
    }
    async findById(ctx: Context, oid: number, uid: number) {
        return await this._findById(ctx, [oid, uid]);
    }
    async create(ctx: Context, oid: number, uid: number, shape: OrganizationMemberShape) {
        return await this._create(ctx, [oid, uid], { oid, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, oid: number, uid: number, shape: OrganizationMemberShape) {
        return await this._create_UNSAFE(ctx, [oid, uid], { oid, uid, ...shape });
    }
    watch(ctx: Context, oid: number, uid: number) {
        return this._watch(ctx, [oid, uid]);
    }
    async findFromIds(ctx: Context, oid: number, uid: number) {
        return await this._findFromIndex(ctx, this.indexIds.directory, [oid, uid]);
    }
    async allFromIdsAfter(ctx: Context, oid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexIds.directory, [oid], after);
    }
    async rangeFromIdsAfter(ctx: Context, oid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexIds.directory, [oid], after, limit, reversed);
    }
    async rangeFromIds(ctx: Context, oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexIds.directory, [oid], limit, reversed);
    }
    async rangeFromIdsWithCursor(ctx: Context, oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexIds.directory, [oid], limit, after, reversed);
    }
    async allFromIds(ctx: Context, oid: number) {
        return await this._findAll(ctx, this.indexIds.directory, [oid]);
    }
    createIdsStream(oid: number, limit: number, after?: string) {
        return this._createStream(this.indexIds.directory, [oid], limit, after); 
    }
    async allFromOrganizationAfter(ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexOrganization.directory, [status, oid], after);
    }
    async rangeFromOrganizationAfter(ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexOrganization.directory, [status, oid], after, limit, reversed);
    }
    async rangeFromOrganization(ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganization.directory, [status, oid], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(ctx: Context, status: 'requested' | 'joined' | 'left', oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganization.directory, [status, oid], limit, after, reversed);
    }
    async allFromOrganization(ctx: Context, status: 'requested' | 'joined' | 'left', oid: number) {
        return await this._findAll(ctx, this.indexOrganization.directory, [status, oid]);
    }
    createOrganizationStream(status: 'requested' | 'joined' | 'left', oid: number, limit: number, after?: string) {
        return this._createStream(this.indexOrganization.directory, [status, oid], limit, after); 
    }
    async allFromUserAfter(ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [status, uid], after);
    }
    async rangeFromUserAfter(ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [status, uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [status, uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, status: 'requested' | 'joined' | 'left', uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [status, uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, status: 'requested' | 'joined' | 'left', uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [status, uid]);
    }
    createUserStream(status: 'requested' | 'joined' | 'left', uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [status, uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationMember(ctx, this.layer, this.directory, [value.oid, value.uid], value, this.options, isNew, this.indexes, 'OrganizationMember');
    }
}
export interface FeatureFlagShape {
    title: string;
}

export class FeatureFlag extends FEntity {
    readonly entityName: 'FeatureFlag' = 'FeatureFlag';
    get key(): string { return this._value.key; }
    get title(): string {
        return this._value.title;
    }
    set title(value: string) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
}

export class FeatureFlagFactory extends FEntityFactory<FeatureFlag> {
    static schema: FEntitySchema = {
        name: 'FeatureFlag',
        editable: false,
        primaryKeys: [
            { name: 'key', type: 'string' },
        ],
        fields: [
            { name: 'title', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('featureFlag');
        let config = { enableVersioning: true, enableTimestamps: true, validator: FeatureFlagFactory.validate, hasLiveStreams: false };
        return new FeatureFlagFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('title', src.title);
        validators.isString('title', src.title);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('FeatureFlag', 'featureFlag', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'key': rawId[0] };
    }
    async findById(ctx: Context, key: string) {
        return await this._findById(ctx, [key]);
    }
    async create(ctx: Context, key: string, shape: FeatureFlagShape) {
        return await this._create(ctx, [key], { key, ...shape });
    }
    async create_UNSAFE(ctx: Context, key: string, shape: FeatureFlagShape) {
        return await this._create_UNSAFE(ctx, [key], { key, ...shape });
    }
    watch(ctx: Context, key: string) {
        return this._watch(ctx, [key]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new FeatureFlag(ctx, this.layer, this.directory, [value.key], value, this.options, isNew, this.indexes, 'FeatureFlag');
    }
}
export interface OrganizationFeaturesShape {
    featureKey: string;
    organizationId: number;
    enabled: boolean;
}

export class OrganizationFeatures extends FEntity {
    readonly entityName: 'OrganizationFeatures' = 'OrganizationFeatures';
    get id(): string { return this._value.id; }
    get featureKey(): string {
        return this._value.featureKey;
    }
    set featureKey(value: string) {
        this._checkIsWritable();
        if (value === this._value.featureKey) { return; }
        this._value.featureKey = value;
        this.markDirty();
    }
    get organizationId(): number {
        return this._value.organizationId;
    }
    set organizationId(value: number) {
        this._checkIsWritable();
        if (value === this._value.organizationId) { return; }
        this._value.organizationId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class OrganizationFeaturesFactory extends FEntityFactory<OrganizationFeatures> {
    static schema: FEntitySchema = {
        name: 'OrganizationFeatures',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'featureKey', type: 'string' },
            { name: 'organizationId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['organizationId', 'featureKey'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationFeatures');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationFeaturesFactory.validate, hasLiveStreams: false };
        let indexOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationFeatures', 'organization'), 'organization', ['organizationId', 'featureKey'], true);
        let indexes = {
            organization: indexOrganization,
        };
        return new OrganizationFeaturesFactory(layer, directory, config, indexes);
    }

    readonly indexOrganization: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('featureKey', src.featureKey);
        validators.isString('featureKey', src.featureKey);
        validators.notNull('organizationId', src.organizationId);
        validators.isNumber('organizationId', src.organizationId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { organization: FEntityIndex }) {
        super('OrganizationFeatures', 'organizationFeatures', config, [indexes.organization], layer, directory);
        this.indexOrganization = indexes.organization;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: OrganizationFeaturesShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: OrganizationFeaturesShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async findFromOrganization(ctx: Context, organizationId: number, featureKey: string) {
        return await this._findFromIndex(ctx, this.indexOrganization.directory, [organizationId, featureKey]);
    }
    async allFromOrganizationAfter(ctx: Context, organizationId: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexOrganization.directory, [organizationId], after);
    }
    async rangeFromOrganizationAfter(ctx: Context, organizationId: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexOrganization.directory, [organizationId], after, limit, reversed);
    }
    async rangeFromOrganization(ctx: Context, organizationId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganization.directory, [organizationId], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(ctx: Context, organizationId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganization.directory, [organizationId], limit, after, reversed);
    }
    async allFromOrganization(ctx: Context, organizationId: number) {
        return await this._findAll(ctx, this.indexOrganization.directory, [organizationId]);
    }
    createOrganizationStream(organizationId: number, limit: number, after?: string) {
        return this._createStream(this.indexOrganization.directory, [organizationId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationFeatures(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationFeatures');
    }
}
export interface ReaderStateShape {
    cursor: string;
    version?: number| null;
}

export class ReaderState extends FEntity {
    readonly entityName: 'ReaderState' = 'ReaderState';
    get id(): string { return this._value.id; }
    get cursor(): string {
        return this._value.cursor;
    }
    set cursor(value: string) {
        this._checkIsWritable();
        if (value === this._value.cursor) { return; }
        this._value.cursor = value;
        this.markDirty();
    }
    get version(): number | null {
        let res = this._value.version;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set version(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
}

export class ReaderStateFactory extends FEntityFactory<ReaderState> {
    static schema: FEntitySchema = {
        name: 'ReaderState',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'cursor', type: 'string' },
            { name: 'version', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('readerState');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ReaderStateFactory.validate, hasLiveStreams: false };
        return new ReaderStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('cursor', src.cursor);
        validators.isString('cursor', src.cursor);
        validators.isNumber('version', src.version);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('ReaderState', 'readerState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: ReaderStateShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: ReaderStateShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ReaderState(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ReaderState');
    }
}
export interface SuperAdminShape {
    role: string;
    enabled: boolean;
}

export class SuperAdmin extends FEntity {
    readonly entityName: 'SuperAdmin' = 'SuperAdmin';
    get id(): number { return this._value.id; }
    get role(): string {
        return this._value.role;
    }
    set role(value: string) {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class SuperAdminFactory extends FEntityFactory<SuperAdmin> {
    static schema: FEntitySchema = {
        name: 'SuperAdmin',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'role', type: 'string' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('superAdmin');
        let config = { enableVersioning: false, enableTimestamps: false, validator: SuperAdminFactory.validate, hasLiveStreams: false };
        return new SuperAdminFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('role', src.role);
        validators.isString('role', src.role);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('SuperAdmin', 'superAdmin', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: SuperAdminShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: SuperAdminShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new SuperAdmin(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'SuperAdmin');
    }
}
export interface UserSettingsShape {
    emailFrequency: '1hour' | '15min' | 'never' | '24hour' | '1week';
    desktopNotifications: 'all' | 'direct' | 'none';
    mobileNotifications: 'all' | 'direct' | 'none';
    commentNotifications?: 'all' | 'direct' | 'none'| null;
    commentNotificationsDelivery?: 'all' | 'none'| null;
    mobileAlert?: boolean| null;
    mobileIncludeText?: boolean| null;
    notificationsDelay?: 'none' | '1min' | '15min'| null;
}

export class UserSettings extends FEntity {
    readonly entityName: 'UserSettings' = 'UserSettings';
    get id(): number { return this._value.id; }
    get emailFrequency(): '1hour' | '15min' | 'never' | '24hour' | '1week' {
        return this._value.emailFrequency;
    }
    set emailFrequency(value: '1hour' | '15min' | 'never' | '24hour' | '1week') {
        this._checkIsWritable();
        if (value === this._value.emailFrequency) { return; }
        this._value.emailFrequency = value;
        this.markDirty();
    }
    get desktopNotifications(): 'all' | 'direct' | 'none' {
        return this._value.desktopNotifications;
    }
    set desktopNotifications(value: 'all' | 'direct' | 'none') {
        this._checkIsWritable();
        if (value === this._value.desktopNotifications) { return; }
        this._value.desktopNotifications = value;
        this.markDirty();
    }
    get mobileNotifications(): 'all' | 'direct' | 'none' {
        return this._value.mobileNotifications;
    }
    set mobileNotifications(value: 'all' | 'direct' | 'none') {
        this._checkIsWritable();
        if (value === this._value.mobileNotifications) { return; }
        this._value.mobileNotifications = value;
        this.markDirty();
    }
    get commentNotifications(): 'all' | 'direct' | 'none' | null {
        let res = this._value.commentNotifications;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set commentNotifications(value: 'all' | 'direct' | 'none' | null) {
        this._checkIsWritable();
        if (value === this._value.commentNotifications) { return; }
        this._value.commentNotifications = value;
        this.markDirty();
    }
    get commentNotificationsDelivery(): 'all' | 'none' | null {
        let res = this._value.commentNotificationsDelivery;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set commentNotificationsDelivery(value: 'all' | 'none' | null) {
        this._checkIsWritable();
        if (value === this._value.commentNotificationsDelivery) { return; }
        this._value.commentNotificationsDelivery = value;
        this.markDirty();
    }
    get mobileAlert(): boolean | null {
        let res = this._value.mobileAlert;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mobileAlert(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.mobileAlert) { return; }
        this._value.mobileAlert = value;
        this.markDirty();
    }
    get mobileIncludeText(): boolean | null {
        let res = this._value.mobileIncludeText;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mobileIncludeText(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.mobileIncludeText) { return; }
        this._value.mobileIncludeText = value;
        this.markDirty();
    }
    get notificationsDelay(): 'none' | '1min' | '15min' | null {
        let res = this._value.notificationsDelay;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set notificationsDelay(value: 'none' | '1min' | '15min' | null) {
        this._checkIsWritable();
        if (value === this._value.notificationsDelay) { return; }
        this._value.notificationsDelay = value;
        this.markDirty();
    }
}

export class UserSettingsFactory extends FEntityFactory<UserSettings> {
    static schema: FEntitySchema = {
        name: 'UserSettings',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'emailFrequency', type: 'enum', enumValues: ['1hour', '15min', 'never', '24hour', '1week'] },
            { name: 'desktopNotifications', type: 'enum', enumValues: ['all', 'direct', 'none'] },
            { name: 'mobileNotifications', type: 'enum', enumValues: ['all', 'direct', 'none'] },
            { name: 'commentNotifications', type: 'enum', enumValues: ['all', 'direct', 'none'] },
            { name: 'commentNotificationsDelivery', type: 'enum', enumValues: ['all', 'none'] },
            { name: 'mobileAlert', type: 'boolean' },
            { name: 'mobileIncludeText', type: 'boolean' },
            { name: 'notificationsDelay', type: 'enum', enumValues: ['none', '1min', '15min'] },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userSettings');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserSettingsFactory.validate, hasLiveStreams: false };
        return new UserSettingsFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('emailFrequency', src.emailFrequency);
        validators.isEnum('emailFrequency', src.emailFrequency, ['1hour', '15min', 'never', '24hour', '1week']);
        validators.notNull('desktopNotifications', src.desktopNotifications);
        validators.isEnum('desktopNotifications', src.desktopNotifications, ['all', 'direct', 'none']);
        validators.notNull('mobileNotifications', src.mobileNotifications);
        validators.isEnum('mobileNotifications', src.mobileNotifications, ['all', 'direct', 'none']);
        validators.isEnum('commentNotifications', src.commentNotifications, ['all', 'direct', 'none']);
        validators.isEnum('commentNotificationsDelivery', src.commentNotificationsDelivery, ['all', 'none']);
        validators.isBoolean('mobileAlert', src.mobileAlert);
        validators.isBoolean('mobileIncludeText', src.mobileIncludeText);
        validators.isEnum('notificationsDelay', src.notificationsDelay, ['none', '1min', '15min']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserSettings', 'userSettings', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserSettingsShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserSettingsShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserSettings(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserSettings');
    }
}
export interface ShortnameReservationShape {
    ownerType: 'org' | 'user';
    ownerId: number;
    enabled: boolean;
}

export class ShortnameReservation extends FEntity {
    readonly entityName: 'ShortnameReservation' = 'ShortnameReservation';
    get shortname(): string { return this._value.shortname; }
    get ownerType(): 'org' | 'user' {
        return this._value.ownerType;
    }
    set ownerType(value: 'org' | 'user') {
        this._checkIsWritable();
        if (value === this._value.ownerType) { return; }
        this._value.ownerType = value;
        this.markDirty();
    }
    get ownerId(): number {
        return this._value.ownerId;
    }
    set ownerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ShortnameReservationFactory extends FEntityFactory<ShortnameReservation> {
    static schema: FEntitySchema = {
        name: 'ShortnameReservation',
        editable: false,
        primaryKeys: [
            { name: 'shortname', type: 'string' },
        ],
        fields: [
            { name: 'ownerType', type: 'enum', enumValues: ['org', 'user'] },
            { name: 'ownerId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['ownerId'] },
            { name: 'org', type: 'unique', fields: ['ownerId'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('shortnameReservation');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ShortnameReservationFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('shortnameReservation', 'user'), 'user', ['ownerId'], true, (src) => src.ownerType === 'user' && src.enabled);
        let indexOrg = new FEntityIndex(await layer.resolveEntityIndexDirectory('shortnameReservation', 'org'), 'org', ['ownerId'], true, (src) => src.ownerType === 'org' && src.enabled);
        let indexes = {
            user: indexUser,
            org: indexOrg,
        };
        return new ShortnameReservationFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexOrg: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('shortname', src.shortname);
        validators.isString('shortname', src.shortname);
        validators.notNull('ownerType', src.ownerType);
        validators.isEnum('ownerType', src.ownerType, ['org', 'user']);
        validators.notNull('ownerId', src.ownerId);
        validators.isNumber('ownerId', src.ownerId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, org: FEntityIndex }) {
        super('ShortnameReservation', 'shortnameReservation', config, [indexes.user, indexes.org], layer, directory);
        this.indexUser = indexes.user;
        this.indexOrg = indexes.org;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'shortname': rawId[0] };
    }
    async findById(ctx: Context, shortname: string) {
        return await this._findById(ctx, [shortname]);
    }
    async create(ctx: Context, shortname: string, shape: ShortnameReservationShape) {
        return await this._create(ctx, [shortname], { shortname, ...shape });
    }
    async create_UNSAFE(ctx: Context, shortname: string, shape: ShortnameReservationShape) {
        return await this._create_UNSAFE(ctx, [shortname], { shortname, ...shape });
    }
    watch(ctx: Context, shortname: string) {
        return this._watch(ctx, [shortname]);
    }
    async findFromUser(ctx: Context, ownerId: number) {
        return await this._findFromIndex(ctx, this.indexUser.directory, [ownerId]);
    }
    async rangeFromUser(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [], limit, after, reversed);
    }
    async allFromUser(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUser.directory, []);
    }
    createUserStream(limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [], limit, after); 
    }
    async findFromOrg(ctx: Context, ownerId: number) {
        return await this._findFromIndex(ctx, this.indexOrg.directory, [ownerId]);
    }
    async rangeFromOrg(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrg.directory, [], limit, reversed);
    }
    async rangeFromOrgWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrg.directory, [], limit, after, reversed);
    }
    async allFromOrg(ctx: Context, ) {
        return await this._findAll(ctx, this.indexOrg.directory, []);
    }
    createOrgStream(limit: number, after?: string) {
        return this._createStream(this.indexOrg.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ShortnameReservation(ctx, this.layer, this.directory, [value.shortname], value, this.options, isNew, this.indexes, 'ShortnameReservation');
    }
}
export interface AuthCodeSessionShape {
    code: string;
    expires: number;
    email: string;
    tokenId?: string| null;
    enabled: boolean;
}

export class AuthCodeSession extends FEntity {
    readonly entityName: 'AuthCodeSession' = 'AuthCodeSession';
    get uid(): string { return this._value.uid; }
    get code(): string {
        return this._value.code;
    }
    set code(value: string) {
        this._checkIsWritable();
        if (value === this._value.code) { return; }
        this._value.code = value;
        this.markDirty();
    }
    get expires(): number {
        return this._value.expires;
    }
    set expires(value: number) {
        this._checkIsWritable();
        if (value === this._value.expires) { return; }
        this._value.expires = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get tokenId(): string | null {
        let res = this._value.tokenId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set tokenId(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.tokenId) { return; }
        this._value.tokenId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class AuthCodeSessionFactory extends FEntityFactory<AuthCodeSession> {
    static schema: FEntitySchema = {
        name: 'AuthCodeSession',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'string' },
        ],
        fields: [
            { name: 'code', type: 'string', secure: true },
            { name: 'expires', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'tokenId', type: 'string', secure: true },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('authCodeSession');
        let config = { enableVersioning: true, enableTimestamps: true, validator: AuthCodeSessionFactory.validate, hasLiveStreams: false };
        return new AuthCodeSessionFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isString('uid', src.uid);
        validators.notNull('code', src.code);
        validators.isString('code', src.code);
        validators.notNull('expires', src.expires);
        validators.isNumber('expires', src.expires);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.isString('tokenId', src.tokenId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('AuthCodeSession', 'authCodeSession', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: string) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: string, shape: AuthCodeSessionShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: string, shape: AuthCodeSessionShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: string) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new AuthCodeSession(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'AuthCodeSession');
    }
}
export interface ConversationShape {
    kind: 'private' | 'organization' | 'room';
    deleted?: boolean| null;
    archived?: boolean| null;
}

export class Conversation extends FEntity {
    readonly entityName: 'Conversation' = 'Conversation';
    get id(): number { return this._value.id; }
    get kind(): 'private' | 'organization' | 'room' {
        return this._value.kind;
    }
    set kind(value: 'private' | 'organization' | 'room') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get archived(): boolean | null {
        let res = this._value.archived;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set archived(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.archived) { return; }
        this._value.archived = value;
        this.markDirty();
    }
}

export class ConversationFactory extends FEntityFactory<Conversation> {
    static schema: FEntitySchema = {
        name: 'Conversation',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['private', 'organization', 'room'] },
            { name: 'deleted', type: 'boolean' },
            { name: 'archived', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversation');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationFactory.validate, hasLiveStreams: false };
        return new ConversationFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['private', 'organization', 'room']);
        validators.isBoolean('deleted', src.deleted);
        validators.isBoolean('archived', src.archived);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('Conversation', 'conversation', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConversationShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConversationShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Conversation(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Conversation');
    }
}
export interface ConversationPrivateShape {
    uid1: number;
    uid2: number;
    pinnedMessage?: number| null;
}

export class ConversationPrivate extends FEntity {
    readonly entityName: 'ConversationPrivate' = 'ConversationPrivate';
    get id(): number { return this._value.id; }
    get uid1(): number {
        return this._value.uid1;
    }
    set uid1(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid1) { return; }
        this._value.uid1 = value;
        this.markDirty();
    }
    get uid2(): number {
        return this._value.uid2;
    }
    set uid2(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid2) { return; }
        this._value.uid2 = value;
        this.markDirty();
    }
    get pinnedMessage(): number | null {
        let res = this._value.pinnedMessage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set pinnedMessage(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.pinnedMessage) { return; }
        this._value.pinnedMessage = value;
        this.markDirty();
    }
}

export class ConversationPrivateFactory extends FEntityFactory<ConversationPrivate> {
    static schema: FEntitySchema = {
        name: 'ConversationPrivate',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'uid1', type: 'number' },
            { name: 'uid2', type: 'number' },
            { name: 'pinnedMessage', type: 'number' },
        ],
        indexes: [
            { name: 'users', type: 'unique', fields: ['uid1', 'uid2'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationPrivate');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationPrivateFactory.validate, hasLiveStreams: false };
        let indexUsers = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationPrivate', 'users'), 'users', ['uid1', 'uid2'], true);
        let indexes = {
            users: indexUsers,
        };
        return new ConversationPrivateFactory(layer, directory, config, indexes);
    }

    readonly indexUsers: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('uid1', src.uid1);
        validators.isNumber('uid1', src.uid1);
        validators.notNull('uid2', src.uid2);
        validators.isNumber('uid2', src.uid2);
        validators.isNumber('pinnedMessage', src.pinnedMessage);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { users: FEntityIndex }) {
        super('ConversationPrivate', 'conversationPrivate', config, [indexes.users], layer, directory);
        this.indexUsers = indexes.users;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConversationPrivateShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConversationPrivateShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromUsers(ctx: Context, uid1: number, uid2: number) {
        return await this._findFromIndex(ctx, this.indexUsers.directory, [uid1, uid2]);
    }
    async allFromUsersAfter(ctx: Context, uid1: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUsers.directory, [uid1], after);
    }
    async rangeFromUsersAfter(ctx: Context, uid1: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUsers.directory, [uid1], after, limit, reversed);
    }
    async rangeFromUsers(ctx: Context, uid1: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUsers.directory, [uid1], limit, reversed);
    }
    async rangeFromUsersWithCursor(ctx: Context, uid1: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUsers.directory, [uid1], limit, after, reversed);
    }
    async allFromUsers(ctx: Context, uid1: number) {
        return await this._findAll(ctx, this.indexUsers.directory, [uid1]);
    }
    createUsersStream(uid1: number, limit: number, after?: string) {
        return this._createStream(this.indexUsers.directory, [uid1], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationPrivate(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationPrivate');
    }
}
export interface ConversationOrganizationShape {
    oid: number;
}

export class ConversationOrganization extends FEntity {
    readonly entityName: 'ConversationOrganization' = 'ConversationOrganization';
    get id(): number { return this._value.id; }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
}

export class ConversationOrganizationFactory extends FEntityFactory<ConversationOrganization> {
    static schema: FEntitySchema = {
        name: 'ConversationOrganization',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'oid', type: 'number' },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['oid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationOrganization');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationOrganizationFactory.validate, hasLiveStreams: false };
        let indexOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationOrganization', 'organization'), 'organization', ['oid'], true);
        let indexes = {
            organization: indexOrganization,
        };
        return new ConversationOrganizationFactory(layer, directory, config, indexes);
    }

    readonly indexOrganization: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { organization: FEntityIndex }) {
        super('ConversationOrganization', 'conversationOrganization', config, [indexes.organization], layer, directory);
        this.indexOrganization = indexes.organization;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConversationOrganizationShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConversationOrganizationShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromOrganization(ctx: Context, oid: number) {
        return await this._findFromIndex(ctx, this.indexOrganization.directory, [oid]);
    }
    async rangeFromOrganization(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganization.directory, [], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganization.directory, [], limit, after, reversed);
    }
    async allFromOrganization(ctx: Context, ) {
        return await this._findAll(ctx, this.indexOrganization.directory, []);
    }
    createOrganizationStream(limit: number, after?: string) {
        return this._createStream(this.indexOrganization.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationOrganization(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationOrganization');
    }
}
export interface ConversationRoomShape {
    kind: 'organization' | 'internal' | 'public' | 'group';
    oid?: number| null;
    ownerId?: number| null;
    featured?: boolean| null;
    listed?: boolean| null;
    isChannel?: boolean| null;
}

export class ConversationRoom extends FEntity {
    readonly entityName: 'ConversationRoom' = 'ConversationRoom';
    get id(): number { return this._value.id; }
    get kind(): 'organization' | 'internal' | 'public' | 'group' {
        return this._value.kind;
    }
    set kind(value: 'organization' | 'internal' | 'public' | 'group') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get oid(): number | null {
        let res = this._value.oid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set oid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get ownerId(): number | null {
        let res = this._value.ownerId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set ownerId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.ownerId) { return; }
        this._value.ownerId = value;
        this.markDirty();
    }
    get featured(): boolean | null {
        let res = this._value.featured;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set featured(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.featured) { return; }
        this._value.featured = value;
        this.markDirty();
    }
    get listed(): boolean | null {
        let res = this._value.listed;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set listed(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.listed) { return; }
        this._value.listed = value;
        this.markDirty();
    }
    get isChannel(): boolean | null {
        let res = this._value.isChannel;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set isChannel(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.isChannel) { return; }
        this._value.isChannel = value;
        this.markDirty();
    }
}

export class ConversationRoomFactory extends FEntityFactory<ConversationRoom> {
    static schema: FEntitySchema = {
        name: 'ConversationRoom',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['organization', 'internal', 'public', 'group'] },
            { name: 'oid', type: 'number' },
            { name: 'ownerId', type: 'number' },
            { name: 'featured', type: 'boolean' },
            { name: 'listed', type: 'boolean' },
            { name: 'isChannel', type: 'boolean' },
        ],
        indexes: [
            { name: 'organization', type: 'range', fields: ['oid'] },
            { name: 'organizationPublicRooms', type: 'unique', fields: ['oid', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationRoom');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationRoomFactory.validate, hasLiveStreams: false };
        let indexOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationRoom', 'organization'), 'organization', ['oid'], false, (v) => v.kind === 'public' || v.kind === 'internal');
        let indexOrganizationPublicRooms = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationRoom', 'organizationPublicRooms'), 'organizationPublicRooms', ['oid', 'id'], true, (v) => v.kind === 'public');
        let indexes = {
            organization: indexOrganization,
            organizationPublicRooms: indexOrganizationPublicRooms,
        };
        return new ConversationRoomFactory(layer, directory, config, indexes);
    }

    readonly indexOrganization: FEntityIndex;
    readonly indexOrganizationPublicRooms: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['organization', 'internal', 'public', 'group']);
        validators.isNumber('oid', src.oid);
        validators.isNumber('ownerId', src.ownerId);
        validators.isBoolean('featured', src.featured);
        validators.isBoolean('listed', src.listed);
        validators.isBoolean('isChannel', src.isChannel);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { organization: FEntityIndex, organizationPublicRooms: FEntityIndex }) {
        super('ConversationRoom', 'conversationRoom', config, [indexes.organization, indexes.organizationPublicRooms], layer, directory);
        this.indexOrganization = indexes.organization;
        this.indexOrganizationPublicRooms = indexes.organizationPublicRooms;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConversationRoomShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConversationRoomShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromOrganization(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganization.directory, [], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganization.directory, [], limit, after, reversed);
    }
    async allFromOrganization(ctx: Context, ) {
        return await this._findAll(ctx, this.indexOrganization.directory, []);
    }
    createOrganizationStream(limit: number, after?: string) {
        return this._createStream(this.indexOrganization.directory, [], limit, after); 
    }
    async findFromOrganizationPublicRooms(ctx: Context, oid: number, id: number) {
        return await this._findFromIndex(ctx, this.indexOrganizationPublicRooms.directory, [oid, id]);
    }
    async allFromOrganizationPublicRoomsAfter(ctx: Context, oid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexOrganizationPublicRooms.directory, [oid], after);
    }
    async rangeFromOrganizationPublicRoomsAfter(ctx: Context, oid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexOrganizationPublicRooms.directory, [oid], after, limit, reversed);
    }
    async rangeFromOrganizationPublicRooms(ctx: Context, oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganizationPublicRooms.directory, [oid], limit, reversed);
    }
    async rangeFromOrganizationPublicRoomsWithCursor(ctx: Context, oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganizationPublicRooms.directory, [oid], limit, after, reversed);
    }
    async allFromOrganizationPublicRooms(ctx: Context, oid: number) {
        return await this._findAll(ctx, this.indexOrganizationPublicRooms.directory, [oid]);
    }
    createOrganizationPublicRoomsStream(oid: number, limit: number, after?: string) {
        return this._createStream(this.indexOrganizationPublicRooms.directory, [oid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationRoom(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConversationRoom');
    }
}
export interface RoomProfileShape {
    title: string;
    image?: any| null;
    description?: string| null;
    socialImage?: any| null;
    pinnedMessage?: number| null;
    welcomeMessageIsOn?: boolean| null;
    welcomeMessageSender?: number| null;
    welcomeMessageText?: string| null;
    activeMembersCount?: number| null;
}

export class RoomProfile extends FEntity {
    readonly entityName: 'RoomProfile' = 'RoomProfile';
    get id(): number { return this._value.id; }
    get title(): string {
        return this._value.title;
    }
    set title(value: string) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get image(): any | null {
        let res = this._value.image;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set image(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.image) { return; }
        this._value.image = value;
        this.markDirty();
    }
    get description(): string | null {
        let res = this._value.description;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set description(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.description) { return; }
        this._value.description = value;
        this.markDirty();
    }
    get socialImage(): any | null {
        let res = this._value.socialImage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set socialImage(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.socialImage) { return; }
        this._value.socialImage = value;
        this.markDirty();
    }
    get pinnedMessage(): number | null {
        let res = this._value.pinnedMessage;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set pinnedMessage(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.pinnedMessage) { return; }
        this._value.pinnedMessage = value;
        this.markDirty();
    }
    get welcomeMessageIsOn(): boolean | null {
        let res = this._value.welcomeMessageIsOn;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set welcomeMessageIsOn(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.welcomeMessageIsOn) { return; }
        this._value.welcomeMessageIsOn = value;
        this.markDirty();
    }
    get welcomeMessageSender(): number | null {
        let res = this._value.welcomeMessageSender;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set welcomeMessageSender(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.welcomeMessageSender) { return; }
        this._value.welcomeMessageSender = value;
        this.markDirty();
    }
    get welcomeMessageText(): string | null {
        let res = this._value.welcomeMessageText;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set welcomeMessageText(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.welcomeMessageText) { return; }
        this._value.welcomeMessageText = value;
        this.markDirty();
    }
    get activeMembersCount(): number | null {
        let res = this._value.activeMembersCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set activeMembersCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.activeMembersCount) { return; }
        this._value.activeMembersCount = value;
        this.markDirty();
    }
}

export class RoomProfileFactory extends FEntityFactory<RoomProfile> {
    static schema: FEntitySchema = {
        name: 'RoomProfile',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'title', type: 'string' },
            { name: 'image', type: 'json' },
            { name: 'description', type: 'string' },
            { name: 'socialImage', type: 'json' },
            { name: 'pinnedMessage', type: 'number' },
            { name: 'welcomeMessageIsOn', type: 'boolean' },
            { name: 'welcomeMessageSender', type: 'number' },
            { name: 'welcomeMessageText', type: 'string' },
            { name: 'activeMembersCount', type: 'number' },
        ],
        indexes: [
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('roomProfile');
        let config = { enableVersioning: true, enableTimestamps: true, validator: RoomProfileFactory.validate, hasLiveStreams: false };
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('roomProfile', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            updated: indexUpdated,
        };
        return new RoomProfileFactory(layer, directory, config, indexes);
    }

    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('title', src.title);
        validators.isString('title', src.title);
        validators.isString('description', src.description);
        validators.isNumber('pinnedMessage', src.pinnedMessage);
        validators.isBoolean('welcomeMessageIsOn', src.welcomeMessageIsOn);
        validators.isNumber('welcomeMessageSender', src.welcomeMessageSender);
        validators.isString('welcomeMessageText', src.welcomeMessageText);
        validators.isNumber('activeMembersCount', src.activeMembersCount);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { updated: FEntityIndex }) {
        super('RoomProfile', 'roomProfile', config, [indexes.updated], layer, directory);
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: RoomProfileShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: RoomProfileShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new RoomProfile(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'RoomProfile');
    }
}
export interface RoomParticipantShape {
    invitedBy: number;
    role: 'member' | 'admin' | 'owner';
    status: 'joined' | 'requested' | 'left' | 'kicked';
}

export class RoomParticipant extends FEntity {
    readonly entityName: 'RoomParticipant' = 'RoomParticipant';
    get cid(): number { return this._value.cid; }
    get uid(): number { return this._value.uid; }
    get invitedBy(): number {
        return this._value.invitedBy;
    }
    set invitedBy(value: number) {
        this._checkIsWritable();
        if (value === this._value.invitedBy) { return; }
        this._value.invitedBy = value;
        this.markDirty();
    }
    get role(): 'member' | 'admin' | 'owner' {
        return this._value.role;
    }
    set role(value: 'member' | 'admin' | 'owner') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
    get status(): 'joined' | 'requested' | 'left' | 'kicked' {
        return this._value.status;
    }
    set status(value: 'joined' | 'requested' | 'left' | 'kicked') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class RoomParticipantFactory extends FEntityFactory<RoomParticipant> {
    static schema: FEntitySchema = {
        name: 'RoomParticipant',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'invitedBy', type: 'number' },
            { name: 'role', type: 'enum', enumValues: ['member', 'admin', 'owner'] },
            { name: 'status', type: 'enum', enumValues: ['joined', 'requested', 'left', 'kicked'] },
        ],
        indexes: [
            { name: 'active', type: 'unique', fields: ['cid', 'uid'] },
            { name: 'requests', type: 'unique', fields: ['cid', 'uid'] },
            { name: 'userActive', type: 'unique', fields: ['uid', 'cid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('roomParticipant');
        let config = { enableVersioning: true, enableTimestamps: true, validator: RoomParticipantFactory.validate, hasLiveStreams: false };
        let indexActive = new FEntityIndex(await layer.resolveEntityIndexDirectory('roomParticipant', 'active'), 'active', ['cid', 'uid'], true, (src) => src.status === 'joined');
        let indexRequests = new FEntityIndex(await layer.resolveEntityIndexDirectory('roomParticipant', 'requests'), 'requests', ['cid', 'uid'], true, (src) => src.status === 'requested');
        let indexUserActive = new FEntityIndex(await layer.resolveEntityIndexDirectory('roomParticipant', 'userActive'), 'userActive', ['uid', 'cid'], true, (src) => src.status === 'joined');
        let indexes = {
            active: indexActive,
            requests: indexRequests,
            userActive: indexUserActive,
        };
        return new RoomParticipantFactory(layer, directory, config, indexes);
    }

    readonly indexActive: FEntityIndex;
    readonly indexRequests: FEntityIndex;
    readonly indexUserActive: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('invitedBy', src.invitedBy);
        validators.isNumber('invitedBy', src.invitedBy);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['member', 'admin', 'owner']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['joined', 'requested', 'left', 'kicked']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { active: FEntityIndex, requests: FEntityIndex, userActive: FEntityIndex }) {
        super('RoomParticipant', 'roomParticipant', config, [indexes.active, indexes.requests, indexes.userActive], layer, directory);
        this.indexActive = indexes.active;
        this.indexRequests = indexes.requests;
        this.indexUserActive = indexes.userActive;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'uid': rawId[1] };
    }
    async findById(ctx: Context, cid: number, uid: number) {
        return await this._findById(ctx, [cid, uid]);
    }
    async create(ctx: Context, cid: number, uid: number, shape: RoomParticipantShape) {
        return await this._create(ctx, [cid, uid], { cid, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, cid: number, uid: number, shape: RoomParticipantShape) {
        return await this._create_UNSAFE(ctx, [cid, uid], { cid, uid, ...shape });
    }
    watch(ctx: Context, cid: number, uid: number) {
        return this._watch(ctx, [cid, uid]);
    }
    async findFromActive(ctx: Context, cid: number, uid: number) {
        return await this._findFromIndex(ctx, this.indexActive.directory, [cid, uid]);
    }
    async allFromActiveAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexActive.directory, [cid], after);
    }
    async rangeFromActiveAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexActive.directory, [cid], after, limit, reversed);
    }
    async rangeFromActive(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexActive.directory, [cid], limit, reversed);
    }
    async rangeFromActiveWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexActive.directory, [cid], limit, after, reversed);
    }
    async allFromActive(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexActive.directory, [cid]);
    }
    createActiveStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexActive.directory, [cid], limit, after); 
    }
    async findFromRequests(ctx: Context, cid: number, uid: number) {
        return await this._findFromIndex(ctx, this.indexRequests.directory, [cid, uid]);
    }
    async allFromRequestsAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexRequests.directory, [cid], after);
    }
    async rangeFromRequestsAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexRequests.directory, [cid], after, limit, reversed);
    }
    async rangeFromRequests(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexRequests.directory, [cid], limit, reversed);
    }
    async rangeFromRequestsWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexRequests.directory, [cid], limit, after, reversed);
    }
    async allFromRequests(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexRequests.directory, [cid]);
    }
    createRequestsStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexRequests.directory, [cid], limit, after); 
    }
    async findFromUserActive(ctx: Context, uid: number, cid: number) {
        return await this._findFromIndex(ctx, this.indexUserActive.directory, [uid, cid]);
    }
    async allFromUserActiveAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUserActive.directory, [uid], after);
    }
    async rangeFromUserActiveAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUserActive.directory, [uid], after, limit, reversed);
    }
    async rangeFromUserActive(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUserActive.directory, [uid], limit, reversed);
    }
    async rangeFromUserActiveWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUserActive.directory, [uid], limit, after, reversed);
    }
    async allFromUserActive(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUserActive.directory, [uid]);
    }
    createUserActiveStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUserActive.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new RoomParticipant(ctx, this.layer, this.directory, [value.cid, value.uid], value, this.options, isNew, this.indexes, 'RoomParticipant');
    }
}
export interface ConversationReceiverShape {
    enabled: boolean;
}

export class ConversationReceiver extends FEntity {
    readonly entityName: 'ConversationReceiver' = 'ConversationReceiver';
    get cid(): number { return this._value.cid; }
    get uid(): number { return this._value.uid; }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ConversationReceiverFactory extends FEntityFactory<ConversationReceiver> {
    static schema: FEntitySchema = {
        name: 'ConversationReceiver',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'conversation', type: 'unique', fields: ['cid', 'uid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationReceiver');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationReceiverFactory.validate, hasLiveStreams: false };
        let indexConversation = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationReceiver', 'conversation'), 'conversation', ['cid', 'uid'], true, (src) => src.enabled);
        let indexes = {
            conversation: indexConversation,
        };
        return new ConversationReceiverFactory(layer, directory, config, indexes);
    }

    readonly indexConversation: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { conversation: FEntityIndex }) {
        super('ConversationReceiver', 'conversationReceiver', config, [indexes.conversation], layer, directory);
        this.indexConversation = indexes.conversation;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'uid': rawId[1] };
    }
    async findById(ctx: Context, cid: number, uid: number) {
        return await this._findById(ctx, [cid, uid]);
    }
    async create(ctx: Context, cid: number, uid: number, shape: ConversationReceiverShape) {
        return await this._create(ctx, [cid, uid], { cid, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, cid: number, uid: number, shape: ConversationReceiverShape) {
        return await this._create_UNSAFE(ctx, [cid, uid], { cid, uid, ...shape });
    }
    watch(ctx: Context, cid: number, uid: number) {
        return this._watch(ctx, [cid, uid]);
    }
    async findFromConversation(ctx: Context, cid: number, uid: number) {
        return await this._findFromIndex(ctx, this.indexConversation.directory, [cid, uid]);
    }
    async allFromConversationAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexConversation.directory, [cid], after);
    }
    async rangeFromConversationAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexConversation.directory, [cid], after, limit, reversed);
    }
    async rangeFromConversation(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexConversation.directory, [cid], limit, reversed);
    }
    async rangeFromConversationWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexConversation.directory, [cid], limit, after, reversed);
    }
    async allFromConversation(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexConversation.directory, [cid]);
    }
    createConversationStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexConversation.directory, [cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationReceiver(ctx, this.layer, this.directory, [value.cid, value.uid], value, this.options, isNew, this.indexes, 'ConversationReceiver');
    }
}
export interface SequenceShape {
    value: number;
}

export class Sequence extends FEntity {
    readonly entityName: 'Sequence' = 'Sequence';
    get sequence(): string { return this._value.sequence; }
    get value(): number {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class SequenceFactory extends FEntityFactory<Sequence> {
    static schema: FEntitySchema = {
        name: 'Sequence',
        editable: false,
        primaryKeys: [
            { name: 'sequence', type: 'string' },
        ],
        fields: [
            { name: 'value', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('sequence');
        let config = { enableVersioning: false, enableTimestamps: false, validator: SequenceFactory.validate, hasLiveStreams: false };
        return new SequenceFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('sequence', src.sequence);
        validators.isString('sequence', src.sequence);
        validators.notNull('value', src.value);
        validators.isNumber('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('Sequence', 'sequence', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'sequence': rawId[0] };
    }
    async findById(ctx: Context, sequence: string) {
        return await this._findById(ctx, [sequence]);
    }
    async create(ctx: Context, sequence: string, shape: SequenceShape) {
        return await this._create(ctx, [sequence], { sequence, ...shape });
    }
    async create_UNSAFE(ctx: Context, sequence: string, shape: SequenceShape) {
        return await this._create_UNSAFE(ctx, [sequence], { sequence, ...shape });
    }
    watch(ctx: Context, sequence: string) {
        return this._watch(ctx, [sequence]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Sequence(ctx, this.layer, this.directory, [value.sequence], value, this.options, isNew, this.indexes, 'Sequence');
    }
}
export interface MessageShape {
    cid: number;
    uid: number;
    repeatKey?: string| null;
    text?: string| null;
    replyMessages?: (number)[]| null;
    serviceMetadata?: any| null;
    reactions?: ({ userId: number, reaction: string, })[]| null;
    edited?: boolean| null;
    isMuted: boolean;
    isService: boolean;
    deleted?: boolean| null;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[]| null;
    attachmentsModern?: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[]| null;
    fileId?: string| null;
    fileMetadata?: { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, }| null;
    filePreview?: string| null;
    augmentation?: any| null;
    mentions?: any| null;
    attachments?: any| null;
    buttons?: any| null;
    type?: string| null;
    title?: string| null;
    postType?: string| null;
    complexMentions?: any| null;
}

export class Message extends FEntity {
    readonly entityName: 'Message' = 'Message';
    get id(): number { return this._value.id; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get repeatKey(): string | null {
        let res = this._value.repeatKey;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set repeatKey(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.repeatKey) { return; }
        this._value.repeatKey = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get replyMessages(): (number)[] | null {
        let res = this._value.replyMessages;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set replyMessages(value: (number)[] | null) {
        this._checkIsWritable();
        if (value === this._value.replyMessages) { return; }
        this._value.replyMessages = value;
        this.markDirty();
    }
    get serviceMetadata(): any | null {
        let res = this._value.serviceMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set serviceMetadata(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.serviceMetadata) { return; }
        this._value.serviceMetadata = value;
        this.markDirty();
    }
    get reactions(): ({ userId: number, reaction: string, })[] | null {
        let res = this._value.reactions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set reactions(value: ({ userId: number, reaction: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.reactions) { return; }
        this._value.reactions = value;
        this.markDirty();
    }
    get edited(): boolean | null {
        let res = this._value.edited;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set edited(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.edited) { return; }
        this._value.edited = value;
        this.markDirty();
    }
    get isMuted(): boolean {
        return this._value.isMuted;
    }
    set isMuted(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isMuted) { return; }
        this._value.isMuted = value;
        this.markDirty();
    }
    get isService(): boolean {
        return this._value.isService;
    }
    set isService(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isService) { return; }
        this._value.isService = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null {
        let res = this._value.spans;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.spans) { return; }
        this._value.spans = value;
        this.markDirty();
    }
    get attachmentsModern(): ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null {
        let res = this._value.attachmentsModern;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachmentsModern(value: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.attachmentsModern) { return; }
        this._value.attachmentsModern = value;
        this.markDirty();
    }
    get fileId(): string | null {
        let res = this._value.fileId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileId(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.fileId) { return; }
        this._value.fileId = value;
        this.markDirty();
    }
    get fileMetadata(): { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null {
        let res = this._value.fileMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileMetadata(value: { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null) {
        this._checkIsWritable();
        if (value === this._value.fileMetadata) { return; }
        this._value.fileMetadata = value;
        this.markDirty();
    }
    get filePreview(): string | null {
        let res = this._value.filePreview;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set filePreview(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.filePreview) { return; }
        this._value.filePreview = value;
        this.markDirty();
    }
    get augmentation(): any | null {
        let res = this._value.augmentation;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set augmentation(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.augmentation) { return; }
        this._value.augmentation = value;
        this.markDirty();
    }
    get mentions(): any | null {
        let res = this._value.mentions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mentions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.mentions) { return; }
        this._value.mentions = value;
        this.markDirty();
    }
    get attachments(): any | null {
        let res = this._value.attachments;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachments(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.attachments) { return; }
        this._value.attachments = value;
        this.markDirty();
    }
    get buttons(): any | null {
        let res = this._value.buttons;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set buttons(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.buttons) { return; }
        this._value.buttons = value;
        this.markDirty();
    }
    get type(): string | null {
        let res = this._value.type;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set type(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.type) { return; }
        this._value.type = value;
        this.markDirty();
    }
    get title(): string | null {
        let res = this._value.title;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set title(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get postType(): string | null {
        let res = this._value.postType;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set postType(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.postType) { return; }
        this._value.postType = value;
        this.markDirty();
    }
    get complexMentions(): any | null {
        let res = this._value.complexMentions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set complexMentions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.complexMentions) { return; }
        this._value.complexMentions = value;
        this.markDirty();
    }
}

export class MessageFactory extends FEntityFactory<Message> {
    static schema: FEntitySchema = {
        name: 'Message',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'repeatKey', type: 'string' },
            { name: 'text', type: 'string', secure: true },
            { name: 'replyMessages', type: 'json' },
            { name: 'serviceMetadata', type: 'json' },
            { name: 'reactions', type: 'json' },
            { name: 'edited', type: 'boolean' },
            { name: 'isMuted', type: 'boolean' },
            { name: 'isService', type: 'boolean' },
            { name: 'deleted', type: 'boolean' },
            { name: 'spans', type: 'json' },
            { name: 'attachmentsModern', type: 'json' },
            { name: 'fileId', type: 'string', secure: true },
            { name: 'fileMetadata', type: 'json', secure: true },
            { name: 'filePreview', type: 'string', secure: true },
            { name: 'augmentation', type: 'json' },
            { name: 'mentions', type: 'json' },
            { name: 'attachments', type: 'json' },
            { name: 'buttons', type: 'json' },
            { name: 'type', type: 'string' },
            { name: 'title', type: 'string' },
            { name: 'postType', type: 'string' },
            { name: 'complexMentions', type: 'json' },
        ],
        indexes: [
            { name: 'chat', type: 'range', fields: ['cid', 'id'] },
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
            { name: 'repeat', type: 'unique', fields: ['uid', 'cid', 'repeatKey'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('message');
        let config = { enableVersioning: true, enableTimestamps: true, validator: MessageFactory.validate, hasLiveStreams: false };
        let indexChat = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'chat'), 'chat', ['cid', 'id'], false, (src) => !src.deleted);
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'updated'), 'updated', ['updatedAt'], false);
        let indexRepeat = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'repeat'), 'repeat', ['uid', 'cid', 'repeatKey'], true, (src) => !!src.repeatKey);
        let indexes = {
            chat: indexChat,
            updated: indexUpdated,
            repeat: indexRepeat,
        };
        return new MessageFactory(layer, directory, config, indexes);
    }

    readonly indexChat: FEntityIndex;
    readonly indexUpdated: FEntityIndex;
    readonly indexRepeat: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('repeatKey', src.repeatKey);
        validators.isString('text', src.text);
        validators.isJson('replyMessages', src.replyMessages, jVec(jNumber()));
        validators.isJson('reactions', src.reactions, jVec(json(() => {
            jField('userId', jNumber());
            jField('reaction', jString());
        })));
        validators.isBoolean('edited', src.edited);
        validators.notNull('isMuted', src.isMuted);
        validators.isBoolean('isMuted', src.isMuted);
        validators.notNull('isService', src.isService);
        validators.isBoolean('isService', src.isService);
        validators.isBoolean('deleted', src.deleted);
        validators.isJson('spans', src.spans, jVec(jEnum(
            json(() => {
                jField('type', jString('user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('user', jNumber());
            }), 
            json(() => {
                jField('type', jString('multi_user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('users', jVec(jNumber()));
            }), 
            json(() => {
                jField('type', jString('room_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('room', jNumber());
            }), 
            json(() => {
                jField('type', jString('link'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('url', jString());
            }), 
            json(() => {
                jField('type', jString('bold_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('italic_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('irony_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('inline_code_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('code_block_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('insane_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('loud_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('rotating_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('date_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('date', jNumber());
            }), 
            json(() => {
                jField('type', jString('all_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
            })
        )));
        validators.isJson('attachmentsModern', src.attachmentsModern, jVec(jEnum(
            json(() => {
                jField('type', jString('file_attachment'));
                jField('fileId', jString());
                jField('filePreview', jString()).nullable();
                jField('fileMetadata', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('id', jString());
            }), 
            json(() => {
                jField('type', jString('rich_attachment'));
                jField('title', jString()).nullable();
                jField('subTitle', jString()).nullable();
                jField('titleLink', jString()).nullable();
                jField('text', jString()).nullable();
                jField('icon', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('image', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('iconInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('imageInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('titleLinkHostname', jString()).nullable();
                jField('keyboard', json(() => {
                jField('buttons', jVec(jVec(json(() => {
                jField('title', jString());
                jField('style', jEnumString('DEFAULT', 'LIGHT'));
                jField('url', jString()).nullable();
            }))));
            })).nullable();
                jField('id', jString());
            })
        )));
        validators.isString('fileId', src.fileId);
        validators.isJson('fileMetadata', src.fileMetadata, json(() => {
            jField('isStored', jBool()).undefinable();
            jField('isImage', jBool()).nullable();
            jField('imageWidth', jNumber()).nullable();
            jField('imageHeight', jNumber()).nullable();
            jField('imageFormat', jString()).nullable();
            jField('mimeType', jString());
            jField('name', jString());
            jField('size', jNumber());
        }));
        validators.isString('filePreview', src.filePreview);
        validators.isString('type', src.type);
        validators.isString('title', src.title);
        validators.isString('postType', src.postType);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { chat: FEntityIndex, updated: FEntityIndex, repeat: FEntityIndex }) {
        super('Message', 'message', config, [indexes.chat, indexes.updated, indexes.repeat], layer, directory);
        this.indexChat = indexes.chat;
        this.indexUpdated = indexes.updated;
        this.indexRepeat = indexes.repeat;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: MessageShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: MessageShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromChatAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChat.directory, [cid], after);
    }
    async rangeFromChatAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChat.directory, [cid], after, limit, reversed);
    }
    async rangeFromChat(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChat.directory, [cid], limit, reversed);
    }
    async rangeFromChatWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChat.directory, [cid], limit, after, reversed);
    }
    async allFromChat(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexChat.directory, [cid]);
    }
    createChatStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexChat.directory, [cid], limit, after); 
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    async findFromRepeat(ctx: Context, uid: number, cid: number, repeatKey: string) {
        return await this._findFromIndex(ctx, this.indexRepeat.directory, [uid, cid, repeatKey]);
    }
    async allFromRepeatAfter(ctx: Context, uid: number, cid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexRepeat.directory, [uid, cid], after);
    }
    async rangeFromRepeatAfter(ctx: Context, uid: number, cid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexRepeat.directory, [uid, cid], after, limit, reversed);
    }
    async rangeFromRepeat(ctx: Context, uid: number, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexRepeat.directory, [uid, cid], limit, reversed);
    }
    async rangeFromRepeatWithCursor(ctx: Context, uid: number, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexRepeat.directory, [uid, cid], limit, after, reversed);
    }
    async allFromRepeat(ctx: Context, uid: number, cid: number) {
        return await this._findAll(ctx, this.indexRepeat.directory, [uid, cid]);
    }
    createRepeatStream(uid: number, cid: number, limit: number, after?: string) {
        return this._createStream(this.indexRepeat.directory, [uid, cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Message(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Message');
    }
}
export interface CommentShape {
    peerId: number;
    peerType: 'message';
    parentCommentId?: number| null;
    uid: number;
    text?: string| null;
    reactions?: ({ userId: number, reaction: string, })[]| null;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[]| null;
    attachments?: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[]| null;
    deleted?: boolean| null;
    edited?: boolean| null;
    visible?: boolean| null;
}

export class Comment extends FEntity {
    readonly entityName: 'Comment' = 'Comment';
    get id(): number { return this._value.id; }
    get peerId(): number {
        return this._value.peerId;
    }
    set peerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.peerId) { return; }
        this._value.peerId = value;
        this.markDirty();
    }
    get peerType(): 'message' {
        return this._value.peerType;
    }
    set peerType(value: 'message') {
        this._checkIsWritable();
        if (value === this._value.peerType) { return; }
        this._value.peerType = value;
        this.markDirty();
    }
    get parentCommentId(): number | null {
        let res = this._value.parentCommentId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set parentCommentId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.parentCommentId) { return; }
        this._value.parentCommentId = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get reactions(): ({ userId: number, reaction: string, })[] | null {
        let res = this._value.reactions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set reactions(value: ({ userId: number, reaction: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.reactions) { return; }
        this._value.reactions = value;
        this.markDirty();
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null {
        let res = this._value.spans;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.spans) { return; }
        this._value.spans = value;
        this.markDirty();
    }
    get attachments(): ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null {
        let res = this._value.attachments;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachments(value: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.attachments) { return; }
        this._value.attachments = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get edited(): boolean | null {
        let res = this._value.edited;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set edited(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.edited) { return; }
        this._value.edited = value;
        this.markDirty();
    }
    get visible(): boolean | null {
        let res = this._value.visible;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set visible(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.visible) { return; }
        this._value.visible = value;
        this.markDirty();
    }
}

export class CommentFactory extends FEntityFactory<Comment> {
    static schema: FEntitySchema = {
        name: 'Comment',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'peerId', type: 'number' },
            { name: 'peerType', type: 'enum', enumValues: ['message'] },
            { name: 'parentCommentId', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'text', type: 'string', secure: true },
            { name: 'reactions', type: 'json' },
            { name: 'spans', type: 'json' },
            { name: 'attachments', type: 'json' },
            { name: 'deleted', type: 'boolean' },
            { name: 'edited', type: 'boolean' },
            { name: 'visible', type: 'boolean' },
        ],
        indexes: [
            { name: 'peer', type: 'range', fields: ['peerType', 'peerId', 'id'] },
            { name: 'child', type: 'range', fields: ['parentCommentId', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('comment');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentFactory.validate, hasLiveStreams: false };
        let indexPeer = new FEntityIndex(await layer.resolveEntityIndexDirectory('comment', 'peer'), 'peer', ['peerType', 'peerId', 'id'], false);
        let indexChild = new FEntityIndex(await layer.resolveEntityIndexDirectory('comment', 'child'), 'child', ['parentCommentId', 'id'], false);
        let indexes = {
            peer: indexPeer,
            child: indexChild,
        };
        return new CommentFactory(layer, directory, config, indexes);
    }

    readonly indexPeer: FEntityIndex;
    readonly indexChild: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('peerType', src.peerType);
        validators.isEnum('peerType', src.peerType, ['message']);
        validators.isNumber('parentCommentId', src.parentCommentId);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('text', src.text);
        validators.isJson('reactions', src.reactions, jVec(json(() => {
            jField('userId', jNumber());
            jField('reaction', jString());
        })));
        validators.isJson('spans', src.spans, jVec(jEnum(
            json(() => {
                jField('type', jString('user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('user', jNumber());
            }), 
            json(() => {
                jField('type', jString('multi_user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('users', jVec(jNumber()));
            }), 
            json(() => {
                jField('type', jString('room_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('room', jNumber());
            }), 
            json(() => {
                jField('type', jString('link'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('url', jString());
            }), 
            json(() => {
                jField('type', jString('bold_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('italic_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('irony_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('inline_code_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('code_block_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('insane_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('loud_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('rotating_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('date_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('date', jNumber());
            }), 
            json(() => {
                jField('type', jString('all_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
            })
        )));
        validators.isJson('attachments', src.attachments, jVec(jEnum(
            json(() => {
                jField('type', jString('file_attachment'));
                jField('fileId', jString());
                jField('filePreview', jString()).nullable();
                jField('fileMetadata', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('id', jString());
            }), 
            json(() => {
                jField('type', jString('rich_attachment'));
                jField('title', jString()).nullable();
                jField('subTitle', jString()).nullable();
                jField('titleLink', jString()).nullable();
                jField('text', jString()).nullable();
                jField('icon', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('image', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('iconInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('imageInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('titleLinkHostname', jString()).nullable();
                jField('keyboard', json(() => {
                jField('buttons', jVec(jVec(json(() => {
                jField('title', jString());
                jField('style', jEnumString('DEFAULT', 'LIGHT'));
                jField('url', jString()).nullable();
            }))));
            })).nullable();
                jField('id', jString());
            })
        )));
        validators.isBoolean('deleted', src.deleted);
        validators.isBoolean('edited', src.edited);
        validators.isBoolean('visible', src.visible);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { peer: FEntityIndex, child: FEntityIndex }) {
        super('Comment', 'comment', config, [indexes.peer, indexes.child], layer, directory);
        this.indexPeer = indexes.peer;
        this.indexChild = indexes.child;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: CommentShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: CommentShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromPeerAfter(ctx: Context, peerType: 'message', peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPeer.directory, [peerType, peerId], after);
    }
    async rangeFromPeerAfter(ctx: Context, peerType: 'message', peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPeer.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromPeer(ctx: Context, peerType: 'message', peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPeer.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromPeerWithCursor(ctx: Context, peerType: 'message', peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPeer.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromPeer(ctx: Context, peerType: 'message', peerId: number) {
        return await this._findAll(ctx, this.indexPeer.directory, [peerType, peerId]);
    }
    createPeerStream(peerType: 'message', peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexPeer.directory, [peerType, peerId], limit, after); 
    }
    async allFromChildAfter(ctx: Context, parentCommentId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChild.directory, [parentCommentId], after);
    }
    async rangeFromChildAfter(ctx: Context, parentCommentId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChild.directory, [parentCommentId], after, limit, reversed);
    }
    async rangeFromChild(ctx: Context, parentCommentId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChild.directory, [parentCommentId], limit, reversed);
    }
    async rangeFromChildWithCursor(ctx: Context, parentCommentId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChild.directory, [parentCommentId], limit, after, reversed);
    }
    async allFromChild(ctx: Context, parentCommentId: number) {
        return await this._findAll(ctx, this.indexChild.directory, [parentCommentId]);
    }
    createChildStream(parentCommentId: number, limit: number, after?: string) {
        return this._createStream(this.indexChild.directory, [parentCommentId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Comment(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Comment');
    }
}
export interface CommentStateShape {
    commentsCount: number;
}

export class CommentState extends FEntity {
    readonly entityName: 'CommentState' = 'CommentState';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get commentsCount(): number {
        return this._value.commentsCount;
    }
    set commentsCount(value: number) {
        this._checkIsWritable();
        if (value === this._value.commentsCount) { return; }
        this._value.commentsCount = value;
        this.markDirty();
    }
}

export class CommentStateFactory extends FEntityFactory<CommentState> {
    static schema: FEntitySchema = {
        name: 'CommentState',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
        ],
        fields: [
            { name: 'commentsCount', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentState');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentStateFactory.validate, hasLiveStreams: false };
        return new CommentStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('commentsCount', src.commentsCount);
        validators.isNumber('commentsCount', src.commentsCount);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('CommentState', 'commentState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1] };
    }
    async findById(ctx: Context, peerType: string, peerId: number) {
        return await this._findById(ctx, [peerType, peerId]);
    }
    async create(ctx: Context, peerType: string, peerId: number, shape: CommentStateShape) {
        return await this._create(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, shape: CommentStateShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number) {
        return this._watch(ctx, [peerType, peerId]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentState(ctx, this.layer, this.directory, [value.peerType, value.peerId], value, this.options, isNew, this.indexes, 'CommentState');
    }
}
export interface CommentSeqShape {
    seq: number;
}

export class CommentSeq extends FEntity {
    readonly entityName: 'CommentSeq' = 'CommentSeq';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class CommentSeqFactory extends FEntityFactory<CommentSeq> {
    static schema: FEntitySchema = {
        name: 'CommentSeq',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentSeq');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentSeqFactory.validate, hasLiveStreams: false };
        return new CommentSeqFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('CommentSeq', 'commentSeq', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1] };
    }
    async findById(ctx: Context, peerType: string, peerId: number) {
        return await this._findById(ctx, [peerType, peerId]);
    }
    async create(ctx: Context, peerType: string, peerId: number, shape: CommentSeqShape) {
        return await this._create(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, shape: CommentSeqShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number) {
        return this._watch(ctx, [peerType, peerId]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentSeq(ctx, this.layer, this.directory, [value.peerType, value.peerId], value, this.options, isNew, this.indexes, 'CommentSeq');
    }
}
export interface CommentEventShape {
    uid?: number| null;
    commentId?: number| null;
    kind: 'comment_received' | 'comment_updated';
}

export class CommentEvent extends FEntity {
    readonly entityName: 'CommentEvent' = 'CommentEvent';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get seq(): number { return this._value.seq; }
    get uid(): number | null {
        let res = this._value.uid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set uid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get commentId(): number | null {
        let res = this._value.commentId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set commentId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.commentId) { return; }
        this._value.commentId = value;
        this.markDirty();
    }
    get kind(): 'comment_received' | 'comment_updated' {
        return this._value.kind;
    }
    set kind(value: 'comment_received' | 'comment_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class CommentEventFactory extends FEntityFactory<CommentEvent> {
    static schema: FEntitySchema = {
        name: 'CommentEvent',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'commentId', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['comment_received', 'comment_updated'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['peerType', 'peerId', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentEventFactory.validate, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentEvent', 'user'), 'user', ['peerType', 'peerId', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new CommentEventFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('uid', src.uid);
        validators.isNumber('commentId', src.commentId);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['comment_received', 'comment_updated']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('CommentEvent', 'commentEvent', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 3) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1], 'seq': rawId[2] };
    }
    async findById(ctx: Context, peerType: string, peerId: number, seq: number) {
        return await this._findById(ctx, [peerType, peerId, seq]);
    }
    async create(ctx: Context, peerType: string, peerId: number, seq: number, shape: CommentEventShape) {
        return await this._create(ctx, [peerType, peerId, seq], { peerType, peerId, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, seq: number, shape: CommentEventShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId, seq], { peerType, peerId, seq, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number, seq: number) {
        return this._watch(ctx, [peerType, peerId, seq]);
    }
    async allFromUserAfter(ctx: Context, peerType: string, peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [peerType, peerId], after);
    }
    async rangeFromUserAfter(ctx: Context, peerType: string, peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, peerType: string, peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, peerType: string, peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromUser(ctx: Context, peerType: string, peerId: number) {
        return await this._findAll(ctx, this.indexUser.directory, [peerType, peerId]);
    }
    createUserStream(peerType: string, peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [peerType, peerId], limit, after); 
    }
    createUserLiveStream(ctx: Context, peerType: string, peerId: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [peerType, peerId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentEvent(ctx, this.layer, this.directory, [value.peerType, value.peerId, value.seq], value, this.options, isNew, this.indexes, 'CommentEvent');
    }
}
export interface CommentsSubscriptionShape {
    kind: 'all' | 'direct';
    status: 'active' | 'disabled';
}

export class CommentsSubscription extends FEntity {
    readonly entityName: 'CommentsSubscription' = 'CommentsSubscription';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get uid(): number { return this._value.uid; }
    get kind(): 'all' | 'direct' {
        return this._value.kind;
    }
    set kind(value: 'all' | 'direct') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get status(): 'active' | 'disabled' {
        return this._value.status;
    }
    set status(value: 'active' | 'disabled') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class CommentsSubscriptionFactory extends FEntityFactory<CommentsSubscription> {
    static schema: FEntitySchema = {
        name: 'CommentsSubscription',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['all', 'direct'] },
            { name: 'status', type: 'enum', enumValues: ['active', 'disabled'] },
        ],
        indexes: [
            { name: 'peer', type: 'range', fields: ['peerType', 'peerId', 'uid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentsSubscription');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentsSubscriptionFactory.validate, hasLiveStreams: false };
        let indexPeer = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentsSubscription', 'peer'), 'peer', ['peerType', 'peerId', 'uid'], false);
        let indexes = {
            peer: indexPeer,
        };
        return new CommentsSubscriptionFactory(layer, directory, config, indexes);
    }

    readonly indexPeer: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['all', 'direct']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['active', 'disabled']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { peer: FEntityIndex }) {
        super('CommentsSubscription', 'commentsSubscription', config, [indexes.peer], layer, directory);
        this.indexPeer = indexes.peer;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 3) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1], 'uid': rawId[2] };
    }
    async findById(ctx: Context, peerType: string, peerId: number, uid: number) {
        return await this._findById(ctx, [peerType, peerId, uid]);
    }
    async create(ctx: Context, peerType: string, peerId: number, uid: number, shape: CommentsSubscriptionShape) {
        return await this._create(ctx, [peerType, peerId, uid], { peerType, peerId, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, uid: number, shape: CommentsSubscriptionShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId, uid], { peerType, peerId, uid, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number, uid: number) {
        return this._watch(ctx, [peerType, peerId, uid]);
    }
    async allFromPeerAfter(ctx: Context, peerType: string, peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPeer.directory, [peerType, peerId], after);
    }
    async rangeFromPeerAfter(ctx: Context, peerType: string, peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPeer.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromPeer(ctx: Context, peerType: string, peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPeer.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromPeerWithCursor(ctx: Context, peerType: string, peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPeer.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromPeer(ctx: Context, peerType: string, peerId: number) {
        return await this._findAll(ctx, this.indexPeer.directory, [peerType, peerId]);
    }
    createPeerStream(peerType: string, peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexPeer.directory, [peerType, peerId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentsSubscription(ctx, this.layer, this.directory, [value.peerType, value.peerId, value.uid], value, this.options, isNew, this.indexes, 'CommentsSubscription');
    }
}
export interface CommentEventGlobalShape {
    peerType?: string| null;
    peerId?: number| null;
    kind: 'comments_peer_updated';
}

export class CommentEventGlobal extends FEntity {
    readonly entityName: 'CommentEventGlobal' = 'CommentEventGlobal';
    get uid(): number { return this._value.uid; }
    get seq(): number { return this._value.seq; }
    get peerType(): string | null {
        let res = this._value.peerType;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set peerType(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.peerType) { return; }
        this._value.peerType = value;
        this.markDirty();
    }
    get peerId(): number | null {
        let res = this._value.peerId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set peerId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.peerId) { return; }
        this._value.peerId = value;
        this.markDirty();
    }
    get kind(): 'comments_peer_updated' {
        return this._value.kind;
    }
    set kind(value: 'comments_peer_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class CommentEventGlobalFactory extends FEntityFactory<CommentEventGlobal> {
    static schema: FEntitySchema = {
        name: 'CommentEventGlobal',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['comments_peer_updated'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentEventGlobal');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentEventGlobalFactory.validate, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentEventGlobal', 'user'), 'user', ['uid', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new CommentEventGlobalFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isString('peerType', src.peerType);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['comments_peer_updated']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('CommentEventGlobal', 'commentEventGlobal', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, uid: number, seq: number) {
        return await this._findById(ctx, [uid, seq]);
    }
    async create(ctx: Context, uid: number, seq: number, shape: CommentEventGlobalShape) {
        return await this._create(ctx, [uid, seq], { uid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, seq: number, shape: CommentEventGlobalShape) {
        return await this._create_UNSAFE(ctx, [uid, seq], { uid, seq, ...shape });
    }
    watch(ctx: Context, uid: number, seq: number) {
        return this._watch(ctx, [uid, seq]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    createUserLiveStream(ctx: Context, uid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentEventGlobal(ctx, this.layer, this.directory, [value.uid, value.seq], value, this.options, isNew, this.indexes, 'CommentEventGlobal');
    }
}
export interface CommentGlobalEventSeqShape {
    seq: number;
}

export class CommentGlobalEventSeq extends FEntity {
    readonly entityName: 'CommentGlobalEventSeq' = 'CommentGlobalEventSeq';
    get uid(): number { return this._value.uid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class CommentGlobalEventSeqFactory extends FEntityFactory<CommentGlobalEventSeq> {
    static schema: FEntitySchema = {
        name: 'CommentGlobalEventSeq',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentGlobalEventSeq');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentGlobalEventSeqFactory.validate, hasLiveStreams: false };
        return new CommentGlobalEventSeqFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('CommentGlobalEventSeq', 'commentGlobalEventSeq', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: CommentGlobalEventSeqShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: CommentGlobalEventSeqShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentGlobalEventSeq(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'CommentGlobalEventSeq');
    }
}
export interface ConversationSeqShape {
    seq: number;
}

export class ConversationSeq extends FEntity {
    readonly entityName: 'ConversationSeq' = 'ConversationSeq';
    get cid(): number { return this._value.cid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class ConversationSeqFactory extends FEntityFactory<ConversationSeq> {
    static schema: FEntitySchema = {
        name: 'ConversationSeq',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationSeq');
        let config = { enableVersioning: false, enableTimestamps: false, validator: ConversationSeqFactory.validate, hasLiveStreams: false };
        return new ConversationSeqFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('ConversationSeq', 'conversationSeq', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0] };
    }
    async findById(ctx: Context, cid: number) {
        return await this._findById(ctx, [cid]);
    }
    async create(ctx: Context, cid: number, shape: ConversationSeqShape) {
        return await this._create(ctx, [cid], { cid, ...shape });
    }
    async create_UNSAFE(ctx: Context, cid: number, shape: ConversationSeqShape) {
        return await this._create_UNSAFE(ctx, [cid], { cid, ...shape });
    }
    watch(ctx: Context, cid: number) {
        return this._watch(ctx, [cid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationSeq(ctx, this.layer, this.directory, [value.cid], value, this.options, isNew, this.indexes, 'ConversationSeq');
    }
}
export interface ConversationEventShape {
    uid?: number| null;
    mid?: number| null;
    kind: 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted';
}

export class ConversationEvent extends FEntity {
    readonly entityName: 'ConversationEvent' = 'ConversationEvent';
    get cid(): number { return this._value.cid; }
    get seq(): number { return this._value.seq; }
    get uid(): number | null {
        let res = this._value.uid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set uid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get mid(): number | null {
        let res = this._value.mid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.mid) { return; }
        this._value.mid = value;
        this.markDirty();
    }
    get kind(): 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted' {
        return this._value.kind;
    }
    set kind(value: 'chat_updated' | 'message_received' | 'message_updated' | 'message_deleted') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class ConversationEventFactory extends FEntityFactory<ConversationEvent> {
    static schema: FEntitySchema = {
        name: 'ConversationEvent',
        editable: false,
        primaryKeys: [
            { name: 'cid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'mid', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['chat_updated', 'message_received', 'message_updated', 'message_deleted'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['cid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conversationEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConversationEventFactory.validate, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('conversationEvent', 'user'), 'user', ['cid', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new ConversationEventFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('uid', src.uid);
        validators.isNumber('mid', src.mid);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['chat_updated', 'message_received', 'message_updated', 'message_deleted']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('ConversationEvent', 'conversationEvent', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'cid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, cid: number, seq: number) {
        return await this._findById(ctx, [cid, seq]);
    }
    async create(ctx: Context, cid: number, seq: number, shape: ConversationEventShape) {
        return await this._create(ctx, [cid, seq], { cid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, cid: number, seq: number, shape: ConversationEventShape) {
        return await this._create_UNSAFE(ctx, [cid, seq], { cid, seq, ...shape });
    }
    watch(ctx: Context, cid: number, seq: number) {
        return this._watch(ctx, [cid, seq]);
    }
    async allFromUserAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [cid], after);
    }
    async rangeFromUserAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [cid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [cid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [cid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [cid]);
    }
    createUserStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [cid], limit, after); 
    }
    createUserLiveStream(ctx: Context, cid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConversationEvent(ctx, this.layer, this.directory, [value.cid, value.seq], value, this.options, isNew, this.indexes, 'ConversationEvent');
    }
}
export interface UserDialogShape {
    unread: number;
    readMessageId?: number| null;
    date?: number| null;
    haveMention?: boolean| null;
    title?: string| null;
    photo?: any| null;
    hidden?: boolean| null;
    disableGlobalCounter?: boolean| null;
}

export class UserDialog extends FEntity {
    readonly entityName: 'UserDialog' = 'UserDialog';
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get unread(): number {
        return this._value.unread;
    }
    set unread(value: number) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
    get readMessageId(): number | null {
        let res = this._value.readMessageId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readMessageId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readMessageId) { return; }
        this._value.readMessageId = value;
        this.markDirty();
    }
    get date(): number | null {
        let res = this._value.date;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set date(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.date) { return; }
        this._value.date = value;
        this.markDirty();
    }
    get haveMention(): boolean | null {
        let res = this._value.haveMention;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set haveMention(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.haveMention) { return; }
        this._value.haveMention = value;
        this.markDirty();
    }
    get title(): string | null {
        let res = this._value.title;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set title(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get photo(): any | null {
        let res = this._value.photo;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set photo(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.photo) { return; }
        this._value.photo = value;
        this.markDirty();
    }
    get hidden(): boolean | null {
        let res = this._value.hidden;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set hidden(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.hidden) { return; }
        this._value.hidden = value;
        this.markDirty();
    }
    get disableGlobalCounter(): boolean | null {
        let res = this._value.disableGlobalCounter;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set disableGlobalCounter(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.disableGlobalCounter) { return; }
        this._value.disableGlobalCounter = value;
        this.markDirty();
    }
}

export class UserDialogFactory extends FEntityFactory<UserDialog> {
    static schema: FEntitySchema = {
        name: 'UserDialog',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'unread', type: 'number' },
            { name: 'readMessageId', type: 'number' },
            { name: 'date', type: 'number' },
            { name: 'haveMention', type: 'boolean' },
            { name: 'title', type: 'string' },
            { name: 'photo', type: 'json' },
            { name: 'hidden', type: 'boolean' },
            { name: 'disableGlobalCounter', type: 'boolean' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'date'], displayName: 'dialogsForUser' },
            { name: 'conversation', type: 'unique', fields: ['cid', 'uid'] },
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userDialog');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserDialogFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('userDialog', 'user'), 'user', ['uid', 'date'], false, (src) => !!src.date && !src.hidden);
        let indexConversation = new FEntityIndex(await layer.resolveEntityIndexDirectory('userDialog', 'conversation'), 'conversation', ['cid', 'uid'], true);
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('userDialog', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            user: indexUser,
            conversation: indexConversation,
            updated: indexUpdated,
        };
        return new UserDialogFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;
    readonly indexConversation: FEntityIndex;
    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('unread', src.unread);
        validators.isNumber('unread', src.unread);
        validators.isNumber('readMessageId', src.readMessageId);
        validators.isNumber('date', src.date);
        validators.isBoolean('haveMention', src.haveMention);
        validators.isString('title', src.title);
        validators.isBoolean('hidden', src.hidden);
        validators.isBoolean('disableGlobalCounter', src.disableGlobalCounter);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex, conversation: FEntityIndex, updated: FEntityIndex }) {
        super('UserDialog', 'userDialog', config, [indexes.user, indexes.conversation, indexes.updated], layer, directory);
        this.indexUser = indexes.user;
        this.indexConversation = indexes.conversation;
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(ctx: Context, uid: number, cid: number) {
        return await this._findById(ctx, [uid, cid]);
    }
    async create(ctx: Context, uid: number, cid: number, shape: UserDialogShape) {
        return await this._create(ctx, [uid, cid], { uid, cid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, cid: number, shape: UserDialogShape) {
        return await this._create_UNSAFE(ctx, [uid, cid], { uid, cid, ...shape });
    }
    watch(ctx: Context, uid: number, cid: number) {
        return this._watch(ctx, [uid, cid]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    async findFromConversation(ctx: Context, cid: number, uid: number) {
        return await this._findFromIndex(ctx, this.indexConversation.directory, [cid, uid]);
    }
    async allFromConversationAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexConversation.directory, [cid], after);
    }
    async rangeFromConversationAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexConversation.directory, [cid], after, limit, reversed);
    }
    async rangeFromConversation(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexConversation.directory, [cid], limit, reversed);
    }
    async rangeFromConversationWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexConversation.directory, [cid], limit, after, reversed);
    }
    async allFromConversation(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexConversation.directory, [cid]);
    }
    createConversationStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexConversation.directory, [cid], limit, after); 
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserDialog(ctx, this.layer, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'UserDialog');
    }
}
export interface UserDialogHandledMessageShape {
}

export class UserDialogHandledMessage extends FEntity {
    readonly entityName: 'UserDialogHandledMessage' = 'UserDialogHandledMessage';
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get mid(): number { return this._value.mid; }
}

export class UserDialogHandledMessageFactory extends FEntityFactory<UserDialogHandledMessage> {
    static schema: FEntitySchema = {
        name: 'UserDialogHandledMessage',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
            { name: 'mid', type: 'number' },
        ],
        fields: [
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userDialogHandledMessage');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserDialogHandledMessageFactory.validate, hasLiveStreams: false };
        return new UserDialogHandledMessageFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('mid', src.mid);
        validators.isNumber('mid', src.mid);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserDialogHandledMessage', 'userDialogHandledMessage', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 3) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1], 'mid': rawId[2] };
    }
    async findById(ctx: Context, uid: number, cid: number, mid: number) {
        return await this._findById(ctx, [uid, cid, mid]);
    }
    async create(ctx: Context, uid: number, cid: number, mid: number, shape: UserDialogHandledMessageShape) {
        return await this._create(ctx, [uid, cid, mid], { uid, cid, mid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, cid: number, mid: number, shape: UserDialogHandledMessageShape) {
        return await this._create_UNSAFE(ctx, [uid, cid, mid], { uid, cid, mid, ...shape });
    }
    watch(ctx: Context, uid: number, cid: number, mid: number) {
        return this._watch(ctx, [uid, cid, mid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserDialogHandledMessage(ctx, this.layer, this.directory, [value.uid, value.cid, value.mid], value, this.options, isNew, this.indexes, 'UserDialogHandledMessage');
    }
}
export interface UserDialogSettingsShape {
    mute: boolean;
}

export class UserDialogSettings extends FEntity {
    readonly entityName: 'UserDialogSettings' = 'UserDialogSettings';
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get mute(): boolean {
        return this._value.mute;
    }
    set mute(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.mute) { return; }
        this._value.mute = value;
        this.markDirty();
    }
}

export class UserDialogSettingsFactory extends FEntityFactory<UserDialogSettings> {
    static schema: FEntitySchema = {
        name: 'UserDialogSettings',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'mute', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userDialogSettings');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserDialogSettingsFactory.validate, hasLiveStreams: false };
        return new UserDialogSettingsFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('mute', src.mute);
        validators.isBoolean('mute', src.mute);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserDialogSettings', 'userDialogSettings', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(ctx: Context, uid: number, cid: number) {
        return await this._findById(ctx, [uid, cid]);
    }
    async create(ctx: Context, uid: number, cid: number, shape: UserDialogSettingsShape) {
        return await this._create(ctx, [uid, cid], { uid, cid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, cid: number, shape: UserDialogSettingsShape) {
        return await this._create_UNSAFE(ctx, [uid, cid], { uid, cid, ...shape });
    }
    watch(ctx: Context, uid: number, cid: number) {
        return this._watch(ctx, [uid, cid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserDialogSettings(ctx, this.layer, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'UserDialogSettings');
    }
}
export interface UserDialogEventShape {
    cid?: number| null;
    mid?: number| null;
    allUnread?: number| null;
    unread?: number| null;
    title?: string| null;
    photo?: any| null;
    mute?: boolean| null;
    haveMention?: boolean| null;
    kind: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed';
}

export class UserDialogEvent extends FEntity {
    readonly entityName: 'UserDialogEvent' = 'UserDialogEvent';
    get uid(): number { return this._value.uid; }
    get seq(): number { return this._value.seq; }
    get cid(): number | null {
        let res = this._value.cid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set cid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get mid(): number | null {
        let res = this._value.mid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.mid) { return; }
        this._value.mid = value;
        this.markDirty();
    }
    get allUnread(): number | null {
        let res = this._value.allUnread;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set allUnread(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.allUnread) { return; }
        this._value.allUnread = value;
        this.markDirty();
    }
    get unread(): number | null {
        let res = this._value.unread;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set unread(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
    get title(): string | null {
        let res = this._value.title;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set title(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get photo(): any | null {
        let res = this._value.photo;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set photo(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.photo) { return; }
        this._value.photo = value;
        this.markDirty();
    }
    get mute(): boolean | null {
        let res = this._value.mute;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mute(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.mute) { return; }
        this._value.mute = value;
        this.markDirty();
    }
    get haveMention(): boolean | null {
        let res = this._value.haveMention;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set haveMention(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.haveMention) { return; }
        this._value.haveMention = value;
        this.markDirty();
    }
    get kind(): 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed' {
        return this._value.kind;
    }
    set kind(value: 'message_received' | 'message_updated' | 'message_deleted' | 'message_read' | 'title_updated' | 'dialog_deleted' | 'dialog_bump' | 'photo_updated' | 'dialog_mute_changed' | 'dialog_mentioned_changed') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class UserDialogEventFactory extends FEntityFactory<UserDialogEvent> {
    static schema: FEntitySchema = {
        name: 'UserDialogEvent',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'mid', type: 'number' },
            { name: 'allUnread', type: 'number' },
            { name: 'unread', type: 'number' },
            { name: 'title', type: 'string' },
            { name: 'photo', type: 'json' },
            { name: 'mute', type: 'boolean' },
            { name: 'haveMention', type: 'boolean' },
            { name: 'kind', type: 'enum', enumValues: ['message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated', 'dialog_deleted', 'dialog_bump', 'photo_updated', 'dialog_mute_changed', 'dialog_mentioned_changed'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userDialogEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserDialogEventFactory.validate, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('userDialogEvent', 'user'), 'user', ['uid', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new UserDialogEventFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('cid', src.cid);
        validators.isNumber('mid', src.mid);
        validators.isNumber('allUnread', src.allUnread);
        validators.isNumber('unread', src.unread);
        validators.isString('title', src.title);
        validators.isBoolean('mute', src.mute);
        validators.isBoolean('haveMention', src.haveMention);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['message_received', 'message_updated', 'message_deleted', 'message_read', 'title_updated', 'dialog_deleted', 'dialog_bump', 'photo_updated', 'dialog_mute_changed', 'dialog_mentioned_changed']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('UserDialogEvent', 'userDialogEvent', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, uid: number, seq: number) {
        return await this._findById(ctx, [uid, seq]);
    }
    async create(ctx: Context, uid: number, seq: number, shape: UserDialogEventShape) {
        return await this._create(ctx, [uid, seq], { uid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, seq: number, shape: UserDialogEventShape) {
        return await this._create_UNSAFE(ctx, [uid, seq], { uid, seq, ...shape });
    }
    watch(ctx: Context, uid: number, seq: number) {
        return this._watch(ctx, [uid, seq]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    createUserLiveStream(ctx: Context, uid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserDialogEvent(ctx, this.layer, this.directory, [value.uid, value.seq], value, this.options, isNew, this.indexes, 'UserDialogEvent');
    }
}
export interface UserMessagingStateShape {
    seq: number;
    unread: number;
    messagesSent?: number| null;
    messagesReceived?: number| null;
    chatsCount?: number| null;
    directChatsCount?: number| null;
}

export class UserMessagingState extends FEntity {
    readonly entityName: 'UserMessagingState' = 'UserMessagingState';
    get uid(): number { return this._value.uid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
    get unread(): number {
        return this._value.unread;
    }
    set unread(value: number) {
        this._checkIsWritable();
        if (value === this._value.unread) { return; }
        this._value.unread = value;
        this.markDirty();
    }
    get messagesSent(): number | null {
        let res = this._value.messagesSent;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set messagesSent(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.messagesSent) { return; }
        this._value.messagesSent = value;
        this.markDirty();
    }
    get messagesReceived(): number | null {
        let res = this._value.messagesReceived;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set messagesReceived(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.messagesReceived) { return; }
        this._value.messagesReceived = value;
        this.markDirty();
    }
    get chatsCount(): number | null {
        let res = this._value.chatsCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set chatsCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.chatsCount) { return; }
        this._value.chatsCount = value;
        this.markDirty();
    }
    get directChatsCount(): number | null {
        let res = this._value.directChatsCount;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set directChatsCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.directChatsCount) { return; }
        this._value.directChatsCount = value;
        this.markDirty();
    }
}

export class UserMessagingStateFactory extends FEntityFactory<UserMessagingState> {
    static schema: FEntitySchema = {
        name: 'UserMessagingState',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
            { name: 'unread', type: 'number' },
            { name: 'messagesSent', type: 'number' },
            { name: 'messagesReceived', type: 'number' },
            { name: 'chatsCount', type: 'number' },
            { name: 'directChatsCount', type: 'number' },
        ],
        indexes: [
            { name: 'hasUnread', type: 'range', fields: [] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userMessagingState');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserMessagingStateFactory.validate, hasLiveStreams: false };
        let indexHasUnread = new FEntityIndex(await layer.resolveEntityIndexDirectory('userMessagingState', 'hasUnread'), 'hasUnread', [], false, (src) => src.unread && src.unread > 0);
        let indexes = {
            hasUnread: indexHasUnread,
        };
        return new UserMessagingStateFactory(layer, directory, config, indexes);
    }

    readonly indexHasUnread: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.notNull('unread', src.unread);
        validators.isNumber('unread', src.unread);
        validators.isNumber('messagesSent', src.messagesSent);
        validators.isNumber('messagesReceived', src.messagesReceived);
        validators.isNumber('chatsCount', src.chatsCount);
        validators.isNumber('directChatsCount', src.directChatsCount);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { hasUnread: FEntityIndex }) {
        super('UserMessagingState', 'userMessagingState', config, [indexes.hasUnread], layer, directory);
        this.indexHasUnread = indexes.hasUnread;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: UserMessagingStateShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: UserMessagingStateShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    async rangeFromHasUnread(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexHasUnread.directory, [], limit, reversed);
    }
    async rangeFromHasUnreadWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexHasUnread.directory, [], limit, after, reversed);
    }
    async allFromHasUnread(ctx: Context, ) {
        return await this._findAll(ctx, this.indexHasUnread.directory, []);
    }
    createHasUnreadStream(limit: number, after?: string) {
        return this._createStream(this.indexHasUnread.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserMessagingState(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserMessagingState');
    }
}
export interface UserNotificationsStateShape {
    readSeq?: number| null;
    lastEmailNotification?: number| null;
    lastPushNotification?: number| null;
    lastEmailSeq?: number| null;
    lastPushSeq?: number| null;
}

export class UserNotificationsState extends FEntity {
    readonly entityName: 'UserNotificationsState' = 'UserNotificationsState';
    get uid(): number { return this._value.uid; }
    get readSeq(): number | null {
        let res = this._value.readSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readSeq) { return; }
        this._value.readSeq = value;
        this.markDirty();
    }
    get lastEmailNotification(): number | null {
        let res = this._value.lastEmailNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailNotification) { return; }
        this._value.lastEmailNotification = value;
        this.markDirty();
    }
    get lastPushNotification(): number | null {
        let res = this._value.lastPushNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushNotification) { return; }
        this._value.lastPushNotification = value;
        this.markDirty();
    }
    get lastEmailSeq(): number | null {
        let res = this._value.lastEmailSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailSeq) { return; }
        this._value.lastEmailSeq = value;
        this.markDirty();
    }
    get lastPushSeq(): number | null {
        let res = this._value.lastPushSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushSeq) { return; }
        this._value.lastPushSeq = value;
        this.markDirty();
    }
}

export class UserNotificationsStateFactory extends FEntityFactory<UserNotificationsState> {
    static schema: FEntitySchema = {
        name: 'UserNotificationsState',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'readSeq', type: 'number' },
            { name: 'lastEmailNotification', type: 'number' },
            { name: 'lastPushNotification', type: 'number' },
            { name: 'lastEmailSeq', type: 'number' },
            { name: 'lastPushSeq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userNotificationsState');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserNotificationsStateFactory.validate, hasLiveStreams: false };
        return new UserNotificationsStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isNumber('readSeq', src.readSeq);
        validators.isNumber('lastEmailNotification', src.lastEmailNotification);
        validators.isNumber('lastPushNotification', src.lastPushNotification);
        validators.isNumber('lastEmailSeq', src.lastEmailSeq);
        validators.isNumber('lastPushSeq', src.lastPushSeq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserNotificationsState', 'userNotificationsState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: UserNotificationsStateShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: UserNotificationsStateShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserNotificationsState(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserNotificationsState');
    }
}
export interface HyperLogShape {
    type: string;
    date: number;
    body: any;
}

export class HyperLog extends FEntity {
    readonly entityName: 'HyperLog' = 'HyperLog';
    get id(): string { return this._value.id; }
    get type(): string {
        return this._value.type;
    }
    set type(value: string) {
        this._checkIsWritable();
        if (value === this._value.type) { return; }
        this._value.type = value;
        this.markDirty();
    }
    get date(): number {
        return this._value.date;
    }
    set date(value: number) {
        this._checkIsWritable();
        if (value === this._value.date) { return; }
        this._value.date = value;
        this.markDirty();
    }
    get body(): any {
        return this._value.body;
    }
    set body(value: any) {
        this._checkIsWritable();
        if (value === this._value.body) { return; }
        this._value.body = value;
        this.markDirty();
    }
}

export class HyperLogFactory extends FEntityFactory<HyperLog> {
    static schema: FEntitySchema = {
        name: 'HyperLog',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'type', type: 'string' },
            { name: 'date', type: 'number' },
            { name: 'body', type: 'json' },
        ],
        indexes: [
            { name: 'created', type: 'range', fields: ['createdAt'] },
            { name: 'userEvents', type: 'range', fields: ['createdAt'], displayName: 'userEvents' },
            { name: 'onlineChangeEvents', type: 'range', fields: ['createdAt'], displayName: 'onlineChangeEvents' },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('hyperLog');
        let config = { enableVersioning: false, enableTimestamps: true, validator: HyperLogFactory.validate, hasLiveStreams: false };
        let indexCreated = new FEntityIndex(await layer.resolveEntityIndexDirectory('hyperLog', 'created'), 'created', ['createdAt'], false);
        let indexUserEvents = new FEntityIndex(await layer.resolveEntityIndexDirectory('hyperLog', 'userEvents'), 'userEvents', ['createdAt'], false, (src) => src.type === 'track');
        let indexOnlineChangeEvents = new FEntityIndex(await layer.resolveEntityIndexDirectory('hyperLog', 'onlineChangeEvents'), 'onlineChangeEvents', ['createdAt'], false, (src) => src.type === 'online_status');
        let indexes = {
            created: indexCreated,
            userEvents: indexUserEvents,
            onlineChangeEvents: indexOnlineChangeEvents,
        };
        return new HyperLogFactory(layer, directory, config, indexes);
    }

    readonly indexCreated: FEntityIndex;
    readonly indexUserEvents: FEntityIndex;
    readonly indexOnlineChangeEvents: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('type', src.type);
        validators.isString('type', src.type);
        validators.notNull('date', src.date);
        validators.isNumber('date', src.date);
        validators.notNull('body', src.body);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { created: FEntityIndex, userEvents: FEntityIndex, onlineChangeEvents: FEntityIndex }) {
        super('HyperLog', 'hyperLog', config, [indexes.created, indexes.userEvents, indexes.onlineChangeEvents], layer, directory);
        this.indexCreated = indexes.created;
        this.indexUserEvents = indexes.userEvents;
        this.indexOnlineChangeEvents = indexes.onlineChangeEvents;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: HyperLogShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: HyperLogShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async rangeFromCreated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexCreated.directory, [], limit, reversed);
    }
    async rangeFromCreatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexCreated.directory, [], limit, after, reversed);
    }
    async allFromCreated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexCreated.directory, []);
    }
    createCreatedStream(limit: number, after?: string) {
        return this._createStream(this.indexCreated.directory, [], limit, after); 
    }
    async rangeFromUserEvents(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUserEvents.directory, [], limit, reversed);
    }
    async rangeFromUserEventsWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUserEvents.directory, [], limit, after, reversed);
    }
    async allFromUserEvents(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUserEvents.directory, []);
    }
    createUserEventsStream(limit: number, after?: string) {
        return this._createStream(this.indexUserEvents.directory, [], limit, after); 
    }
    async rangeFromOnlineChangeEvents(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOnlineChangeEvents.directory, [], limit, reversed);
    }
    async rangeFromOnlineChangeEventsWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOnlineChangeEvents.directory, [], limit, after, reversed);
    }
    async allFromOnlineChangeEvents(ctx: Context, ) {
        return await this._findAll(ctx, this.indexOnlineChangeEvents.directory, []);
    }
    createOnlineChangeEventsStream(limit: number, after?: string) {
        return this._createStream(this.indexOnlineChangeEvents.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new HyperLog(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'HyperLog');
    }
}
export interface MessageDraftShape {
    contents: string;
}

export class MessageDraft extends FEntity {
    readonly entityName: 'MessageDraft' = 'MessageDraft';
    get uid(): number { return this._value.uid; }
    get cid(): number { return this._value.cid; }
    get contents(): string {
        return this._value.contents;
    }
    set contents(value: string) {
        this._checkIsWritable();
        if (value === this._value.contents) { return; }
        this._value.contents = value;
        this.markDirty();
    }
}

export class MessageDraftFactory extends FEntityFactory<MessageDraft> {
    static schema: FEntitySchema = {
        name: 'MessageDraft',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'cid', type: 'number' },
        ],
        fields: [
            { name: 'contents', type: 'string', secure: true },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('messageDraft');
        let config = { enableVersioning: true, enableTimestamps: true, validator: MessageDraftFactory.validate, hasLiveStreams: false };
        return new MessageDraftFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('contents', src.contents);
        validators.isString('contents', src.contents);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('MessageDraft', 'messageDraft', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'cid': rawId[1] };
    }
    async findById(ctx: Context, uid: number, cid: number) {
        return await this._findById(ctx, [uid, cid]);
    }
    async create(ctx: Context, uid: number, cid: number, shape: MessageDraftShape) {
        return await this._create(ctx, [uid, cid], { uid, cid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, cid: number, shape: MessageDraftShape) {
        return await this._create_UNSAFE(ctx, [uid, cid], { uid, cid, ...shape });
    }
    watch(ctx: Context, uid: number, cid: number) {
        return this._watch(ctx, [uid, cid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new MessageDraft(ctx, this.layer, this.directory, [value.uid, value.cid], value, this.options, isNew, this.indexes, 'MessageDraft');
    }
}
export interface ChannelInvitationShape {
    creatorId: number;
    channelId: number;
    email: string;
    firstName?: string| null;
    lastName?: string| null;
    text?: string| null;
    acceptedById?: number| null;
    enabled: boolean;
}

export class ChannelInvitation extends FEntity {
    readonly entityName: 'ChannelInvitation' = 'ChannelInvitation';
    get id(): string { return this._value.id; }
    get creatorId(): number {
        return this._value.creatorId;
    }
    set creatorId(value: number) {
        this._checkIsWritable();
        if (value === this._value.creatorId) { return; }
        this._value.creatorId = value;
        this.markDirty();
    }
    get channelId(): number {
        return this._value.channelId;
    }
    set channelId(value: number) {
        this._checkIsWritable();
        if (value === this._value.channelId) { return; }
        this._value.channelId = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get acceptedById(): number | null {
        let res = this._value.acceptedById;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set acceptedById(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.acceptedById) { return; }
        this._value.acceptedById = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ChannelInvitationFactory extends FEntityFactory<ChannelInvitation> {
    static schema: FEntitySchema = {
        name: 'ChannelInvitation',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'creatorId', type: 'number' },
            { name: 'channelId', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'text', type: 'string' },
            { name: 'acceptedById', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'channel', type: 'range', fields: ['createdAt', 'channelId'] },
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('channelInvitation');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ChannelInvitationFactory.validate, hasLiveStreams: false };
        let indexChannel = new FEntityIndex(await layer.resolveEntityIndexDirectory('channelInvitation', 'channel'), 'channel', ['createdAt', 'channelId'], false);
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('channelInvitation', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            channel: indexChannel,
            updated: indexUpdated,
        };
        return new ChannelInvitationFactory(layer, directory, config, indexes);
    }

    readonly indexChannel: FEntityIndex;
    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('creatorId', src.creatorId);
        validators.isNumber('creatorId', src.creatorId);
        validators.notNull('channelId', src.channelId);
        validators.isNumber('channelId', src.channelId);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('text', src.text);
        validators.isNumber('acceptedById', src.acceptedById);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { channel: FEntityIndex, updated: FEntityIndex }) {
        super('ChannelInvitation', 'channelInvitation', config, [indexes.channel, indexes.updated], layer, directory);
        this.indexChannel = indexes.channel;
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: ChannelInvitationShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: ChannelInvitationShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromChannelAfter(ctx: Context, createdAt: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChannel.directory, [createdAt], after);
    }
    async rangeFromChannelAfter(ctx: Context, createdAt: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChannel.directory, [createdAt], after, limit, reversed);
    }
    async rangeFromChannel(ctx: Context, createdAt: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChannel.directory, [createdAt], limit, reversed);
    }
    async rangeFromChannelWithCursor(ctx: Context, createdAt: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChannel.directory, [createdAt], limit, after, reversed);
    }
    async allFromChannel(ctx: Context, createdAt: number) {
        return await this._findAll(ctx, this.indexChannel.directory, [createdAt]);
    }
    createChannelStream(createdAt: number, limit: number, after?: string) {
        return this._createStream(this.indexChannel.directory, [createdAt], limit, after); 
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ChannelInvitation(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ChannelInvitation');
    }
}
export interface ChannelLinkShape {
    creatorId: number;
    channelId: number;
    enabled: boolean;
}

export class ChannelLink extends FEntity {
    readonly entityName: 'ChannelLink' = 'ChannelLink';
    get id(): string { return this._value.id; }
    get creatorId(): number {
        return this._value.creatorId;
    }
    set creatorId(value: number) {
        this._checkIsWritable();
        if (value === this._value.creatorId) { return; }
        this._value.creatorId = value;
        this.markDirty();
    }
    get channelId(): number {
        return this._value.channelId;
    }
    set channelId(value: number) {
        this._checkIsWritable();
        if (value === this._value.channelId) { return; }
        this._value.channelId = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ChannelLinkFactory extends FEntityFactory<ChannelLink> {
    static schema: FEntitySchema = {
        name: 'ChannelLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'creatorId', type: 'number' },
            { name: 'channelId', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'channel', type: 'range', fields: ['channelId', 'createdAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('channelLink');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ChannelLinkFactory.validate, hasLiveStreams: false };
        let indexChannel = new FEntityIndex(await layer.resolveEntityIndexDirectory('channelLink', 'channel'), 'channel', ['channelId', 'createdAt'], false);
        let indexes = {
            channel: indexChannel,
        };
        return new ChannelLinkFactory(layer, directory, config, indexes);
    }

    readonly indexChannel: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('creatorId', src.creatorId);
        validators.isNumber('creatorId', src.creatorId);
        validators.notNull('channelId', src.channelId);
        validators.isNumber('channelId', src.channelId);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { channel: FEntityIndex }) {
        super('ChannelLink', 'channelLink', config, [indexes.channel], layer, directory);
        this.indexChannel = indexes.channel;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: ChannelLinkShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: ChannelLinkShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async allFromChannelAfter(ctx: Context, channelId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChannel.directory, [channelId], after);
    }
    async rangeFromChannelAfter(ctx: Context, channelId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChannel.directory, [channelId], after, limit, reversed);
    }
    async rangeFromChannel(ctx: Context, channelId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChannel.directory, [channelId], limit, reversed);
    }
    async rangeFromChannelWithCursor(ctx: Context, channelId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChannel.directory, [channelId], limit, after, reversed);
    }
    async allFromChannel(ctx: Context, channelId: number) {
        return await this._findAll(ctx, this.indexChannel.directory, [channelId]);
    }
    createChannelStream(channelId: number, limit: number, after?: string) {
        return this._createStream(this.indexChannel.directory, [channelId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ChannelLink(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ChannelLink');
    }
}
export interface AppInviteLinkShape {
    uid: number;
}

export class AppInviteLink extends FEntity {
    readonly entityName: 'AppInviteLink' = 'AppInviteLink';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
}

export class AppInviteLinkFactory extends FEntityFactory<AppInviteLink> {
    static schema: FEntitySchema = {
        name: 'AppInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['uid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('appInviteLink');
        let config = { enableVersioning: true, enableTimestamps: true, validator: AppInviteLinkFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('appInviteLink', 'user'), 'user', ['uid'], true);
        let indexes = {
            user: indexUser,
        };
        return new AppInviteLinkFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('AppInviteLink', 'appInviteLink', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: AppInviteLinkShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: AppInviteLinkShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async findFromUser(ctx: Context, uid: number) {
        return await this._findFromIndex(ctx, this.indexUser.directory, [uid]);
    }
    async rangeFromUser(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [], limit, after, reversed);
    }
    async allFromUser(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUser.directory, []);
    }
    createUserStream(limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new AppInviteLink(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'AppInviteLink');
    }
}
export interface SampleEntityShape {
    data: string;
}

export class SampleEntity extends FEntity {
    readonly entityName: 'SampleEntity' = 'SampleEntity';
    get id(): string { return this._value.id; }
    get data(): string {
        return this._value.data;
    }
    set data(value: string) {
        this._checkIsWritable();
        if (value === this._value.data) { return; }
        this._value.data = value;
        this.markDirty();
    }
}

export class SampleEntityFactory extends FEntityFactory<SampleEntity> {
    static schema: FEntitySchema = {
        name: 'SampleEntity',
        editable: true,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'data', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('sampleEntity');
        let config = { enableVersioning: true, enableTimestamps: true, validator: SampleEntityFactory.validate, hasLiveStreams: false };
        return new SampleEntityFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('data', src.data);
        validators.isString('data', src.data);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('SampleEntity', 'sampleEntity', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: SampleEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: SampleEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new SampleEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'SampleEntity');
    }
}
export interface OrganizationPublicInviteLinkShape {
    uid: number;
    oid: number;
    enabled: boolean;
}

export class OrganizationPublicInviteLink extends FEntity {
    readonly entityName: 'OrganizationPublicInviteLink' = 'OrganizationPublicInviteLink';
    get id(): string { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class OrganizationPublicInviteLinkFactory extends FEntityFactory<OrganizationPublicInviteLink> {
    static schema: FEntitySchema = {
        name: 'OrganizationPublicInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'oid', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'userInOrganization', type: 'unique', fields: ['uid', 'oid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationPublicInviteLink');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationPublicInviteLinkFactory.validate, hasLiveStreams: false };
        let indexUserInOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationPublicInviteLink', 'userInOrganization'), 'userInOrganization', ['uid', 'oid'], true, src => src.enabled);
        let indexes = {
            userInOrganization: indexUserInOrganization,
        };
        return new OrganizationPublicInviteLinkFactory(layer, directory, config, indexes);
    }

    readonly indexUserInOrganization: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { userInOrganization: FEntityIndex }) {
        super('OrganizationPublicInviteLink', 'organizationPublicInviteLink', config, [indexes.userInOrganization], layer, directory);
        this.indexUserInOrganization = indexes.userInOrganization;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: OrganizationPublicInviteLinkShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: OrganizationPublicInviteLinkShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async findFromUserInOrganization(ctx: Context, uid: number, oid: number) {
        return await this._findFromIndex(ctx, this.indexUserInOrganization.directory, [uid, oid]);
    }
    async allFromUserInOrganizationAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUserInOrganization.directory, [uid], after);
    }
    async rangeFromUserInOrganizationAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUserInOrganization.directory, [uid], after, limit, reversed);
    }
    async rangeFromUserInOrganization(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUserInOrganization.directory, [uid], limit, reversed);
    }
    async rangeFromUserInOrganizationWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUserInOrganization.directory, [uid], limit, after, reversed);
    }
    async allFromUserInOrganization(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUserInOrganization.directory, [uid]);
    }
    createUserInOrganizationStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUserInOrganization.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationPublicInviteLink(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationPublicInviteLink');
    }
}
export interface OrganizationInviteLinkShape {
    oid: number;
    email: string;
    uid: number;
    firstName?: string| null;
    lastName?: string| null;
    text?: string| null;
    ttl?: number| null;
    enabled: boolean;
    joined: boolean;
    role: 'MEMBER' | 'OWNER';
}

export class OrganizationInviteLink extends FEntity {
    readonly entityName: 'OrganizationInviteLink' = 'OrganizationInviteLink';
    get id(): string { return this._value.id; }
    get oid(): number {
        return this._value.oid;
    }
    set oid(value: number) {
        this._checkIsWritable();
        if (value === this._value.oid) { return; }
        this._value.oid = value;
        this.markDirty();
    }
    get email(): string {
        return this._value.email;
    }
    set email(value: string) {
        this._checkIsWritable();
        if (value === this._value.email) { return; }
        this._value.email = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get firstName(): string | null {
        let res = this._value.firstName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set firstName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.firstName) { return; }
        this._value.firstName = value;
        this.markDirty();
    }
    get lastName(): string | null {
        let res = this._value.lastName;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastName(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.lastName) { return; }
        this._value.lastName = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get ttl(): number | null {
        let res = this._value.ttl;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set ttl(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.ttl) { return; }
        this._value.ttl = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
    get joined(): boolean {
        return this._value.joined;
    }
    set joined(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.joined) { return; }
        this._value.joined = value;
        this.markDirty();
    }
    get role(): 'MEMBER' | 'OWNER' {
        return this._value.role;
    }
    set role(value: 'MEMBER' | 'OWNER') {
        this._checkIsWritable();
        if (value === this._value.role) { return; }
        this._value.role = value;
        this.markDirty();
    }
}

export class OrganizationInviteLinkFactory extends FEntityFactory<OrganizationInviteLink> {
    static schema: FEntitySchema = {
        name: 'OrganizationInviteLink',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'oid', type: 'number' },
            { name: 'email', type: 'string' },
            { name: 'uid', type: 'number' },
            { name: 'firstName', type: 'string' },
            { name: 'lastName', type: 'string' },
            { name: 'text', type: 'string' },
            { name: 'ttl', type: 'number' },
            { name: 'enabled', type: 'boolean' },
            { name: 'joined', type: 'boolean' },
            { name: 'role', type: 'enum', enumValues: ['MEMBER', 'OWNER'] },
        ],
        indexes: [
            { name: 'organization', type: 'unique', fields: ['oid', 'id'] },
            { name: 'emailInOrganization', type: 'unique', fields: ['email', 'oid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('organizationInviteLink');
        let config = { enableVersioning: true, enableTimestamps: true, validator: OrganizationInviteLinkFactory.validate, hasLiveStreams: false };
        let indexOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationInviteLink', 'organization'), 'organization', ['oid', 'id'], true, src => src.enabled);
        let indexEmailInOrganization = new FEntityIndex(await layer.resolveEntityIndexDirectory('organizationInviteLink', 'emailInOrganization'), 'emailInOrganization', ['email', 'oid'], true, src => src.enabled);
        let indexes = {
            organization: indexOrganization,
            emailInOrganization: indexEmailInOrganization,
        };
        return new OrganizationInviteLinkFactory(layer, directory, config, indexes);
    }

    readonly indexOrganization: FEntityIndex;
    readonly indexEmailInOrganization: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('oid', src.oid);
        validators.isNumber('oid', src.oid);
        validators.notNull('email', src.email);
        validators.isString('email', src.email);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('firstName', src.firstName);
        validators.isString('lastName', src.lastName);
        validators.isString('text', src.text);
        validators.isNumber('ttl', src.ttl);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
        validators.notNull('joined', src.joined);
        validators.isBoolean('joined', src.joined);
        validators.notNull('role', src.role);
        validators.isEnum('role', src.role, ['MEMBER', 'OWNER']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { organization: FEntityIndex, emailInOrganization: FEntityIndex }) {
        super('OrganizationInviteLink', 'organizationInviteLink', config, [indexes.organization, indexes.emailInOrganization], layer, directory);
        this.indexOrganization = indexes.organization;
        this.indexEmailInOrganization = indexes.emailInOrganization;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: string) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: string, shape: OrganizationInviteLinkShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: string, shape: OrganizationInviteLinkShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: string) {
        return this._watch(ctx, [id]);
    }
    async findFromOrganization(ctx: Context, oid: number, id: string) {
        return await this._findFromIndex(ctx, this.indexOrganization.directory, [oid, id]);
    }
    async allFromOrganizationAfter(ctx: Context, oid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexOrganization.directory, [oid], after);
    }
    async rangeFromOrganizationAfter(ctx: Context, oid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexOrganization.directory, [oid], after, limit, reversed);
    }
    async rangeFromOrganization(ctx: Context, oid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexOrganization.directory, [oid], limit, reversed);
    }
    async rangeFromOrganizationWithCursor(ctx: Context, oid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexOrganization.directory, [oid], limit, after, reversed);
    }
    async allFromOrganization(ctx: Context, oid: number) {
        return await this._findAll(ctx, this.indexOrganization.directory, [oid]);
    }
    createOrganizationStream(oid: number, limit: number, after?: string) {
        return this._createStream(this.indexOrganization.directory, [oid], limit, after); 
    }
    async findFromEmailInOrganization(ctx: Context, email: string, oid: number) {
        return await this._findFromIndex(ctx, this.indexEmailInOrganization.directory, [email, oid]);
    }
    async allFromEmailInOrganizationAfter(ctx: Context, email: string, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexEmailInOrganization.directory, [email], after);
    }
    async rangeFromEmailInOrganizationAfter(ctx: Context, email: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexEmailInOrganization.directory, [email], after, limit, reversed);
    }
    async rangeFromEmailInOrganization(ctx: Context, email: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexEmailInOrganization.directory, [email], limit, reversed);
    }
    async rangeFromEmailInOrganizationWithCursor(ctx: Context, email: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexEmailInOrganization.directory, [email], limit, after, reversed);
    }
    async allFromEmailInOrganization(ctx: Context, email: string) {
        return await this._findAll(ctx, this.indexEmailInOrganization.directory, [email]);
    }
    createEmailInOrganizationStream(email: string, limit: number, after?: string) {
        return this._createStream(this.indexEmailInOrganization.directory, [email], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new OrganizationInviteLink(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'OrganizationInviteLink');
    }
}
export interface ConferenceRoomShape {
    startTime?: number| null;
    strategy?: 'direct' | 'bridged'| null;
}

export class ConferenceRoom extends FEntity {
    readonly entityName: 'ConferenceRoom' = 'ConferenceRoom';
    get id(): number { return this._value.id; }
    get startTime(): number | null {
        let res = this._value.startTime;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set startTime(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.startTime) { return; }
        this._value.startTime = value;
        this.markDirty();
    }
    get strategy(): 'direct' | 'bridged' | null {
        let res = this._value.strategy;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set strategy(value: 'direct' | 'bridged' | null) {
        this._checkIsWritable();
        if (value === this._value.strategy) { return; }
        this._value.strategy = value;
        this.markDirty();
    }
}

export class ConferenceRoomFactory extends FEntityFactory<ConferenceRoom> {
    static schema: FEntitySchema = {
        name: 'ConferenceRoom',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'startTime', type: 'number' },
            { name: 'strategy', type: 'enum', enumValues: ['direct', 'bridged'] },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conferenceRoom');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConferenceRoomFactory.validate, hasLiveStreams: false };
        return new ConferenceRoomFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.isNumber('startTime', src.startTime);
        validators.isEnum('strategy', src.strategy, ['direct', 'bridged']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('ConferenceRoom', 'conferenceRoom', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConferenceRoomShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConferenceRoomShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConferenceRoom(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConferenceRoom');
    }
}
export interface ConferencePeerShape {
    cid: number;
    uid: number;
    tid: string;
    keepAliveTimeout: number;
    enabled: boolean;
}

export class ConferencePeer extends FEntity {
    readonly entityName: 'ConferencePeer' = 'ConferencePeer';
    get id(): number { return this._value.id; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get tid(): string {
        return this._value.tid;
    }
    set tid(value: string) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get keepAliveTimeout(): number {
        return this._value.keepAliveTimeout;
    }
    set keepAliveTimeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.keepAliveTimeout) { return; }
        this._value.keepAliveTimeout = value;
        this.markDirty();
    }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class ConferencePeerFactory extends FEntityFactory<ConferencePeer> {
    static schema: FEntitySchema = {
        name: 'ConferencePeer',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'tid', type: 'string' },
            { name: 'keepAliveTimeout', type: 'number' },
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'auth', type: 'unique', fields: ['cid', 'uid', 'tid'] },
            { name: 'conference', type: 'range', fields: ['cid', 'keepAliveTimeout'] },
            { name: 'active', type: 'range', fields: ['keepAliveTimeout'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conferencePeer');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConferencePeerFactory.validate, hasLiveStreams: false };
        let indexAuth = new FEntityIndex(await layer.resolveEntityIndexDirectory('conferencePeer', 'auth'), 'auth', ['cid', 'uid', 'tid'], true, (src) => src.enabled);
        let indexConference = new FEntityIndex(await layer.resolveEntityIndexDirectory('conferencePeer', 'conference'), 'conference', ['cid', 'keepAliveTimeout'], false, (src) => src.enabled);
        let indexActive = new FEntityIndex(await layer.resolveEntityIndexDirectory('conferencePeer', 'active'), 'active', ['keepAliveTimeout'], false, (src) => src.enabled);
        let indexes = {
            auth: indexAuth,
            conference: indexConference,
            active: indexActive,
        };
        return new ConferencePeerFactory(layer, directory, config, indexes);
    }

    readonly indexAuth: FEntityIndex;
    readonly indexConference: FEntityIndex;
    readonly indexActive: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('tid', src.tid);
        validators.isString('tid', src.tid);
        validators.notNull('keepAliveTimeout', src.keepAliveTimeout);
        validators.isNumber('keepAliveTimeout', src.keepAliveTimeout);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { auth: FEntityIndex, conference: FEntityIndex, active: FEntityIndex }) {
        super('ConferencePeer', 'conferencePeer', config, [indexes.auth, indexes.conference, indexes.active], layer, directory);
        this.indexAuth = indexes.auth;
        this.indexConference = indexes.conference;
        this.indexActive = indexes.active;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConferencePeerShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConferencePeerShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromAuth(ctx: Context, cid: number, uid: number, tid: string) {
        return await this._findFromIndex(ctx, this.indexAuth.directory, [cid, uid, tid]);
    }
    async allFromAuthAfter(ctx: Context, cid: number, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexAuth.directory, [cid, uid], after);
    }
    async rangeFromAuthAfter(ctx: Context, cid: number, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexAuth.directory, [cid, uid], after, limit, reversed);
    }
    async rangeFromAuth(ctx: Context, cid: number, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexAuth.directory, [cid, uid], limit, reversed);
    }
    async rangeFromAuthWithCursor(ctx: Context, cid: number, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexAuth.directory, [cid, uid], limit, after, reversed);
    }
    async allFromAuth(ctx: Context, cid: number, uid: number) {
        return await this._findAll(ctx, this.indexAuth.directory, [cid, uid]);
    }
    createAuthStream(cid: number, uid: number, limit: number, after?: string) {
        return this._createStream(this.indexAuth.directory, [cid, uid], limit, after); 
    }
    async allFromConferenceAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexConference.directory, [cid], after);
    }
    async rangeFromConferenceAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexConference.directory, [cid], after, limit, reversed);
    }
    async rangeFromConference(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexConference.directory, [cid], limit, reversed);
    }
    async rangeFromConferenceWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexConference.directory, [cid], limit, after, reversed);
    }
    async allFromConference(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexConference.directory, [cid]);
    }
    createConferenceStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexConference.directory, [cid], limit, after); 
    }
    async rangeFromActive(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexActive.directory, [], limit, reversed);
    }
    async rangeFromActiveWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexActive.directory, [], limit, after, reversed);
    }
    async allFromActive(ctx: Context, ) {
        return await this._findAll(ctx, this.indexActive.directory, []);
    }
    createActiveStream(limit: number, after?: string) {
        return this._createStream(this.indexActive.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConferencePeer(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConferencePeer');
    }
}
export interface ConferenceMediaStreamShape {
    cid: number;
    peer1: number;
    peer2?: number| null;
    kind: 'direct' | 'bridged';
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer?: string| null;
    answer?: string| null;
    ice1: any;
    ice2: any;
}

export class ConferenceMediaStream extends FEntity {
    readonly entityName: 'ConferenceMediaStream' = 'ConferenceMediaStream';
    get id(): number { return this._value.id; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get peer1(): number {
        return this._value.peer1;
    }
    set peer1(value: number) {
        this._checkIsWritable();
        if (value === this._value.peer1) { return; }
        this._value.peer1 = value;
        this.markDirty();
    }
    get peer2(): number | null {
        let res = this._value.peer2;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set peer2(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.peer2) { return; }
        this._value.peer2 = value;
        this.markDirty();
    }
    get kind(): 'direct' | 'bridged' {
        return this._value.kind;
    }
    set kind(value: 'direct' | 'bridged') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get state(): 'wait-offer' | 'wait-answer' | 'online' | 'completed' {
        return this._value.state;
    }
    set state(value: 'wait-offer' | 'wait-answer' | 'online' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.state) { return; }
        this._value.state = value;
        this.markDirty();
    }
    get offer(): string | null {
        let res = this._value.offer;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set offer(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.offer) { return; }
        this._value.offer = value;
        this.markDirty();
    }
    get answer(): string | null {
        let res = this._value.answer;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set answer(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.answer) { return; }
        this._value.answer = value;
        this.markDirty();
    }
    get ice1(): any {
        return this._value.ice1;
    }
    set ice1(value: any) {
        this._checkIsWritable();
        if (value === this._value.ice1) { return; }
        this._value.ice1 = value;
        this.markDirty();
    }
    get ice2(): any {
        return this._value.ice2;
    }
    set ice2(value: any) {
        this._checkIsWritable();
        if (value === this._value.ice2) { return; }
        this._value.ice2 = value;
        this.markDirty();
    }
}

export class ConferenceMediaStreamFactory extends FEntityFactory<ConferenceMediaStream> {
    static schema: FEntitySchema = {
        name: 'ConferenceMediaStream',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'peer1', type: 'number' },
            { name: 'peer2', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['direct', 'bridged'] },
            { name: 'state', type: 'enum', enumValues: ['wait-offer', 'wait-answer', 'online', 'completed'] },
            { name: 'offer', type: 'string' },
            { name: 'answer', type: 'string' },
            { name: 'ice1', type: 'json' },
            { name: 'ice2', type: 'json' },
        ],
        indexes: [
            { name: 'conference', type: 'range', fields: ['cid', 'createdAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conferenceMediaStream');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConferenceMediaStreamFactory.validate, hasLiveStreams: false };
        let indexConference = new FEntityIndex(await layer.resolveEntityIndexDirectory('conferenceMediaStream', 'conference'), 'conference', ['cid', 'createdAt'], false, (src) => src.state !== 'completed');
        let indexes = {
            conference: indexConference,
        };
        return new ConferenceMediaStreamFactory(layer, directory, config, indexes);
    }

    readonly indexConference: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('peer1', src.peer1);
        validators.isNumber('peer1', src.peer1);
        validators.isNumber('peer2', src.peer2);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['direct', 'bridged']);
        validators.notNull('state', src.state);
        validators.isEnum('state', src.state, ['wait-offer', 'wait-answer', 'online', 'completed']);
        validators.isString('offer', src.offer);
        validators.isString('answer', src.answer);
        validators.notNull('ice1', src.ice1);
        validators.notNull('ice2', src.ice2);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { conference: FEntityIndex }) {
        super('ConferenceMediaStream', 'conferenceMediaStream', config, [indexes.conference], layer, directory);
        this.indexConference = indexes.conference;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ConferenceMediaStreamShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ConferenceMediaStreamShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromConferenceAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexConference.directory, [cid], after);
    }
    async rangeFromConferenceAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexConference.directory, [cid], after, limit, reversed);
    }
    async rangeFromConference(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexConference.directory, [cid], limit, reversed);
    }
    async rangeFromConferenceWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexConference.directory, [cid], limit, after, reversed);
    }
    async allFromConference(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexConference.directory, [cid]);
    }
    createConferenceStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexConference.directory, [cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConferenceMediaStream(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ConferenceMediaStream');
    }
}
export interface ConferenceConnectionShape {
    cid: number;
    state: 'wait-offer' | 'wait-answer' | 'online' | 'completed';
    offer?: string| null;
    answer?: string| null;
    ice1: any;
    ice2: any;
}

export class ConferenceConnection extends FEntity {
    readonly entityName: 'ConferenceConnection' = 'ConferenceConnection';
    get peer1(): number { return this._value.peer1; }
    get peer2(): number { return this._value.peer2; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get state(): 'wait-offer' | 'wait-answer' | 'online' | 'completed' {
        return this._value.state;
    }
    set state(value: 'wait-offer' | 'wait-answer' | 'online' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.state) { return; }
        this._value.state = value;
        this.markDirty();
    }
    get offer(): string | null {
        let res = this._value.offer;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set offer(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.offer) { return; }
        this._value.offer = value;
        this.markDirty();
    }
    get answer(): string | null {
        let res = this._value.answer;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set answer(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.answer) { return; }
        this._value.answer = value;
        this.markDirty();
    }
    get ice1(): any {
        return this._value.ice1;
    }
    set ice1(value: any) {
        this._checkIsWritable();
        if (value === this._value.ice1) { return; }
        this._value.ice1 = value;
        this.markDirty();
    }
    get ice2(): any {
        return this._value.ice2;
    }
    set ice2(value: any) {
        this._checkIsWritable();
        if (value === this._value.ice2) { return; }
        this._value.ice2 = value;
        this.markDirty();
    }
}

export class ConferenceConnectionFactory extends FEntityFactory<ConferenceConnection> {
    static schema: FEntitySchema = {
        name: 'ConferenceConnection',
        editable: false,
        primaryKeys: [
            { name: 'peer1', type: 'number' },
            { name: 'peer2', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'state', type: 'enum', enumValues: ['wait-offer', 'wait-answer', 'online', 'completed'] },
            { name: 'offer', type: 'string' },
            { name: 'answer', type: 'string' },
            { name: 'ice1', type: 'json' },
            { name: 'ice2', type: 'json' },
        ],
        indexes: [
            { name: 'conference', type: 'range', fields: ['cid', 'createdAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('conferenceConnection');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ConferenceConnectionFactory.validate, hasLiveStreams: false };
        let indexConference = new FEntityIndex(await layer.resolveEntityIndexDirectory('conferenceConnection', 'conference'), 'conference', ['cid', 'createdAt'], false, (src) => src.state !== 'completed');
        let indexes = {
            conference: indexConference,
        };
        return new ConferenceConnectionFactory(layer, directory, config, indexes);
    }

    readonly indexConference: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('peer1', src.peer1);
        validators.isNumber('peer1', src.peer1);
        validators.notNull('peer2', src.peer2);
        validators.isNumber('peer2', src.peer2);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('state', src.state);
        validators.isEnum('state', src.state, ['wait-offer', 'wait-answer', 'online', 'completed']);
        validators.isString('offer', src.offer);
        validators.isString('answer', src.answer);
        validators.notNull('ice1', src.ice1);
        validators.notNull('ice2', src.ice2);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { conference: FEntityIndex }) {
        super('ConferenceConnection', 'conferenceConnection', config, [indexes.conference], layer, directory);
        this.indexConference = indexes.conference;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'peer1': rawId[0], 'peer2': rawId[1] };
    }
    async findById(ctx: Context, peer1: number, peer2: number) {
        return await this._findById(ctx, [peer1, peer2]);
    }
    async create(ctx: Context, peer1: number, peer2: number, shape: ConferenceConnectionShape) {
        return await this._create(ctx, [peer1, peer2], { peer1, peer2, ...shape });
    }
    async create_UNSAFE(ctx: Context, peer1: number, peer2: number, shape: ConferenceConnectionShape) {
        return await this._create_UNSAFE(ctx, [peer1, peer2], { peer1, peer2, ...shape });
    }
    watch(ctx: Context, peer1: number, peer2: number) {
        return this._watch(ctx, [peer1, peer2]);
    }
    async allFromConferenceAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexConference.directory, [cid], after);
    }
    async rangeFromConferenceAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexConference.directory, [cid], after, limit, reversed);
    }
    async rangeFromConference(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexConference.directory, [cid], limit, reversed);
    }
    async rangeFromConferenceWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexConference.directory, [cid], limit, after, reversed);
    }
    async allFromConference(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexConference.directory, [cid]);
    }
    createConferenceStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexConference.directory, [cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ConferenceConnection(ctx, this.layer, this.directory, [value.peer1, value.peer2], value, this.options, isNew, this.indexes, 'ConferenceConnection');
    }
}
export interface UserEdgeShape {
}

export class UserEdge extends FEntity {
    readonly entityName: 'UserEdge' = 'UserEdge';
    get uid1(): number { return this._value.uid1; }
    get uid2(): number { return this._value.uid2; }
}

export class UserEdgeFactory extends FEntityFactory<UserEdge> {
    static schema: FEntitySchema = {
        name: 'UserEdge',
        editable: false,
        primaryKeys: [
            { name: 'uid1', type: 'number' },
            { name: 'uid2', type: 'number' },
        ],
        fields: [
        ],
        indexes: [
            { name: 'forward', type: 'range', fields: ['uid1', 'uid2'] },
            { name: 'reverse', type: 'range', fields: ['uid2', 'uid1'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userEdge');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserEdgeFactory.validate, hasLiveStreams: false };
        let indexForward = new FEntityIndex(await layer.resolveEntityIndexDirectory('userEdge', 'forward'), 'forward', ['uid1', 'uid2'], false);
        let indexReverse = new FEntityIndex(await layer.resolveEntityIndexDirectory('userEdge', 'reverse'), 'reverse', ['uid2', 'uid1'], false);
        let indexes = {
            forward: indexForward,
            reverse: indexReverse,
        };
        return new UserEdgeFactory(layer, directory, config, indexes);
    }

    readonly indexForward: FEntityIndex;
    readonly indexReverse: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid1', src.uid1);
        validators.isNumber('uid1', src.uid1);
        validators.notNull('uid2', src.uid2);
        validators.isNumber('uid2', src.uid2);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { forward: FEntityIndex, reverse: FEntityIndex }) {
        super('UserEdge', 'userEdge', config, [indexes.forward, indexes.reverse], layer, directory);
        this.indexForward = indexes.forward;
        this.indexReverse = indexes.reverse;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid1': rawId[0], 'uid2': rawId[1] };
    }
    async findById(ctx: Context, uid1: number, uid2: number) {
        return await this._findById(ctx, [uid1, uid2]);
    }
    async create(ctx: Context, uid1: number, uid2: number, shape: UserEdgeShape) {
        return await this._create(ctx, [uid1, uid2], { uid1, uid2, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid1: number, uid2: number, shape: UserEdgeShape) {
        return await this._create_UNSAFE(ctx, [uid1, uid2], { uid1, uid2, ...shape });
    }
    watch(ctx: Context, uid1: number, uid2: number) {
        return this._watch(ctx, [uid1, uid2]);
    }
    async allFromForwardAfter(ctx: Context, uid1: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexForward.directory, [uid1], after);
    }
    async rangeFromForwardAfter(ctx: Context, uid1: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexForward.directory, [uid1], after, limit, reversed);
    }
    async rangeFromForward(ctx: Context, uid1: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexForward.directory, [uid1], limit, reversed);
    }
    async rangeFromForwardWithCursor(ctx: Context, uid1: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexForward.directory, [uid1], limit, after, reversed);
    }
    async allFromForward(ctx: Context, uid1: number) {
        return await this._findAll(ctx, this.indexForward.directory, [uid1]);
    }
    createForwardStream(uid1: number, limit: number, after?: string) {
        return this._createStream(this.indexForward.directory, [uid1], limit, after); 
    }
    async allFromReverseAfter(ctx: Context, uid2: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexReverse.directory, [uid2], after);
    }
    async rangeFromReverseAfter(ctx: Context, uid2: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexReverse.directory, [uid2], after, limit, reversed);
    }
    async rangeFromReverse(ctx: Context, uid2: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexReverse.directory, [uid2], limit, reversed);
    }
    async rangeFromReverseWithCursor(ctx: Context, uid2: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexReverse.directory, [uid2], limit, after, reversed);
    }
    async allFromReverse(ctx: Context, uid2: number) {
        return await this._findAll(ctx, this.indexReverse.directory, [uid2]);
    }
    createReverseStream(uid2: number, limit: number, after?: string) {
        return this._createStream(this.indexReverse.directory, [uid2], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserEdge(ctx, this.layer, this.directory, [value.uid1, value.uid2], value, this.options, isNew, this.indexes, 'UserEdge');
    }
}
export interface UserInfluencerUserIndexShape {
    value: number;
}

export class UserInfluencerUserIndex extends FEntity {
    readonly entityName: 'UserInfluencerUserIndex' = 'UserInfluencerUserIndex';
    get uid(): number { return this._value.uid; }
    get value(): number {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class UserInfluencerUserIndexFactory extends FEntityFactory<UserInfluencerUserIndex> {
    static schema: FEntitySchema = {
        name: 'UserInfluencerUserIndex',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'value', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userInfluencerUserIndex');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserInfluencerUserIndexFactory.validate, hasLiveStreams: false };
        return new UserInfluencerUserIndexFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('value', src.value);
        validators.isNumber('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserInfluencerUserIndex', 'userInfluencerUserIndex', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: UserInfluencerUserIndexShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: UserInfluencerUserIndexShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserInfluencerUserIndex(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserInfluencerUserIndex');
    }
}
export interface UserInfluencerIndexShape {
    value: number;
}

export class UserInfluencerIndex extends FEntity {
    readonly entityName: 'UserInfluencerIndex' = 'UserInfluencerIndex';
    get uid(): number { return this._value.uid; }
    get value(): number {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class UserInfluencerIndexFactory extends FEntityFactory<UserInfluencerIndex> {
    static schema: FEntitySchema = {
        name: 'UserInfluencerIndex',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'value', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userInfluencerIndex');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserInfluencerIndexFactory.validate, hasLiveStreams: false };
        return new UserInfluencerIndexFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('value', src.value);
        validators.isNumber('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('UserInfluencerIndex', 'userInfluencerIndex', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: UserInfluencerIndexShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: UserInfluencerIndexShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserInfluencerIndex(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'UserInfluencerIndex');
    }
}
export interface FeedSubscriberShape {
    key: string;
}

export class FeedSubscriber extends FEntity {
    readonly entityName: 'FeedSubscriber' = 'FeedSubscriber';
    get id(): number { return this._value.id; }
    get key(): string {
        return this._value.key;
    }
    set key(value: string) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
}

export class FeedSubscriberFactory extends FEntityFactory<FeedSubscriber> {
    static schema: FEntitySchema = {
        name: 'FeedSubscriber',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'string' },
        ],
        indexes: [
            { name: 'key', type: 'unique', fields: ['key'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('feedSubscriber');
        let config = { enableVersioning: true, enableTimestamps: true, validator: FeedSubscriberFactory.validate, hasLiveStreams: false };
        let indexKey = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedSubscriber', 'key'), 'key', ['key'], true);
        let indexes = {
            key: indexKey,
        };
        return new FeedSubscriberFactory(layer, directory, config, indexes);
    }

    readonly indexKey: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { key: FEntityIndex }) {
        super('FeedSubscriber', 'feedSubscriber', config, [indexes.key], layer, directory);
        this.indexKey = indexes.key;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: FeedSubscriberShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: FeedSubscriberShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromKey(ctx: Context, key: string) {
        return await this._findFromIndex(ctx, this.indexKey.directory, [key]);
    }
    async rangeFromKey(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexKey.directory, [], limit, reversed);
    }
    async rangeFromKeyWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexKey.directory, [], limit, after, reversed);
    }
    async allFromKey(ctx: Context, ) {
        return await this._findAll(ctx, this.indexKey.directory, []);
    }
    createKeyStream(limit: number, after?: string) {
        return this._createStream(this.indexKey.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new FeedSubscriber(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'FeedSubscriber');
    }
}
export interface FeedSubscriptionShape {
    enabled: boolean;
}

export class FeedSubscription extends FEntity {
    readonly entityName: 'FeedSubscription' = 'FeedSubscription';
    get sid(): number { return this._value.sid; }
    get tid(): number { return this._value.tid; }
    get enabled(): boolean {
        return this._value.enabled;
    }
    set enabled(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.enabled) { return; }
        this._value.enabled = value;
        this.markDirty();
    }
}

export class FeedSubscriptionFactory extends FEntityFactory<FeedSubscription> {
    static schema: FEntitySchema = {
        name: 'FeedSubscription',
        editable: false,
        primaryKeys: [
            { name: 'sid', type: 'number' },
            { name: 'tid', type: 'number' },
        ],
        fields: [
            { name: 'enabled', type: 'boolean' },
        ],
        indexes: [
            { name: 'subscriber', type: 'range', fields: ['sid', 'tid'] },
            { name: 'topic', type: 'range', fields: ['tid', 'sid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('feedSubscription');
        let config = { enableVersioning: false, enableTimestamps: false, validator: FeedSubscriptionFactory.validate, hasLiveStreams: false };
        let indexSubscriber = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedSubscription', 'subscriber'), 'subscriber', ['sid', 'tid'], false, (state) => state.enabled);
        let indexTopic = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedSubscription', 'topic'), 'topic', ['tid', 'sid'], false, (state) => state.enabled);
        let indexes = {
            subscriber: indexSubscriber,
            topic: indexTopic,
        };
        return new FeedSubscriptionFactory(layer, directory, config, indexes);
    }

    readonly indexSubscriber: FEntityIndex;
    readonly indexTopic: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('sid', src.sid);
        validators.isNumber('sid', src.sid);
        validators.notNull('tid', src.tid);
        validators.isNumber('tid', src.tid);
        validators.notNull('enabled', src.enabled);
        validators.isBoolean('enabled', src.enabled);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { subscriber: FEntityIndex, topic: FEntityIndex }) {
        super('FeedSubscription', 'feedSubscription', config, [indexes.subscriber, indexes.topic], layer, directory);
        this.indexSubscriber = indexes.subscriber;
        this.indexTopic = indexes.topic;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'sid': rawId[0], 'tid': rawId[1] };
    }
    async findById(ctx: Context, sid: number, tid: number) {
        return await this._findById(ctx, [sid, tid]);
    }
    async create(ctx: Context, sid: number, tid: number, shape: FeedSubscriptionShape) {
        return await this._create(ctx, [sid, tid], { sid, tid, ...shape });
    }
    async create_UNSAFE(ctx: Context, sid: number, tid: number, shape: FeedSubscriptionShape) {
        return await this._create_UNSAFE(ctx, [sid, tid], { sid, tid, ...shape });
    }
    watch(ctx: Context, sid: number, tid: number) {
        return this._watch(ctx, [sid, tid]);
    }
    async allFromSubscriberAfter(ctx: Context, sid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexSubscriber.directory, [sid], after);
    }
    async rangeFromSubscriberAfter(ctx: Context, sid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexSubscriber.directory, [sid], after, limit, reversed);
    }
    async rangeFromSubscriber(ctx: Context, sid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexSubscriber.directory, [sid], limit, reversed);
    }
    async rangeFromSubscriberWithCursor(ctx: Context, sid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexSubscriber.directory, [sid], limit, after, reversed);
    }
    async allFromSubscriber(ctx: Context, sid: number) {
        return await this._findAll(ctx, this.indexSubscriber.directory, [sid]);
    }
    createSubscriberStream(sid: number, limit: number, after?: string) {
        return this._createStream(this.indexSubscriber.directory, [sid], limit, after); 
    }
    async allFromTopicAfter(ctx: Context, tid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexTopic.directory, [tid], after);
    }
    async rangeFromTopicAfter(ctx: Context, tid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexTopic.directory, [tid], after, limit, reversed);
    }
    async rangeFromTopic(ctx: Context, tid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexTopic.directory, [tid], limit, reversed);
    }
    async rangeFromTopicWithCursor(ctx: Context, tid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexTopic.directory, [tid], limit, after, reversed);
    }
    async allFromTopic(ctx: Context, tid: number) {
        return await this._findAll(ctx, this.indexTopic.directory, [tid]);
    }
    createTopicStream(tid: number, limit: number, after?: string) {
        return this._createStream(this.indexTopic.directory, [tid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new FeedSubscription(ctx, this.layer, this.directory, [value.sid, value.tid], value, this.options, isNew, this.indexes, 'FeedSubscription');
    }
}
export interface FeedTopicShape {
    key: string;
}

export class FeedTopic extends FEntity {
    readonly entityName: 'FeedTopic' = 'FeedTopic';
    get id(): number { return this._value.id; }
    get key(): string {
        return this._value.key;
    }
    set key(value: string) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
}

export class FeedTopicFactory extends FEntityFactory<FeedTopic> {
    static schema: FEntitySchema = {
        name: 'FeedTopic',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'string' },
        ],
        indexes: [
            { name: 'key', type: 'unique', fields: ['key'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('feedTopic');
        let config = { enableVersioning: true, enableTimestamps: true, validator: FeedTopicFactory.validate, hasLiveStreams: false };
        let indexKey = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedTopic', 'key'), 'key', ['key'], true);
        let indexes = {
            key: indexKey,
        };
        return new FeedTopicFactory(layer, directory, config, indexes);
    }

    readonly indexKey: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { key: FEntityIndex }) {
        super('FeedTopic', 'feedTopic', config, [indexes.key], layer, directory);
        this.indexKey = indexes.key;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: FeedTopicShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: FeedTopicShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromKey(ctx: Context, key: string) {
        return await this._findFromIndex(ctx, this.indexKey.directory, [key]);
    }
    async rangeFromKey(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexKey.directory, [], limit, reversed);
    }
    async rangeFromKeyWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexKey.directory, [], limit, after, reversed);
    }
    async allFromKey(ctx: Context, ) {
        return await this._findAll(ctx, this.indexKey.directory, []);
    }
    createKeyStream(limit: number, after?: string) {
        return this._createStream(this.indexKey.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new FeedTopic(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'FeedTopic');
    }
}
export interface FeedEventShape {
    tid: number;
    type: string;
    content: any;
}

export class FeedEvent extends FEntity {
    readonly entityName: 'FeedEvent' = 'FeedEvent';
    get id(): number { return this._value.id; }
    get tid(): number {
        return this._value.tid;
    }
    set tid(value: number) {
        this._checkIsWritable();
        if (value === this._value.tid) { return; }
        this._value.tid = value;
        this.markDirty();
    }
    get type(): string {
        return this._value.type;
    }
    set type(value: string) {
        this._checkIsWritable();
        if (value === this._value.type) { return; }
        this._value.type = value;
        this.markDirty();
    }
    get content(): any {
        return this._value.content;
    }
    set content(value: any) {
        this._checkIsWritable();
        if (value === this._value.content) { return; }
        this._value.content = value;
        this.markDirty();
    }
}

export class FeedEventFactory extends FEntityFactory<FeedEvent> {
    static schema: FEntitySchema = {
        name: 'FeedEvent',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'tid', type: 'number' },
            { name: 'type', type: 'string' },
            { name: 'content', type: 'json' },
        ],
        indexes: [
            { name: 'topic', type: 'range', fields: ['tid', 'createdAt'] },
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('feedEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: FeedEventFactory.validate, hasLiveStreams: false };
        let indexTopic = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedEvent', 'topic'), 'topic', ['tid', 'createdAt'], false);
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('feedEvent', 'updated'), 'updated', ['updatedAt'], false);
        let indexes = {
            topic: indexTopic,
            updated: indexUpdated,
        };
        return new FeedEventFactory(layer, directory, config, indexes);
    }

    readonly indexTopic: FEntityIndex;
    readonly indexUpdated: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('tid', src.tid);
        validators.isNumber('tid', src.tid);
        validators.notNull('type', src.type);
        validators.isString('type', src.type);
        validators.notNull('content', src.content);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { topic: FEntityIndex, updated: FEntityIndex }) {
        super('FeedEvent', 'feedEvent', config, [indexes.topic, indexes.updated], layer, directory);
        this.indexTopic = indexes.topic;
        this.indexUpdated = indexes.updated;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: FeedEventShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: FeedEventShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromTopicAfter(ctx: Context, tid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexTopic.directory, [tid], after);
    }
    async rangeFromTopicAfter(ctx: Context, tid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexTopic.directory, [tid], after, limit, reversed);
    }
    async rangeFromTopic(ctx: Context, tid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexTopic.directory, [tid], limit, reversed);
    }
    async rangeFromTopicWithCursor(ctx: Context, tid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexTopic.directory, [tid], limit, after, reversed);
    }
    async allFromTopic(ctx: Context, tid: number) {
        return await this._findAll(ctx, this.indexTopic.directory, [tid]);
    }
    createTopicStream(tid: number, limit: number, after?: string) {
        return this._createStream(this.indexTopic.directory, [tid], limit, after); 
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new FeedEvent(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'FeedEvent');
    }
}
export interface AppHookShape {
    key: string;
}

export class AppHook extends FEntity {
    readonly entityName: 'AppHook' = 'AppHook';
    get appId(): number { return this._value.appId; }
    get chatId(): number { return this._value.chatId; }
    get key(): string {
        return this._value.key;
    }
    set key(value: string) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
}

export class AppHookFactory extends FEntityFactory<AppHook> {
    static schema: FEntitySchema = {
        name: 'AppHook',
        editable: false,
        primaryKeys: [
            { name: 'appId', type: 'number' },
            { name: 'chatId', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'string' },
        ],
        indexes: [
            { name: 'key', type: 'unique', fields: ['key'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('appHook');
        let config = { enableVersioning: true, enableTimestamps: true, validator: AppHookFactory.validate, hasLiveStreams: false };
        let indexKey = new FEntityIndex(await layer.resolveEntityIndexDirectory('appHook', 'key'), 'key', ['key'], true);
        let indexes = {
            key: indexKey,
        };
        return new AppHookFactory(layer, directory, config, indexes);
    }

    readonly indexKey: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('appId', src.appId);
        validators.isNumber('appId', src.appId);
        validators.notNull('chatId', src.chatId);
        validators.isNumber('chatId', src.chatId);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { key: FEntityIndex }) {
        super('AppHook', 'appHook', config, [indexes.key], layer, directory);
        this.indexKey = indexes.key;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'appId': rawId[0], 'chatId': rawId[1] };
    }
    async findById(ctx: Context, appId: number, chatId: number) {
        return await this._findById(ctx, [appId, chatId]);
    }
    async create(ctx: Context, appId: number, chatId: number, shape: AppHookShape) {
        return await this._create(ctx, [appId, chatId], { appId, chatId, ...shape });
    }
    async create_UNSAFE(ctx: Context, appId: number, chatId: number, shape: AppHookShape) {
        return await this._create_UNSAFE(ctx, [appId, chatId], { appId, chatId, ...shape });
    }
    watch(ctx: Context, appId: number, chatId: number) {
        return this._watch(ctx, [appId, chatId]);
    }
    async findFromKey(ctx: Context, key: string) {
        return await this._findFromIndex(ctx, this.indexKey.directory, [key]);
    }
    async rangeFromKey(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexKey.directory, [], limit, reversed);
    }
    async rangeFromKeyWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexKey.directory, [], limit, after, reversed);
    }
    async allFromKey(ctx: Context, ) {
        return await this._findAll(ctx, this.indexKey.directory, []);
    }
    createKeyStream(limit: number, after?: string) {
        return this._createStream(this.indexKey.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new AppHook(ctx, this.layer, this.directory, [value.appId, value.chatId], value, this.options, isNew, this.indexes, 'AppHook');
    }
}
export interface UserStorageNamespaceShape {
    ns: string;
}

export class UserStorageNamespace extends FEntity {
    readonly entityName: 'UserStorageNamespace' = 'UserStorageNamespace';
    get id(): number { return this._value.id; }
    get ns(): string {
        return this._value.ns;
    }
    set ns(value: string) {
        this._checkIsWritable();
        if (value === this._value.ns) { return; }
        this._value.ns = value;
        this.markDirty();
    }
}

export class UserStorageNamespaceFactory extends FEntityFactory<UserStorageNamespace> {
    static schema: FEntitySchema = {
        name: 'UserStorageNamespace',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'ns', type: 'string' },
        ],
        indexes: [
            { name: 'namespace', type: 'unique', fields: ['ns'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userStorageNamespace');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserStorageNamespaceFactory.validate, hasLiveStreams: false };
        let indexNamespace = new FEntityIndex(await layer.resolveEntityIndexDirectory('userStorageNamespace', 'namespace'), 'namespace', ['ns'], true);
        let indexes = {
            namespace: indexNamespace,
        };
        return new UserStorageNamespaceFactory(layer, directory, config, indexes);
    }

    readonly indexNamespace: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('ns', src.ns);
        validators.isString('ns', src.ns);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { namespace: FEntityIndex }) {
        super('UserStorageNamespace', 'userStorageNamespace', config, [indexes.namespace], layer, directory);
        this.indexNamespace = indexes.namespace;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserStorageNamespaceShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserStorageNamespaceShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromNamespace(ctx: Context, ns: string) {
        return await this._findFromIndex(ctx, this.indexNamespace.directory, [ns]);
    }
    async rangeFromNamespace(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexNamespace.directory, [], limit, reversed);
    }
    async rangeFromNamespaceWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexNamespace.directory, [], limit, after, reversed);
    }
    async allFromNamespace(ctx: Context, ) {
        return await this._findAll(ctx, this.indexNamespace.directory, []);
    }
    createNamespaceStream(limit: number, after?: string) {
        return this._createStream(this.indexNamespace.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserStorageNamespace(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserStorageNamespace');
    }
}
export interface UserStorageRecordShape {
    ns: number;
    key: string;
    value?: string| null;
}

export class UserStorageRecord extends FEntity {
    readonly entityName: 'UserStorageRecord' = 'UserStorageRecord';
    get uid(): number { return this._value.uid; }
    get id(): number { return this._value.id; }
    get ns(): number {
        return this._value.ns;
    }
    set ns(value: number) {
        this._checkIsWritable();
        if (value === this._value.ns) { return; }
        this._value.ns = value;
        this.markDirty();
    }
    get key(): string {
        return this._value.key;
    }
    set key(value: string) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
    get value(): string | null {
        let res = this._value.value;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set value(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class UserStorageRecordFactory extends FEntityFactory<UserStorageRecord> {
    static schema: FEntitySchema = {
        name: 'UserStorageRecord',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'ns', type: 'number' },
            { name: 'key', type: 'string' },
            { name: 'value', type: 'string' },
        ],
        indexes: [
            { name: 'key', type: 'unique', fields: ['uid', 'ns', 'key'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userStorageRecord');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserStorageRecordFactory.validate, hasLiveStreams: false };
        let indexKey = new FEntityIndex(await layer.resolveEntityIndexDirectory('userStorageRecord', 'key'), 'key', ['uid', 'ns', 'key'], true);
        let indexes = {
            key: indexKey,
        };
        return new UserStorageRecordFactory(layer, directory, config, indexes);
    }

    readonly indexKey: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('ns', src.ns);
        validators.isNumber('ns', src.ns);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.isString('value', src.value);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { key: FEntityIndex }) {
        super('UserStorageRecord', 'userStorageRecord', config, [indexes.key], layer, directory);
        this.indexKey = indexes.key;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'id': rawId[1] };
    }
    async findById(ctx: Context, uid: number, id: number) {
        return await this._findById(ctx, [uid, id]);
    }
    async create(ctx: Context, uid: number, id: number, shape: UserStorageRecordShape) {
        return await this._create(ctx, [uid, id], { uid, id, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, id: number, shape: UserStorageRecordShape) {
        return await this._create_UNSAFE(ctx, [uid, id], { uid, id, ...shape });
    }
    watch(ctx: Context, uid: number, id: number) {
        return this._watch(ctx, [uid, id]);
    }
    async findFromKey(ctx: Context, uid: number, ns: number, key: string) {
        return await this._findFromIndex(ctx, this.indexKey.directory, [uid, ns, key]);
    }
    async allFromKeyAfter(ctx: Context, uid: number, ns: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexKey.directory, [uid, ns], after);
    }
    async rangeFromKeyAfter(ctx: Context, uid: number, ns: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexKey.directory, [uid, ns], after, limit, reversed);
    }
    async rangeFromKey(ctx: Context, uid: number, ns: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexKey.directory, [uid, ns], limit, reversed);
    }
    async rangeFromKeyWithCursor(ctx: Context, uid: number, ns: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexKey.directory, [uid, ns], limit, after, reversed);
    }
    async allFromKey(ctx: Context, uid: number, ns: number) {
        return await this._findAll(ctx, this.indexKey.directory, [uid, ns]);
    }
    createKeyStream(uid: number, ns: number, limit: number, after?: string) {
        return this._createStream(this.indexKey.directory, [uid, ns], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserStorageRecord(ctx, this.layer, this.directory, [value.uid, value.id], value, this.options, isNew, this.indexes, 'UserStorageRecord');
    }
}
export interface DiscoverUserPickedTagsShape {
    deleted: boolean;
}

export class DiscoverUserPickedTags extends FEntity {
    readonly entityName: 'DiscoverUserPickedTags' = 'DiscoverUserPickedTags';
    get uid(): number { return this._value.uid; }
    get id(): string { return this._value.id; }
    get deleted(): boolean {
        return this._value.deleted;
    }
    set deleted(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
}

export class DiscoverUserPickedTagsFactory extends FEntityFactory<DiscoverUserPickedTags> {
    static schema: FEntitySchema = {
        name: 'DiscoverUserPickedTags',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'id', type: 'string' },
        ],
        fields: [
            { name: 'deleted', type: 'boolean' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['uid', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('discoverUserPickedTags');
        let config = { enableVersioning: true, enableTimestamps: true, validator: DiscoverUserPickedTagsFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('discoverUserPickedTags', 'user'), 'user', ['uid', 'id'], true, (src) => !src.deleted);
        let indexes = {
            user: indexUser,
        };
        return new DiscoverUserPickedTagsFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('id', src.id);
        validators.isString('id', src.id);
        validators.notNull('deleted', src.deleted);
        validators.isBoolean('deleted', src.deleted);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('DiscoverUserPickedTags', 'discoverUserPickedTags', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'id': rawId[1] };
    }
    async findById(ctx: Context, uid: number, id: string) {
        return await this._findById(ctx, [uid, id]);
    }
    async create(ctx: Context, uid: number, id: string, shape: DiscoverUserPickedTagsShape) {
        return await this._create(ctx, [uid, id], { uid, id, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, id: string, shape: DiscoverUserPickedTagsShape) {
        return await this._create_UNSAFE(ctx, [uid, id], { uid, id, ...shape });
    }
    watch(ctx: Context, uid: number, id: string) {
        return this._watch(ctx, [uid, id]);
    }
    async findFromUser(ctx: Context, uid: number, id: string) {
        return await this._findFromIndex(ctx, this.indexUser.directory, [uid, id]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new DiscoverUserPickedTags(ctx, this.layer, this.directory, [value.uid, value.id], value, this.options, isNew, this.indexes, 'DiscoverUserPickedTags');
    }
}
export interface DebugEventShape {
    key?: string| null;
}

export class DebugEvent extends FEntity {
    readonly entityName: 'DebugEvent' = 'DebugEvent';
    get uid(): number { return this._value.uid; }
    get seq(): number { return this._value.seq; }
    get key(): string | null {
        let res = this._value.key;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set key(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
}

export class DebugEventFactory extends FEntityFactory<DebugEvent> {
    static schema: FEntitySchema = {
        name: 'DebugEvent',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'string' },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('debugEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: DebugEventFactory.validate, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('debugEvent', 'user'), 'user', ['uid', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new DebugEventFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isString('key', src.key);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('DebugEvent', 'debugEvent', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, uid: number, seq: number) {
        return await this._findById(ctx, [uid, seq]);
    }
    async create(ctx: Context, uid: number, seq: number, shape: DebugEventShape) {
        return await this._create(ctx, [uid, seq], { uid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, seq: number, shape: DebugEventShape) {
        return await this._create_UNSAFE(ctx, [uid, seq], { uid, seq, ...shape });
    }
    watch(ctx: Context, uid: number, seq: number) {
        return this._watch(ctx, [uid, seq]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    createUserLiveStream(ctx: Context, uid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new DebugEvent(ctx, this.layer, this.directory, [value.uid, value.seq], value, this.options, isNew, this.indexes, 'DebugEvent');
    }
}
export interface DebugEventStateShape {
    seq: number;
}

export class DebugEventState extends FEntity {
    readonly entityName: 'DebugEventState' = 'DebugEventState';
    get uid(): number { return this._value.uid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class DebugEventStateFactory extends FEntityFactory<DebugEventState> {
    static schema: FEntitySchema = {
        name: 'DebugEventState',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('debugEventState');
        let config = { enableVersioning: true, enableTimestamps: true, validator: DebugEventStateFactory.validate, hasLiveStreams: false };
        return new DebugEventStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('DebugEventState', 'debugEventState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0] };
    }
    async findById(ctx: Context, uid: number) {
        return await this._findById(ctx, [uid]);
    }
    async create(ctx: Context, uid: number, shape: DebugEventStateShape) {
        return await this._create(ctx, [uid], { uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, shape: DebugEventStateShape) {
        return await this._create_UNSAFE(ctx, [uid], { uid, ...shape });
    }
    watch(ctx: Context, uid: number) {
        return this._watch(ctx, [uid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new DebugEventState(ctx, this.layer, this.directory, [value.uid], value, this.options, isNew, this.indexes, 'DebugEventState');
    }
}
export interface NotificationCenterShape {
    kind: 'user';
}

export class NotificationCenter extends FEntity {
    readonly entityName: 'NotificationCenter' = 'NotificationCenter';
    get id(): number { return this._value.id; }
    get kind(): 'user' {
        return this._value.kind;
    }
    set kind(value: 'user') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class NotificationCenterFactory extends FEntityFactory<NotificationCenter> {
    static schema: FEntitySchema = {
        name: 'NotificationCenter',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['user'] },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('notificationCenter');
        let config = { enableVersioning: true, enableTimestamps: true, validator: NotificationCenterFactory.validate, hasLiveStreams: false };
        return new NotificationCenterFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['user']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('NotificationCenter', 'notificationCenter', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: NotificationCenterShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: NotificationCenterShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new NotificationCenter(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'NotificationCenter');
    }
}
export interface UserNotificationCenterShape {
    uid: number;
}

export class UserNotificationCenter extends FEntity {
    readonly entityName: 'UserNotificationCenter' = 'UserNotificationCenter';
    get id(): number { return this._value.id; }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
}

export class UserNotificationCenterFactory extends FEntityFactory<UserNotificationCenter> {
    static schema: FEntitySchema = {
        name: 'UserNotificationCenter',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
        ],
        indexes: [
            { name: 'user', type: 'unique', fields: ['uid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('userNotificationCenter');
        let config = { enableVersioning: true, enableTimestamps: true, validator: UserNotificationCenterFactory.validate, hasLiveStreams: false };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('userNotificationCenter', 'user'), 'user', ['uid'], true);
        let indexes = {
            user: indexUser,
        };
        return new UserNotificationCenterFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('UserNotificationCenter', 'userNotificationCenter', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: UserNotificationCenterShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: UserNotificationCenterShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromUser(ctx: Context, uid: number) {
        return await this._findFromIndex(ctx, this.indexUser.directory, [uid]);
    }
    async rangeFromUser(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [], limit, after, reversed);
    }
    async allFromUser(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUser.directory, []);
    }
    createUserStream(limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new UserNotificationCenter(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'UserNotificationCenter');
    }
}
export interface NotificationShape {
    ncid: number;
    text?: string| null;
    deleted?: boolean| null;
    content?: ({ type: 'new_comment', commentId: number, })[]| null;
}

export class Notification extends FEntity {
    readonly entityName: 'Notification' = 'Notification';
    get id(): number { return this._value.id; }
    get ncid(): number {
        return this._value.ncid;
    }
    set ncid(value: number) {
        this._checkIsWritable();
        if (value === this._value.ncid) { return; }
        this._value.ncid = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get content(): ({ type: 'new_comment', commentId: number, })[] | null {
        let res = this._value.content;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set content(value: ({ type: 'new_comment', commentId: number, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.content) { return; }
        this._value.content = value;
        this.markDirty();
    }
}

export class NotificationFactory extends FEntityFactory<Notification> {
    static schema: FEntitySchema = {
        name: 'Notification',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'ncid', type: 'number' },
            { name: 'text', type: 'string', secure: true },
            { name: 'deleted', type: 'boolean' },
            { name: 'content', type: 'json' },
        ],
        indexes: [
            { name: 'notificationCenter', type: 'range', fields: ['ncid', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('notification');
        let config = { enableVersioning: true, enableTimestamps: true, validator: NotificationFactory.validate, hasLiveStreams: false };
        let indexNotificationCenter = new FEntityIndex(await layer.resolveEntityIndexDirectory('notification', 'notificationCenter'), 'notificationCenter', ['ncid', 'id'], false, (src) => !src.deleted);
        let indexes = {
            notificationCenter: indexNotificationCenter,
        };
        return new NotificationFactory(layer, directory, config, indexes);
    }

    readonly indexNotificationCenter: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('ncid', src.ncid);
        validators.isNumber('ncid', src.ncid);
        validators.isString('text', src.text);
        validators.isBoolean('deleted', src.deleted);
        validators.isJson('content', src.content, jVec(jEnum(
            json(() => {
                jField('type', jString('new_comment'));
                jField('commentId', jNumber());
            })
        )));
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { notificationCenter: FEntityIndex }) {
        super('Notification', 'notification', config, [indexes.notificationCenter], layer, directory);
        this.indexNotificationCenter = indexes.notificationCenter;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: NotificationShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: NotificationShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromNotificationCenterAfter(ctx: Context, ncid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexNotificationCenter.directory, [ncid], after);
    }
    async rangeFromNotificationCenterAfter(ctx: Context, ncid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexNotificationCenter.directory, [ncid], after, limit, reversed);
    }
    async rangeFromNotificationCenter(ctx: Context, ncid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexNotificationCenter.directory, [ncid], limit, reversed);
    }
    async rangeFromNotificationCenterWithCursor(ctx: Context, ncid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexNotificationCenter.directory, [ncid], limit, after, reversed);
    }
    async allFromNotificationCenter(ctx: Context, ncid: number) {
        return await this._findAll(ctx, this.indexNotificationCenter.directory, [ncid]);
    }
    createNotificationCenterStream(ncid: number, limit: number, after?: string) {
        return this._createStream(this.indexNotificationCenter.directory, [ncid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Notification(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Notification');
    }
}
export interface NotificationCenterStateShape {
    seq: number;
    readNotificationId?: number| null;
    readSeq?: number| null;
    lastEmailNotification?: number| null;
    lastPushNotification?: number| null;
    lastEmailSeq?: number| null;
    lastPushSeq?: number| null;
}

export class NotificationCenterState extends FEntity {
    readonly entityName: 'NotificationCenterState' = 'NotificationCenterState';
    get ncid(): number { return this._value.ncid; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
    get readNotificationId(): number | null {
        let res = this._value.readNotificationId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readNotificationId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readNotificationId) { return; }
        this._value.readNotificationId = value;
        this.markDirty();
    }
    get readSeq(): number | null {
        let res = this._value.readSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set readSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.readSeq) { return; }
        this._value.readSeq = value;
        this.markDirty();
    }
    get lastEmailNotification(): number | null {
        let res = this._value.lastEmailNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailNotification) { return; }
        this._value.lastEmailNotification = value;
        this.markDirty();
    }
    get lastPushNotification(): number | null {
        let res = this._value.lastPushNotification;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushNotification(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushNotification) { return; }
        this._value.lastPushNotification = value;
        this.markDirty();
    }
    get lastEmailSeq(): number | null {
        let res = this._value.lastEmailSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastEmailSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastEmailSeq) { return; }
        this._value.lastEmailSeq = value;
        this.markDirty();
    }
    get lastPushSeq(): number | null {
        let res = this._value.lastPushSeq;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set lastPushSeq(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.lastPushSeq) { return; }
        this._value.lastPushSeq = value;
        this.markDirty();
    }
}

export class NotificationCenterStateFactory extends FEntityFactory<NotificationCenterState> {
    static schema: FEntitySchema = {
        name: 'NotificationCenterState',
        editable: false,
        primaryKeys: [
            { name: 'ncid', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
            { name: 'readNotificationId', type: 'number' },
            { name: 'readSeq', type: 'number' },
            { name: 'lastEmailNotification', type: 'number' },
            { name: 'lastPushNotification', type: 'number' },
            { name: 'lastEmailSeq', type: 'number' },
            { name: 'lastPushSeq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('notificationCenterState');
        let config = { enableVersioning: true, enableTimestamps: true, validator: NotificationCenterStateFactory.validate, hasLiveStreams: false };
        return new NotificationCenterStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('ncid', src.ncid);
        validators.isNumber('ncid', src.ncid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('readNotificationId', src.readNotificationId);
        validators.isNumber('readSeq', src.readSeq);
        validators.isNumber('lastEmailNotification', src.lastEmailNotification);
        validators.isNumber('lastPushNotification', src.lastPushNotification);
        validators.isNumber('lastEmailSeq', src.lastEmailSeq);
        validators.isNumber('lastPushSeq', src.lastPushSeq);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('NotificationCenterState', 'notificationCenterState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'ncid': rawId[0] };
    }
    async findById(ctx: Context, ncid: number) {
        return await this._findById(ctx, [ncid]);
    }
    async create(ctx: Context, ncid: number, shape: NotificationCenterStateShape) {
        return await this._create(ctx, [ncid], { ncid, ...shape });
    }
    async create_UNSAFE(ctx: Context, ncid: number, shape: NotificationCenterStateShape) {
        return await this._create_UNSAFE(ctx, [ncid], { ncid, ...shape });
    }
    watch(ctx: Context, ncid: number) {
        return this._watch(ctx, [ncid]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new NotificationCenterState(ctx, this.layer, this.directory, [value.ncid], value, this.options, isNew, this.indexes, 'NotificationCenterState');
    }
}
export interface NotificationCenterEventShape {
    notificationId?: number| null;
    updatedContent?: { type: 'comment', peerId: number, peerType: string, commentId: number | null, }| null;
    kind: 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated';
}

export class NotificationCenterEvent extends FEntity {
    readonly entityName: 'NotificationCenterEvent' = 'NotificationCenterEvent';
    get ncid(): number { return this._value.ncid; }
    get seq(): number { return this._value.seq; }
    get notificationId(): number | null {
        let res = this._value.notificationId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set notificationId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.notificationId) { return; }
        this._value.notificationId = value;
        this.markDirty();
    }
    get updatedContent(): { type: 'comment', peerId: number, peerType: string, commentId: number | null, } | null {
        let res = this._value.updatedContent;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set updatedContent(value: { type: 'comment', peerId: number, peerType: string, commentId: number | null, } | null) {
        this._checkIsWritable();
        if (value === this._value.updatedContent) { return; }
        this._value.updatedContent = value;
        this.markDirty();
    }
    get kind(): 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated' {
        return this._value.kind;
    }
    set kind(value: 'notification_received' | 'notification_read' | 'notification_deleted' | 'notification_updated' | 'notification_content_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class NotificationCenterEventFactory extends FEntityFactory<NotificationCenterEvent> {
    static schema: FEntitySchema = {
        name: 'NotificationCenterEvent',
        editable: false,
        primaryKeys: [
            { name: 'ncid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'notificationId', type: 'number' },
            { name: 'updatedContent', type: 'json' },
            { name: 'kind', type: 'enum', enumValues: ['notification_received', 'notification_read', 'notification_deleted', 'notification_updated', 'notification_content_updated'] },
        ],
        indexes: [
            { name: 'notificationCenter', type: 'range', fields: ['ncid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('notificationCenterEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: NotificationCenterEventFactory.validate, hasLiveStreams: true };
        let indexNotificationCenter = new FEntityIndex(await layer.resolveEntityIndexDirectory('notificationCenterEvent', 'notificationCenter'), 'notificationCenter', ['ncid', 'seq'], false);
        let indexes = {
            notificationCenter: indexNotificationCenter,
        };
        return new NotificationCenterEventFactory(layer, directory, config, indexes);
    }

    readonly indexNotificationCenter: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('ncid', src.ncid);
        validators.isNumber('ncid', src.ncid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('notificationId', src.notificationId);
        validators.isJson('updatedContent', src.updatedContent, jEnum(
            json(() => {
                jField('type', jString('comment'));
                jField('peerId', jNumber());
                jField('peerType', jString());
                jField('commentId', jNumber()).nullable();
            })
        ));
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['notification_received', 'notification_read', 'notification_deleted', 'notification_updated', 'notification_content_updated']);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { notificationCenter: FEntityIndex }) {
        super('NotificationCenterEvent', 'notificationCenterEvent', config, [indexes.notificationCenter], layer, directory);
        this.indexNotificationCenter = indexes.notificationCenter;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'ncid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, ncid: number, seq: number) {
        return await this._findById(ctx, [ncid, seq]);
    }
    async create(ctx: Context, ncid: number, seq: number, shape: NotificationCenterEventShape) {
        return await this._create(ctx, [ncid, seq], { ncid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, ncid: number, seq: number, shape: NotificationCenterEventShape) {
        return await this._create_UNSAFE(ctx, [ncid, seq], { ncid, seq, ...shape });
    }
    watch(ctx: Context, ncid: number, seq: number) {
        return this._watch(ctx, [ncid, seq]);
    }
    async allFromNotificationCenterAfter(ctx: Context, ncid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexNotificationCenter.directory, [ncid], after);
    }
    async rangeFromNotificationCenterAfter(ctx: Context, ncid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexNotificationCenter.directory, [ncid], after, limit, reversed);
    }
    async rangeFromNotificationCenter(ctx: Context, ncid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexNotificationCenter.directory, [ncid], limit, reversed);
    }
    async rangeFromNotificationCenterWithCursor(ctx: Context, ncid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexNotificationCenter.directory, [ncid], limit, after, reversed);
    }
    async allFromNotificationCenter(ctx: Context, ncid: number) {
        return await this._findAll(ctx, this.indexNotificationCenter.directory, [ncid]);
    }
    createNotificationCenterStream(ncid: number, limit: number, after?: string) {
        return this._createStream(this.indexNotificationCenter.directory, [ncid], limit, after); 
    }
    createNotificationCenterLiveStream(ctx: Context, ncid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexNotificationCenter.directory, [ncid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new NotificationCenterEvent(ctx, this.layer, this.directory, [value.ncid, value.seq], value, this.options, isNew, this.indexes, 'NotificationCenterEvent');
    }
}
export interface ChatAudienceCalculatingQueueShape {
    active: boolean;
    delta: number;
}

export class ChatAudienceCalculatingQueue extends FEntity {
    readonly entityName: 'ChatAudienceCalculatingQueue' = 'ChatAudienceCalculatingQueue';
    get id(): number { return this._value.id; }
    get active(): boolean {
        return this._value.active;
    }
    set active(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.active) { return; }
        this._value.active = value;
        this.markDirty();
    }
    get delta(): number {
        return this._value.delta;
    }
    set delta(value: number) {
        this._checkIsWritable();
        if (value === this._value.delta) { return; }
        this._value.delta = value;
        this.markDirty();
    }
}

export class ChatAudienceCalculatingQueueFactory extends FEntityFactory<ChatAudienceCalculatingQueue> {
    static schema: FEntitySchema = {
        name: 'ChatAudienceCalculatingQueue',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'active', type: 'boolean' },
            { name: 'delta', type: 'number' },
        ],
        indexes: [
            { name: 'active', type: 'range', fields: ['createdAt'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('chatAudienceCalculatingQueue');
        let config = { enableVersioning: true, enableTimestamps: true, validator: ChatAudienceCalculatingQueueFactory.validate, hasLiveStreams: false };
        let indexActive = new FEntityIndex(await layer.resolveEntityIndexDirectory('chatAudienceCalculatingQueue', 'active'), 'active', ['createdAt'], false, (src) => !!src.active);
        let indexes = {
            active: indexActive,
        };
        return new ChatAudienceCalculatingQueueFactory(layer, directory, config, indexes);
    }

    readonly indexActive: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('active', src.active);
        validators.isBoolean('active', src.active);
        validators.notNull('delta', src.delta);
        validators.isNumber('delta', src.delta);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { active: FEntityIndex }) {
        super('ChatAudienceCalculatingQueue', 'chatAudienceCalculatingQueue', config, [indexes.active], layer, directory);
        this.indexActive = indexes.active;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ChatAudienceCalculatingQueueShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ChatAudienceCalculatingQueueShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async rangeFromActive(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexActive.directory, [], limit, reversed);
    }
    async rangeFromActiveWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexActive.directory, [], limit, after, reversed);
    }
    async allFromActive(ctx: Context, ) {
        return await this._findAll(ctx, this.indexActive.directory, []);
    }
    createActiveStream(limit: number, after?: string) {
        return this._createStream(this.indexActive.directory, [], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ChatAudienceCalculatingQueue(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ChatAudienceCalculatingQueue');
    }
}

export interface AllEntities {
    readonly layer: EntityLayer;
    readonly allEntities: FEntityFactory<FEntity>[];
    readonly NeedNotificationFlagDirectory: Directory;
    readonly NotificationCenterNeedDeliveryFlagDirectory: Directory;
    readonly Environment: EnvironmentFactory;
    readonly EnvironmentVariable: EnvironmentVariableFactory;
    readonly Online: OnlineFactory;
    readonly Presence: PresenceFactory;
    readonly AuthToken: AuthTokenFactory;
    readonly ServiceCache: ServiceCacheFactory;
    readonly Lock: LockFactory;
    readonly Task: TaskFactory;
    readonly DelayedTask: DelayedTaskFactory;
    readonly PushFirebase: PushFirebaseFactory;
    readonly PushApple: PushAppleFactory;
    readonly PushWeb: PushWebFactory;
    readonly PushSafari: PushSafariFactory;
    readonly UserProfilePrefil: UserProfilePrefilFactory;
    readonly User: UserFactory;
    readonly UserProfile: UserProfileFactory;
    readonly UserIndexingQueue: UserIndexingQueueFactory;
    readonly Organization: OrganizationFactory;
    readonly OrganizationProfile: OrganizationProfileFactory;
    readonly OrganizationEditorial: OrganizationEditorialFactory;
    readonly OrganizationIndexingQueue: OrganizationIndexingQueueFactory;
    readonly OrganizationMember: OrganizationMemberFactory;
    readonly FeatureFlag: FeatureFlagFactory;
    readonly OrganizationFeatures: OrganizationFeaturesFactory;
    readonly ReaderState: ReaderStateFactory;
    readonly SuperAdmin: SuperAdminFactory;
    readonly UserSettings: UserSettingsFactory;
    readonly ShortnameReservation: ShortnameReservationFactory;
    readonly AuthCodeSession: AuthCodeSessionFactory;
    readonly Conversation: ConversationFactory;
    readonly ConversationPrivate: ConversationPrivateFactory;
    readonly ConversationOrganization: ConversationOrganizationFactory;
    readonly ConversationRoom: ConversationRoomFactory;
    readonly RoomProfile: RoomProfileFactory;
    readonly RoomParticipant: RoomParticipantFactory;
    readonly ConversationReceiver: ConversationReceiverFactory;
    readonly Sequence: SequenceFactory;
    readonly Message: MessageFactory;
    readonly Comment: CommentFactory;
    readonly CommentState: CommentStateFactory;
    readonly CommentSeq: CommentSeqFactory;
    readonly CommentEvent: CommentEventFactory;
    readonly CommentsSubscription: CommentsSubscriptionFactory;
    readonly CommentEventGlobal: CommentEventGlobalFactory;
    readonly CommentGlobalEventSeq: CommentGlobalEventSeqFactory;
    readonly ConversationSeq: ConversationSeqFactory;
    readonly ConversationEvent: ConversationEventFactory;
    readonly UserDialog: UserDialogFactory;
    readonly UserDialogHandledMessage: UserDialogHandledMessageFactory;
    readonly UserDialogSettings: UserDialogSettingsFactory;
    readonly UserDialogEvent: UserDialogEventFactory;
    readonly UserMessagingState: UserMessagingStateFactory;
    readonly UserNotificationsState: UserNotificationsStateFactory;
    readonly HyperLog: HyperLogFactory;
    readonly MessageDraft: MessageDraftFactory;
    readonly ChannelInvitation: ChannelInvitationFactory;
    readonly ChannelLink: ChannelLinkFactory;
    readonly AppInviteLink: AppInviteLinkFactory;
    readonly SampleEntity: SampleEntityFactory;
    readonly OrganizationPublicInviteLink: OrganizationPublicInviteLinkFactory;
    readonly OrganizationInviteLink: OrganizationInviteLinkFactory;
    readonly ConferenceRoom: ConferenceRoomFactory;
    readonly ConferencePeer: ConferencePeerFactory;
    readonly ConferenceMediaStream: ConferenceMediaStreamFactory;
    readonly ConferenceConnection: ConferenceConnectionFactory;
    readonly UserEdge: UserEdgeFactory;
    readonly UserInfluencerUserIndex: UserInfluencerUserIndexFactory;
    readonly UserInfluencerIndex: UserInfluencerIndexFactory;
    readonly FeedSubscriber: FeedSubscriberFactory;
    readonly FeedSubscription: FeedSubscriptionFactory;
    readonly FeedTopic: FeedTopicFactory;
    readonly FeedEvent: FeedEventFactory;
    readonly AppHook: AppHookFactory;
    readonly UserStorageNamespace: UserStorageNamespaceFactory;
    readonly UserStorageRecord: UserStorageRecordFactory;
    readonly DiscoverUserPickedTags: DiscoverUserPickedTagsFactory;
    readonly DebugEvent: DebugEventFactory;
    readonly DebugEventState: DebugEventStateFactory;
    readonly NotificationCenter: NotificationCenterFactory;
    readonly UserNotificationCenter: UserNotificationCenterFactory;
    readonly Notification: NotificationFactory;
    readonly NotificationCenterState: NotificationCenterStateFactory;
    readonly NotificationCenterEvent: NotificationCenterEventFactory;
    readonly ChatAudienceCalculatingQueue: ChatAudienceCalculatingQueueFactory;
}
export class AllEntitiesDirect extends EntitiesBase implements AllEntities {
    static readonly schema: FEntitySchema[] = [
        EnvironmentFactory.schema,
        EnvironmentVariableFactory.schema,
        OnlineFactory.schema,
        PresenceFactory.schema,
        AuthTokenFactory.schema,
        ServiceCacheFactory.schema,
        LockFactory.schema,
        TaskFactory.schema,
        DelayedTaskFactory.schema,
        PushFirebaseFactory.schema,
        PushAppleFactory.schema,
        PushWebFactory.schema,
        PushSafariFactory.schema,
        UserProfilePrefilFactory.schema,
        UserFactory.schema,
        UserProfileFactory.schema,
        UserIndexingQueueFactory.schema,
        OrganizationFactory.schema,
        OrganizationProfileFactory.schema,
        OrganizationEditorialFactory.schema,
        OrganizationIndexingQueueFactory.schema,
        OrganizationMemberFactory.schema,
        FeatureFlagFactory.schema,
        OrganizationFeaturesFactory.schema,
        ReaderStateFactory.schema,
        SuperAdminFactory.schema,
        UserSettingsFactory.schema,
        ShortnameReservationFactory.schema,
        AuthCodeSessionFactory.schema,
        ConversationFactory.schema,
        ConversationPrivateFactory.schema,
        ConversationOrganizationFactory.schema,
        ConversationRoomFactory.schema,
        RoomProfileFactory.schema,
        RoomParticipantFactory.schema,
        ConversationReceiverFactory.schema,
        SequenceFactory.schema,
        MessageFactory.schema,
        CommentFactory.schema,
        CommentStateFactory.schema,
        CommentSeqFactory.schema,
        CommentEventFactory.schema,
        CommentsSubscriptionFactory.schema,
        CommentEventGlobalFactory.schema,
        CommentGlobalEventSeqFactory.schema,
        ConversationSeqFactory.schema,
        ConversationEventFactory.schema,
        UserDialogFactory.schema,
        UserDialogHandledMessageFactory.schema,
        UserDialogSettingsFactory.schema,
        UserDialogEventFactory.schema,
        UserMessagingStateFactory.schema,
        UserNotificationsStateFactory.schema,
        HyperLogFactory.schema,
        MessageDraftFactory.schema,
        ChannelInvitationFactory.schema,
        ChannelLinkFactory.schema,
        AppInviteLinkFactory.schema,
        SampleEntityFactory.schema,
        OrganizationPublicInviteLinkFactory.schema,
        OrganizationInviteLinkFactory.schema,
        ConferenceRoomFactory.schema,
        ConferencePeerFactory.schema,
        ConferenceMediaStreamFactory.schema,
        ConferenceConnectionFactory.schema,
        UserEdgeFactory.schema,
        UserInfluencerUserIndexFactory.schema,
        UserInfluencerIndexFactory.schema,
        FeedSubscriberFactory.schema,
        FeedSubscriptionFactory.schema,
        FeedTopicFactory.schema,
        FeedEventFactory.schema,
        AppHookFactory.schema,
        UserStorageNamespaceFactory.schema,
        UserStorageRecordFactory.schema,
        DiscoverUserPickedTagsFactory.schema,
        DebugEventFactory.schema,
        DebugEventStateFactory.schema,
        NotificationCenterFactory.schema,
        UserNotificationCenterFactory.schema,
        NotificationFactory.schema,
        NotificationCenterStateFactory.schema,
        NotificationCenterEventFactory.schema,
        ChatAudienceCalculatingQueueFactory.schema,
    ];

    static async create(layer: EntityLayer) {
        let allEntities: FEntityFactory<FEntity>[] = [];
        let EnvironmentPromise = EnvironmentFactory.create(layer);
        let EnvironmentVariablePromise = EnvironmentVariableFactory.create(layer);
        let OnlinePromise = OnlineFactory.create(layer);
        let PresencePromise = PresenceFactory.create(layer);
        let AuthTokenPromise = AuthTokenFactory.create(layer);
        let ServiceCachePromise = ServiceCacheFactory.create(layer);
        let LockPromise = LockFactory.create(layer);
        let TaskPromise = TaskFactory.create(layer);
        let DelayedTaskPromise = DelayedTaskFactory.create(layer);
        let PushFirebasePromise = PushFirebaseFactory.create(layer);
        let PushApplePromise = PushAppleFactory.create(layer);
        let PushWebPromise = PushWebFactory.create(layer);
        let PushSafariPromise = PushSafariFactory.create(layer);
        let UserProfilePrefilPromise = UserProfilePrefilFactory.create(layer);
        let UserPromise = UserFactory.create(layer);
        let UserProfilePromise = UserProfileFactory.create(layer);
        let UserIndexingQueuePromise = UserIndexingQueueFactory.create(layer);
        let OrganizationPromise = OrganizationFactory.create(layer);
        let OrganizationProfilePromise = OrganizationProfileFactory.create(layer);
        let OrganizationEditorialPromise = OrganizationEditorialFactory.create(layer);
        let OrganizationIndexingQueuePromise = OrganizationIndexingQueueFactory.create(layer);
        let OrganizationMemberPromise = OrganizationMemberFactory.create(layer);
        let FeatureFlagPromise = FeatureFlagFactory.create(layer);
        let OrganizationFeaturesPromise = OrganizationFeaturesFactory.create(layer);
        let ReaderStatePromise = ReaderStateFactory.create(layer);
        let SuperAdminPromise = SuperAdminFactory.create(layer);
        let UserSettingsPromise = UserSettingsFactory.create(layer);
        let ShortnameReservationPromise = ShortnameReservationFactory.create(layer);
        let AuthCodeSessionPromise = AuthCodeSessionFactory.create(layer);
        let ConversationPromise = ConversationFactory.create(layer);
        let ConversationPrivatePromise = ConversationPrivateFactory.create(layer);
        let ConversationOrganizationPromise = ConversationOrganizationFactory.create(layer);
        let ConversationRoomPromise = ConversationRoomFactory.create(layer);
        let RoomProfilePromise = RoomProfileFactory.create(layer);
        let RoomParticipantPromise = RoomParticipantFactory.create(layer);
        let ConversationReceiverPromise = ConversationReceiverFactory.create(layer);
        let SequencePromise = SequenceFactory.create(layer);
        let MessagePromise = MessageFactory.create(layer);
        let CommentPromise = CommentFactory.create(layer);
        let CommentStatePromise = CommentStateFactory.create(layer);
        let CommentSeqPromise = CommentSeqFactory.create(layer);
        let CommentEventPromise = CommentEventFactory.create(layer);
        let CommentsSubscriptionPromise = CommentsSubscriptionFactory.create(layer);
        let CommentEventGlobalPromise = CommentEventGlobalFactory.create(layer);
        let CommentGlobalEventSeqPromise = CommentGlobalEventSeqFactory.create(layer);
        let ConversationSeqPromise = ConversationSeqFactory.create(layer);
        let ConversationEventPromise = ConversationEventFactory.create(layer);
        let UserDialogPromise = UserDialogFactory.create(layer);
        let UserDialogHandledMessagePromise = UserDialogHandledMessageFactory.create(layer);
        let UserDialogSettingsPromise = UserDialogSettingsFactory.create(layer);
        let UserDialogEventPromise = UserDialogEventFactory.create(layer);
        let UserMessagingStatePromise = UserMessagingStateFactory.create(layer);
        let UserNotificationsStatePromise = UserNotificationsStateFactory.create(layer);
        let HyperLogPromise = HyperLogFactory.create(layer);
        let MessageDraftPromise = MessageDraftFactory.create(layer);
        let ChannelInvitationPromise = ChannelInvitationFactory.create(layer);
        let ChannelLinkPromise = ChannelLinkFactory.create(layer);
        let AppInviteLinkPromise = AppInviteLinkFactory.create(layer);
        let SampleEntityPromise = SampleEntityFactory.create(layer);
        let OrganizationPublicInviteLinkPromise = OrganizationPublicInviteLinkFactory.create(layer);
        let OrganizationInviteLinkPromise = OrganizationInviteLinkFactory.create(layer);
        let ConferenceRoomPromise = ConferenceRoomFactory.create(layer);
        let ConferencePeerPromise = ConferencePeerFactory.create(layer);
        let ConferenceMediaStreamPromise = ConferenceMediaStreamFactory.create(layer);
        let ConferenceConnectionPromise = ConferenceConnectionFactory.create(layer);
        let UserEdgePromise = UserEdgeFactory.create(layer);
        let UserInfluencerUserIndexPromise = UserInfluencerUserIndexFactory.create(layer);
        let UserInfluencerIndexPromise = UserInfluencerIndexFactory.create(layer);
        let FeedSubscriberPromise = FeedSubscriberFactory.create(layer);
        let FeedSubscriptionPromise = FeedSubscriptionFactory.create(layer);
        let FeedTopicPromise = FeedTopicFactory.create(layer);
        let FeedEventPromise = FeedEventFactory.create(layer);
        let AppHookPromise = AppHookFactory.create(layer);
        let UserStorageNamespacePromise = UserStorageNamespaceFactory.create(layer);
        let UserStorageRecordPromise = UserStorageRecordFactory.create(layer);
        let DiscoverUserPickedTagsPromise = DiscoverUserPickedTagsFactory.create(layer);
        let DebugEventPromise = DebugEventFactory.create(layer);
        let DebugEventStatePromise = DebugEventStateFactory.create(layer);
        let NotificationCenterPromise = NotificationCenterFactory.create(layer);
        let UserNotificationCenterPromise = UserNotificationCenterFactory.create(layer);
        let NotificationPromise = NotificationFactory.create(layer);
        let NotificationCenterStatePromise = NotificationCenterStateFactory.create(layer);
        let NotificationCenterEventPromise = NotificationCenterEventFactory.create(layer);
        let ChatAudienceCalculatingQueuePromise = ChatAudienceCalculatingQueueFactory.create(layer);
        let NeedNotificationFlagDirectoryPromise = layer.resolveCustomDirectory('needNotificationFlag');
        let NotificationCenterNeedDeliveryFlagDirectoryPromise = layer.resolveCustomDirectory('notificationCenterNeedDeliveryFlag');
        allEntities.push(await EnvironmentPromise);
        allEntities.push(await EnvironmentVariablePromise);
        allEntities.push(await OnlinePromise);
        allEntities.push(await PresencePromise);
        allEntities.push(await AuthTokenPromise);
        allEntities.push(await ServiceCachePromise);
        allEntities.push(await LockPromise);
        allEntities.push(await TaskPromise);
        allEntities.push(await DelayedTaskPromise);
        allEntities.push(await PushFirebasePromise);
        allEntities.push(await PushApplePromise);
        allEntities.push(await PushWebPromise);
        allEntities.push(await PushSafariPromise);
        allEntities.push(await UserProfilePrefilPromise);
        allEntities.push(await UserPromise);
        allEntities.push(await UserProfilePromise);
        allEntities.push(await UserIndexingQueuePromise);
        allEntities.push(await OrganizationPromise);
        allEntities.push(await OrganizationProfilePromise);
        allEntities.push(await OrganizationEditorialPromise);
        allEntities.push(await OrganizationIndexingQueuePromise);
        allEntities.push(await OrganizationMemberPromise);
        allEntities.push(await FeatureFlagPromise);
        allEntities.push(await OrganizationFeaturesPromise);
        allEntities.push(await ReaderStatePromise);
        allEntities.push(await SuperAdminPromise);
        allEntities.push(await UserSettingsPromise);
        allEntities.push(await ShortnameReservationPromise);
        allEntities.push(await AuthCodeSessionPromise);
        allEntities.push(await ConversationPromise);
        allEntities.push(await ConversationPrivatePromise);
        allEntities.push(await ConversationOrganizationPromise);
        allEntities.push(await ConversationRoomPromise);
        allEntities.push(await RoomProfilePromise);
        allEntities.push(await RoomParticipantPromise);
        allEntities.push(await ConversationReceiverPromise);
        allEntities.push(await SequencePromise);
        allEntities.push(await MessagePromise);
        allEntities.push(await CommentPromise);
        allEntities.push(await CommentStatePromise);
        allEntities.push(await CommentSeqPromise);
        allEntities.push(await CommentEventPromise);
        allEntities.push(await CommentsSubscriptionPromise);
        allEntities.push(await CommentEventGlobalPromise);
        allEntities.push(await CommentGlobalEventSeqPromise);
        allEntities.push(await ConversationSeqPromise);
        allEntities.push(await ConversationEventPromise);
        allEntities.push(await UserDialogPromise);
        allEntities.push(await UserDialogHandledMessagePromise);
        allEntities.push(await UserDialogSettingsPromise);
        allEntities.push(await UserDialogEventPromise);
        allEntities.push(await UserMessagingStatePromise);
        allEntities.push(await UserNotificationsStatePromise);
        allEntities.push(await HyperLogPromise);
        allEntities.push(await MessageDraftPromise);
        allEntities.push(await ChannelInvitationPromise);
        allEntities.push(await ChannelLinkPromise);
        allEntities.push(await AppInviteLinkPromise);
        allEntities.push(await SampleEntityPromise);
        allEntities.push(await OrganizationPublicInviteLinkPromise);
        allEntities.push(await OrganizationInviteLinkPromise);
        allEntities.push(await ConferenceRoomPromise);
        allEntities.push(await ConferencePeerPromise);
        allEntities.push(await ConferenceMediaStreamPromise);
        allEntities.push(await ConferenceConnectionPromise);
        allEntities.push(await UserEdgePromise);
        allEntities.push(await UserInfluencerUserIndexPromise);
        allEntities.push(await UserInfluencerIndexPromise);
        allEntities.push(await FeedSubscriberPromise);
        allEntities.push(await FeedSubscriptionPromise);
        allEntities.push(await FeedTopicPromise);
        allEntities.push(await FeedEventPromise);
        allEntities.push(await AppHookPromise);
        allEntities.push(await UserStorageNamespacePromise);
        allEntities.push(await UserStorageRecordPromise);
        allEntities.push(await DiscoverUserPickedTagsPromise);
        allEntities.push(await DebugEventPromise);
        allEntities.push(await DebugEventStatePromise);
        allEntities.push(await NotificationCenterPromise);
        allEntities.push(await UserNotificationCenterPromise);
        allEntities.push(await NotificationPromise);
        allEntities.push(await NotificationCenterStatePromise);
        allEntities.push(await NotificationCenterEventPromise);
        allEntities.push(await ChatAudienceCalculatingQueuePromise);
        let entities = {
            layer, allEntities,
            Environment: await EnvironmentPromise,
            EnvironmentVariable: await EnvironmentVariablePromise,
            Online: await OnlinePromise,
            Presence: await PresencePromise,
            AuthToken: await AuthTokenPromise,
            ServiceCache: await ServiceCachePromise,
            Lock: await LockPromise,
            Task: await TaskPromise,
            DelayedTask: await DelayedTaskPromise,
            PushFirebase: await PushFirebasePromise,
            PushApple: await PushApplePromise,
            PushWeb: await PushWebPromise,
            PushSafari: await PushSafariPromise,
            UserProfilePrefil: await UserProfilePrefilPromise,
            User: await UserPromise,
            UserProfile: await UserProfilePromise,
            UserIndexingQueue: await UserIndexingQueuePromise,
            Organization: await OrganizationPromise,
            OrganizationProfile: await OrganizationProfilePromise,
            OrganizationEditorial: await OrganizationEditorialPromise,
            OrganizationIndexingQueue: await OrganizationIndexingQueuePromise,
            OrganizationMember: await OrganizationMemberPromise,
            FeatureFlag: await FeatureFlagPromise,
            OrganizationFeatures: await OrganizationFeaturesPromise,
            ReaderState: await ReaderStatePromise,
            SuperAdmin: await SuperAdminPromise,
            UserSettings: await UserSettingsPromise,
            ShortnameReservation: await ShortnameReservationPromise,
            AuthCodeSession: await AuthCodeSessionPromise,
            Conversation: await ConversationPromise,
            ConversationPrivate: await ConversationPrivatePromise,
            ConversationOrganization: await ConversationOrganizationPromise,
            ConversationRoom: await ConversationRoomPromise,
            RoomProfile: await RoomProfilePromise,
            RoomParticipant: await RoomParticipantPromise,
            ConversationReceiver: await ConversationReceiverPromise,
            Sequence: await SequencePromise,
            Message: await MessagePromise,
            Comment: await CommentPromise,
            CommentState: await CommentStatePromise,
            CommentSeq: await CommentSeqPromise,
            CommentEvent: await CommentEventPromise,
            CommentsSubscription: await CommentsSubscriptionPromise,
            CommentEventGlobal: await CommentEventGlobalPromise,
            CommentGlobalEventSeq: await CommentGlobalEventSeqPromise,
            ConversationSeq: await ConversationSeqPromise,
            ConversationEvent: await ConversationEventPromise,
            UserDialog: await UserDialogPromise,
            UserDialogHandledMessage: await UserDialogHandledMessagePromise,
            UserDialogSettings: await UserDialogSettingsPromise,
            UserDialogEvent: await UserDialogEventPromise,
            UserMessagingState: await UserMessagingStatePromise,
            UserNotificationsState: await UserNotificationsStatePromise,
            HyperLog: await HyperLogPromise,
            MessageDraft: await MessageDraftPromise,
            ChannelInvitation: await ChannelInvitationPromise,
            ChannelLink: await ChannelLinkPromise,
            AppInviteLink: await AppInviteLinkPromise,
            SampleEntity: await SampleEntityPromise,
            OrganizationPublicInviteLink: await OrganizationPublicInviteLinkPromise,
            OrganizationInviteLink: await OrganizationInviteLinkPromise,
            ConferenceRoom: await ConferenceRoomPromise,
            ConferencePeer: await ConferencePeerPromise,
            ConferenceMediaStream: await ConferenceMediaStreamPromise,
            ConferenceConnection: await ConferenceConnectionPromise,
            UserEdge: await UserEdgePromise,
            UserInfluencerUserIndex: await UserInfluencerUserIndexPromise,
            UserInfluencerIndex: await UserInfluencerIndexPromise,
            FeedSubscriber: await FeedSubscriberPromise,
            FeedSubscription: await FeedSubscriptionPromise,
            FeedTopic: await FeedTopicPromise,
            FeedEvent: await FeedEventPromise,
            AppHook: await AppHookPromise,
            UserStorageNamespace: await UserStorageNamespacePromise,
            UserStorageRecord: await UserStorageRecordPromise,
            DiscoverUserPickedTags: await DiscoverUserPickedTagsPromise,
            DebugEvent: await DebugEventPromise,
            DebugEventState: await DebugEventStatePromise,
            NotificationCenter: await NotificationCenterPromise,
            UserNotificationCenter: await UserNotificationCenterPromise,
            Notification: await NotificationPromise,
            NotificationCenterState: await NotificationCenterStatePromise,
            NotificationCenterEvent: await NotificationCenterEventPromise,
            ChatAudienceCalculatingQueue: await ChatAudienceCalculatingQueuePromise,
            NeedNotificationFlagDirectory: await NeedNotificationFlagDirectoryPromise,
            NotificationCenterNeedDeliveryFlagDirectory: await NotificationCenterNeedDeliveryFlagDirectoryPromise,
        };
        return new AllEntitiesDirect(entities);
    }

    readonly allEntities: FEntityFactory<FEntity>[] = [];
    readonly NeedNotificationFlagDirectory: Directory;
    readonly NotificationCenterNeedDeliveryFlagDirectory: Directory;
    readonly Environment: EnvironmentFactory;
    readonly EnvironmentVariable: EnvironmentVariableFactory;
    readonly Online: OnlineFactory;
    readonly Presence: PresenceFactory;
    readonly AuthToken: AuthTokenFactory;
    readonly ServiceCache: ServiceCacheFactory;
    readonly Lock: LockFactory;
    readonly Task: TaskFactory;
    readonly DelayedTask: DelayedTaskFactory;
    readonly PushFirebase: PushFirebaseFactory;
    readonly PushApple: PushAppleFactory;
    readonly PushWeb: PushWebFactory;
    readonly PushSafari: PushSafariFactory;
    readonly UserProfilePrefil: UserProfilePrefilFactory;
    readonly User: UserFactory;
    readonly UserProfile: UserProfileFactory;
    readonly UserIndexingQueue: UserIndexingQueueFactory;
    readonly Organization: OrganizationFactory;
    readonly OrganizationProfile: OrganizationProfileFactory;
    readonly OrganizationEditorial: OrganizationEditorialFactory;
    readonly OrganizationIndexingQueue: OrganizationIndexingQueueFactory;
    readonly OrganizationMember: OrganizationMemberFactory;
    readonly FeatureFlag: FeatureFlagFactory;
    readonly OrganizationFeatures: OrganizationFeaturesFactory;
    readonly ReaderState: ReaderStateFactory;
    readonly SuperAdmin: SuperAdminFactory;
    readonly UserSettings: UserSettingsFactory;
    readonly ShortnameReservation: ShortnameReservationFactory;
    readonly AuthCodeSession: AuthCodeSessionFactory;
    readonly Conversation: ConversationFactory;
    readonly ConversationPrivate: ConversationPrivateFactory;
    readonly ConversationOrganization: ConversationOrganizationFactory;
    readonly ConversationRoom: ConversationRoomFactory;
    readonly RoomProfile: RoomProfileFactory;
    readonly RoomParticipant: RoomParticipantFactory;
    readonly ConversationReceiver: ConversationReceiverFactory;
    readonly Sequence: SequenceFactory;
    readonly Message: MessageFactory;
    readonly Comment: CommentFactory;
    readonly CommentState: CommentStateFactory;
    readonly CommentSeq: CommentSeqFactory;
    readonly CommentEvent: CommentEventFactory;
    readonly CommentsSubscription: CommentsSubscriptionFactory;
    readonly CommentEventGlobal: CommentEventGlobalFactory;
    readonly CommentGlobalEventSeq: CommentGlobalEventSeqFactory;
    readonly ConversationSeq: ConversationSeqFactory;
    readonly ConversationEvent: ConversationEventFactory;
    readonly UserDialog: UserDialogFactory;
    readonly UserDialogHandledMessage: UserDialogHandledMessageFactory;
    readonly UserDialogSettings: UserDialogSettingsFactory;
    readonly UserDialogEvent: UserDialogEventFactory;
    readonly UserMessagingState: UserMessagingStateFactory;
    readonly UserNotificationsState: UserNotificationsStateFactory;
    readonly HyperLog: HyperLogFactory;
    readonly MessageDraft: MessageDraftFactory;
    readonly ChannelInvitation: ChannelInvitationFactory;
    readonly ChannelLink: ChannelLinkFactory;
    readonly AppInviteLink: AppInviteLinkFactory;
    readonly SampleEntity: SampleEntityFactory;
    readonly OrganizationPublicInviteLink: OrganizationPublicInviteLinkFactory;
    readonly OrganizationInviteLink: OrganizationInviteLinkFactory;
    readonly ConferenceRoom: ConferenceRoomFactory;
    readonly ConferencePeer: ConferencePeerFactory;
    readonly ConferenceMediaStream: ConferenceMediaStreamFactory;
    readonly ConferenceConnection: ConferenceConnectionFactory;
    readonly UserEdge: UserEdgeFactory;
    readonly UserInfluencerUserIndex: UserInfluencerUserIndexFactory;
    readonly UserInfluencerIndex: UserInfluencerIndexFactory;
    readonly FeedSubscriber: FeedSubscriberFactory;
    readonly FeedSubscription: FeedSubscriptionFactory;
    readonly FeedTopic: FeedTopicFactory;
    readonly FeedEvent: FeedEventFactory;
    readonly AppHook: AppHookFactory;
    readonly UserStorageNamespace: UserStorageNamespaceFactory;
    readonly UserStorageRecord: UserStorageRecordFactory;
    readonly DiscoverUserPickedTags: DiscoverUserPickedTagsFactory;
    readonly DebugEvent: DebugEventFactory;
    readonly DebugEventState: DebugEventStateFactory;
    readonly NotificationCenter: NotificationCenterFactory;
    readonly UserNotificationCenter: UserNotificationCenterFactory;
    readonly Notification: NotificationFactory;
    readonly NotificationCenterState: NotificationCenterStateFactory;
    readonly NotificationCenterEvent: NotificationCenterEventFactory;
    readonly ChatAudienceCalculatingQueue: ChatAudienceCalculatingQueueFactory;

    private constructor(entities: AllEntities) {
        super(entities.layer);
        this.Environment = entities.Environment;
        this.allEntities.push(this.Environment);
        this.EnvironmentVariable = entities.EnvironmentVariable;
        this.allEntities.push(this.EnvironmentVariable);
        this.Online = entities.Online;
        this.allEntities.push(this.Online);
        this.Presence = entities.Presence;
        this.allEntities.push(this.Presence);
        this.AuthToken = entities.AuthToken;
        this.allEntities.push(this.AuthToken);
        this.ServiceCache = entities.ServiceCache;
        this.allEntities.push(this.ServiceCache);
        this.Lock = entities.Lock;
        this.allEntities.push(this.Lock);
        this.Task = entities.Task;
        this.allEntities.push(this.Task);
        this.DelayedTask = entities.DelayedTask;
        this.allEntities.push(this.DelayedTask);
        this.PushFirebase = entities.PushFirebase;
        this.allEntities.push(this.PushFirebase);
        this.PushApple = entities.PushApple;
        this.allEntities.push(this.PushApple);
        this.PushWeb = entities.PushWeb;
        this.allEntities.push(this.PushWeb);
        this.PushSafari = entities.PushSafari;
        this.allEntities.push(this.PushSafari);
        this.UserProfilePrefil = entities.UserProfilePrefil;
        this.allEntities.push(this.UserProfilePrefil);
        this.User = entities.User;
        this.allEntities.push(this.User);
        this.UserProfile = entities.UserProfile;
        this.allEntities.push(this.UserProfile);
        this.UserIndexingQueue = entities.UserIndexingQueue;
        this.allEntities.push(this.UserIndexingQueue);
        this.Organization = entities.Organization;
        this.allEntities.push(this.Organization);
        this.OrganizationProfile = entities.OrganizationProfile;
        this.allEntities.push(this.OrganizationProfile);
        this.OrganizationEditorial = entities.OrganizationEditorial;
        this.allEntities.push(this.OrganizationEditorial);
        this.OrganizationIndexingQueue = entities.OrganizationIndexingQueue;
        this.allEntities.push(this.OrganizationIndexingQueue);
        this.OrganizationMember = entities.OrganizationMember;
        this.allEntities.push(this.OrganizationMember);
        this.FeatureFlag = entities.FeatureFlag;
        this.allEntities.push(this.FeatureFlag);
        this.OrganizationFeatures = entities.OrganizationFeatures;
        this.allEntities.push(this.OrganizationFeatures);
        this.ReaderState = entities.ReaderState;
        this.allEntities.push(this.ReaderState);
        this.SuperAdmin = entities.SuperAdmin;
        this.allEntities.push(this.SuperAdmin);
        this.UserSettings = entities.UserSettings;
        this.allEntities.push(this.UserSettings);
        this.ShortnameReservation = entities.ShortnameReservation;
        this.allEntities.push(this.ShortnameReservation);
        this.AuthCodeSession = entities.AuthCodeSession;
        this.allEntities.push(this.AuthCodeSession);
        this.Conversation = entities.Conversation;
        this.allEntities.push(this.Conversation);
        this.ConversationPrivate = entities.ConversationPrivate;
        this.allEntities.push(this.ConversationPrivate);
        this.ConversationOrganization = entities.ConversationOrganization;
        this.allEntities.push(this.ConversationOrganization);
        this.ConversationRoom = entities.ConversationRoom;
        this.allEntities.push(this.ConversationRoom);
        this.RoomProfile = entities.RoomProfile;
        this.allEntities.push(this.RoomProfile);
        this.RoomParticipant = entities.RoomParticipant;
        this.allEntities.push(this.RoomParticipant);
        this.ConversationReceiver = entities.ConversationReceiver;
        this.allEntities.push(this.ConversationReceiver);
        this.Sequence = entities.Sequence;
        this.allEntities.push(this.Sequence);
        this.Message = entities.Message;
        this.allEntities.push(this.Message);
        this.Comment = entities.Comment;
        this.allEntities.push(this.Comment);
        this.CommentState = entities.CommentState;
        this.allEntities.push(this.CommentState);
        this.CommentSeq = entities.CommentSeq;
        this.allEntities.push(this.CommentSeq);
        this.CommentEvent = entities.CommentEvent;
        this.allEntities.push(this.CommentEvent);
        this.CommentsSubscription = entities.CommentsSubscription;
        this.allEntities.push(this.CommentsSubscription);
        this.CommentEventGlobal = entities.CommentEventGlobal;
        this.allEntities.push(this.CommentEventGlobal);
        this.CommentGlobalEventSeq = entities.CommentGlobalEventSeq;
        this.allEntities.push(this.CommentGlobalEventSeq);
        this.ConversationSeq = entities.ConversationSeq;
        this.allEntities.push(this.ConversationSeq);
        this.ConversationEvent = entities.ConversationEvent;
        this.allEntities.push(this.ConversationEvent);
        this.UserDialog = entities.UserDialog;
        this.allEntities.push(this.UserDialog);
        this.UserDialogHandledMessage = entities.UserDialogHandledMessage;
        this.allEntities.push(this.UserDialogHandledMessage);
        this.UserDialogSettings = entities.UserDialogSettings;
        this.allEntities.push(this.UserDialogSettings);
        this.UserDialogEvent = entities.UserDialogEvent;
        this.allEntities.push(this.UserDialogEvent);
        this.UserMessagingState = entities.UserMessagingState;
        this.allEntities.push(this.UserMessagingState);
        this.UserNotificationsState = entities.UserNotificationsState;
        this.allEntities.push(this.UserNotificationsState);
        this.HyperLog = entities.HyperLog;
        this.allEntities.push(this.HyperLog);
        this.MessageDraft = entities.MessageDraft;
        this.allEntities.push(this.MessageDraft);
        this.ChannelInvitation = entities.ChannelInvitation;
        this.allEntities.push(this.ChannelInvitation);
        this.ChannelLink = entities.ChannelLink;
        this.allEntities.push(this.ChannelLink);
        this.AppInviteLink = entities.AppInviteLink;
        this.allEntities.push(this.AppInviteLink);
        this.SampleEntity = entities.SampleEntity;
        this.allEntities.push(this.SampleEntity);
        this.OrganizationPublicInviteLink = entities.OrganizationPublicInviteLink;
        this.allEntities.push(this.OrganizationPublicInviteLink);
        this.OrganizationInviteLink = entities.OrganizationInviteLink;
        this.allEntities.push(this.OrganizationInviteLink);
        this.ConferenceRoom = entities.ConferenceRoom;
        this.allEntities.push(this.ConferenceRoom);
        this.ConferencePeer = entities.ConferencePeer;
        this.allEntities.push(this.ConferencePeer);
        this.ConferenceMediaStream = entities.ConferenceMediaStream;
        this.allEntities.push(this.ConferenceMediaStream);
        this.ConferenceConnection = entities.ConferenceConnection;
        this.allEntities.push(this.ConferenceConnection);
        this.UserEdge = entities.UserEdge;
        this.allEntities.push(this.UserEdge);
        this.UserInfluencerUserIndex = entities.UserInfluencerUserIndex;
        this.allEntities.push(this.UserInfluencerUserIndex);
        this.UserInfluencerIndex = entities.UserInfluencerIndex;
        this.allEntities.push(this.UserInfluencerIndex);
        this.FeedSubscriber = entities.FeedSubscriber;
        this.allEntities.push(this.FeedSubscriber);
        this.FeedSubscription = entities.FeedSubscription;
        this.allEntities.push(this.FeedSubscription);
        this.FeedTopic = entities.FeedTopic;
        this.allEntities.push(this.FeedTopic);
        this.FeedEvent = entities.FeedEvent;
        this.allEntities.push(this.FeedEvent);
        this.AppHook = entities.AppHook;
        this.allEntities.push(this.AppHook);
        this.UserStorageNamespace = entities.UserStorageNamespace;
        this.allEntities.push(this.UserStorageNamespace);
        this.UserStorageRecord = entities.UserStorageRecord;
        this.allEntities.push(this.UserStorageRecord);
        this.DiscoverUserPickedTags = entities.DiscoverUserPickedTags;
        this.allEntities.push(this.DiscoverUserPickedTags);
        this.DebugEvent = entities.DebugEvent;
        this.allEntities.push(this.DebugEvent);
        this.DebugEventState = entities.DebugEventState;
        this.allEntities.push(this.DebugEventState);
        this.NotificationCenter = entities.NotificationCenter;
        this.allEntities.push(this.NotificationCenter);
        this.UserNotificationCenter = entities.UserNotificationCenter;
        this.allEntities.push(this.UserNotificationCenter);
        this.Notification = entities.Notification;
        this.allEntities.push(this.Notification);
        this.NotificationCenterState = entities.NotificationCenterState;
        this.allEntities.push(this.NotificationCenterState);
        this.NotificationCenterEvent = entities.NotificationCenterEvent;
        this.allEntities.push(this.NotificationCenterEvent);
        this.ChatAudienceCalculatingQueue = entities.ChatAudienceCalculatingQueue;
        this.allEntities.push(this.ChatAudienceCalculatingQueue);
        this.NeedNotificationFlagDirectory = entities.NeedNotificationFlagDirectory;
        this.NotificationCenterNeedDeliveryFlagDirectory = entities.NotificationCenterNeedDeliveryFlagDirectory;
    }
}
