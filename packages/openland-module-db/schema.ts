// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { EntitiesBase } from 'foundation-orm/EntitiesBase';
// @ts-ignore
import { Subspace, Directory, Tuple } from '@openland/foundationdb';
// @ts-ignore
import { FEntity, FEntityOptions } from 'foundation-orm/FEntity';
// @ts-ignore
import { FEntitySchema } from 'foundation-orm/FEntitySchema';
// @ts-ignore
import { FEntityIndex } from 'foundation-orm/FEntityIndex';
// @ts-ignore
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
// @ts-ignore
import { FConnection } from 'foundation-orm/FConnection';
// @ts-ignore
import { validators } from 'foundation-orm/utils/validators';
// @ts-ignore
import { EntityLayer } from 'foundation-orm/EntityLayer';
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { json, jField, jNumber, jString, jBool, jVec, jEnum, jEnumString } from 'openland-utils/jsonSchema';

export interface MessageShape {
    cid: number;
    uid: number;
    repeatKey?: string| null;
    text?: string| null;
    replyMessages?: (number)[]| null;
    serviceMetadata?: any| null;
    reactions?: ({ userId: number, reaction: string, })[]| null;
    edited?: boolean| null;
    isMuted: boolean;
    isService: boolean;
    deleted?: boolean| null;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[]| null;
    attachmentsModern?: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[]| null;
    fileId?: string| null;
    fileMetadata?: { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, }| null;
    filePreview?: string| null;
    augmentation?: any| null;
    mentions?: any| null;
    attachments?: any| null;
    buttons?: any| null;
    type?: string| null;
    title?: string| null;
    postType?: string| null;
    complexMentions?: any| null;
}

export class Message extends FEntity {
    readonly entityName: 'Message' = 'Message';
    get id(): number { return this._value.id; }
    get cid(): number {
        return this._value.cid;
    }
    set cid(value: number) {
        this._checkIsWritable();
        if (value === this._value.cid) { return; }
        this._value.cid = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get repeatKey(): string | null {
        let res = this._value.repeatKey;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set repeatKey(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.repeatKey) { return; }
        this._value.repeatKey = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get replyMessages(): (number)[] | null {
        let res = this._value.replyMessages;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set replyMessages(value: (number)[] | null) {
        this._checkIsWritable();
        if (value === this._value.replyMessages) { return; }
        this._value.replyMessages = value;
        this.markDirty();
    }
    get serviceMetadata(): any | null {
        let res = this._value.serviceMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set serviceMetadata(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.serviceMetadata) { return; }
        this._value.serviceMetadata = value;
        this.markDirty();
    }
    get reactions(): ({ userId: number, reaction: string, })[] | null {
        let res = this._value.reactions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set reactions(value: ({ userId: number, reaction: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.reactions) { return; }
        this._value.reactions = value;
        this.markDirty();
    }
    get edited(): boolean | null {
        let res = this._value.edited;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set edited(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.edited) { return; }
        this._value.edited = value;
        this.markDirty();
    }
    get isMuted(): boolean {
        return this._value.isMuted;
    }
    set isMuted(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isMuted) { return; }
        this._value.isMuted = value;
        this.markDirty();
    }
    get isService(): boolean {
        return this._value.isService;
    }
    set isService(value: boolean) {
        this._checkIsWritable();
        if (value === this._value.isService) { return; }
        this._value.isService = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null {
        let res = this._value.spans;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.spans) { return; }
        this._value.spans = value;
        this.markDirty();
    }
    get attachmentsModern(): ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null {
        let res = this._value.attachmentsModern;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachmentsModern(value: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.attachmentsModern) { return; }
        this._value.attachmentsModern = value;
        this.markDirty();
    }
    get fileId(): string | null {
        let res = this._value.fileId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileId(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.fileId) { return; }
        this._value.fileId = value;
        this.markDirty();
    }
    get fileMetadata(): { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null {
        let res = this._value.fileMetadata;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set fileMetadata(value: { isStored: boolean | undefined, isImage: boolean | null, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null) {
        this._checkIsWritable();
        if (value === this._value.fileMetadata) { return; }
        this._value.fileMetadata = value;
        this.markDirty();
    }
    get filePreview(): string | null {
        let res = this._value.filePreview;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set filePreview(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.filePreview) { return; }
        this._value.filePreview = value;
        this.markDirty();
    }
    get augmentation(): any | null {
        let res = this._value.augmentation;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set augmentation(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.augmentation) { return; }
        this._value.augmentation = value;
        this.markDirty();
    }
    get mentions(): any | null {
        let res = this._value.mentions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set mentions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.mentions) { return; }
        this._value.mentions = value;
        this.markDirty();
    }
    get attachments(): any | null {
        let res = this._value.attachments;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachments(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.attachments) { return; }
        this._value.attachments = value;
        this.markDirty();
    }
    get buttons(): any | null {
        let res = this._value.buttons;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set buttons(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.buttons) { return; }
        this._value.buttons = value;
        this.markDirty();
    }
    get type(): string | null {
        let res = this._value.type;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set type(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.type) { return; }
        this._value.type = value;
        this.markDirty();
    }
    get title(): string | null {
        let res = this._value.title;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set title(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.title) { return; }
        this._value.title = value;
        this.markDirty();
    }
    get postType(): string | null {
        let res = this._value.postType;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set postType(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.postType) { return; }
        this._value.postType = value;
        this.markDirty();
    }
    get complexMentions(): any | null {
        let res = this._value.complexMentions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set complexMentions(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.complexMentions) { return; }
        this._value.complexMentions = value;
        this.markDirty();
    }
}

export class MessageFactory extends FEntityFactory<Message> {
    static schema: FEntitySchema = {
        name: 'Message',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'cid', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'repeatKey', type: 'string' },
            { name: 'text', type: 'string', secure: true },
            { name: 'replyMessages', type: 'json' },
            { name: 'serviceMetadata', type: 'json' },
            { name: 'reactions', type: 'json' },
            { name: 'edited', type: 'boolean' },
            { name: 'isMuted', type: 'boolean' },
            { name: 'isService', type: 'boolean' },
            { name: 'deleted', type: 'boolean' },
            { name: 'spans', type: 'json' },
            { name: 'attachmentsModern', type: 'json' },
            { name: 'fileId', type: 'string', secure: true },
            { name: 'fileMetadata', type: 'json', secure: true },
            { name: 'filePreview', type: 'string', secure: true },
            { name: 'augmentation', type: 'json' },
            { name: 'mentions', type: 'json' },
            { name: 'attachments', type: 'json' },
            { name: 'buttons', type: 'json' },
            { name: 'type', type: 'string' },
            { name: 'title', type: 'string' },
            { name: 'postType', type: 'string' },
            { name: 'complexMentions', type: 'json' },
        ],
        indexes: [
            { name: 'chat', type: 'range', fields: ['cid', 'id'] },
            { name: 'updated', type: 'range', fields: ['updatedAt'] },
            { name: 'repeat', type: 'unique', fields: ['uid', 'cid', 'repeatKey'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('message');
        let config = { enableVersioning: true, enableTimestamps: true, validator: MessageFactory.validate, keyValidator: MessageFactory.validateKey, hasLiveStreams: false };
        let indexChat = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'chat'), 'chat', ['cid', 'id'], false, (src) => !src.deleted);
        let indexUpdated = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'updated'), 'updated', ['updatedAt'], false);
        let indexRepeat = new FEntityIndex(await layer.resolveEntityIndexDirectory('message', 'repeat'), 'repeat', ['uid', 'cid', 'repeatKey'], true, (src) => !!src.repeatKey);
        let indexes = {
            chat: indexChat,
            updated: indexUpdated,
            repeat: indexRepeat,
        };
        return new MessageFactory(layer, directory, config, indexes);
    }

    readonly indexChat: FEntityIndex;
    readonly indexUpdated: FEntityIndex;
    readonly indexRepeat: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('cid', src.cid);
        validators.isNumber('cid', src.cid);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('repeatKey', src.repeatKey);
        validators.isString('text', src.text);
        validators.isJson('replyMessages', src.replyMessages, jVec(jNumber()));
        validators.isJson('reactions', src.reactions, jVec(json(() => {
            jField('userId', jNumber());
            jField('reaction', jString());
        })));
        validators.isBoolean('edited', src.edited);
        validators.notNull('isMuted', src.isMuted);
        validators.isBoolean('isMuted', src.isMuted);
        validators.notNull('isService', src.isService);
        validators.isBoolean('isService', src.isService);
        validators.isBoolean('deleted', src.deleted);
        validators.isJson('spans', src.spans, jVec(jEnum(
            json(() => {
                jField('type', jString('user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('user', jNumber());
            }), 
            json(() => {
                jField('type', jString('multi_user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('users', jVec(jNumber()));
            }), 
            json(() => {
                jField('type', jString('room_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('room', jNumber());
            }), 
            json(() => {
                jField('type', jString('link'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('url', jString());
            }), 
            json(() => {
                jField('type', jString('bold_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('italic_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('irony_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('inline_code_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('code_block_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('insane_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('loud_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('rotating_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('date_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('date', jNumber());
            }), 
            json(() => {
                jField('type', jString('all_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
            })
        )));
        validators.isJson('attachmentsModern', src.attachmentsModern, jVec(jEnum(
            json(() => {
                jField('type', jString('file_attachment'));
                jField('fileId', jString());
                jField('filePreview', jString()).nullable();
                jField('fileMetadata', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('id', jString());
            }), 
            json(() => {
                jField('type', jString('rich_attachment'));
                jField('title', jString()).nullable();
                jField('subTitle', jString()).nullable();
                jField('titleLink', jString()).nullable();
                jField('text', jString()).nullable();
                jField('icon', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('image', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('iconInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('imageInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('titleLinkHostname', jString()).nullable();
                jField('keyboard', json(() => {
                jField('buttons', jVec(jVec(json(() => {
                jField('title', jString());
                jField('style', jEnumString('DEFAULT', 'LIGHT'));
                jField('url', jString()).nullable();
            }))));
            })).nullable();
                jField('id', jString());
            })
        )));
        validators.isString('fileId', src.fileId);
        validators.isJson('fileMetadata', src.fileMetadata, json(() => {
            jField('isStored', jBool()).undefinable();
            jField('isImage', jBool()).nullable();
            jField('imageWidth', jNumber()).nullable();
            jField('imageHeight', jNumber()).nullable();
            jField('imageFormat', jString()).nullable();
            jField('mimeType', jString());
            jField('name', jString());
            jField('size', jNumber());
        }));
        validators.isString('filePreview', src.filePreview);
        validators.isString('type', src.type);
        validators.isString('title', src.title);
        validators.isString('postType', src.postType);
    }

    private static validateKey(key: Tuple[]) {
        validators.isNumber('0', key[0]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { chat: FEntityIndex, updated: FEntityIndex, repeat: FEntityIndex }) {
        super('Message', 'message', config, [indexes.chat, indexes.updated, indexes.repeat], layer, directory);
        this.indexChat = indexes.chat;
        this.indexUpdated = indexes.updated;
        this.indexRepeat = indexes.repeat;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: MessageShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: MessageShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromChatAfter(ctx: Context, cid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChat.directory, [cid], after);
    }
    async rangeFromChatAfter(ctx: Context, cid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChat.directory, [cid], after, limit, reversed);
    }
    async rangeFromChat(ctx: Context, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChat.directory, [cid], limit, reversed);
    }
    async rangeFromChatWithCursor(ctx: Context, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChat.directory, [cid], limit, after, reversed);
    }
    async allFromChat(ctx: Context, cid: number) {
        return await this._findAll(ctx, this.indexChat.directory, [cid]);
    }
    createChatStream(cid: number, limit: number, after?: string) {
        return this._createStream(this.indexChat.directory, [cid], limit, after); 
    }
    async rangeFromUpdated(ctx: Context, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUpdated.directory, [], limit, reversed);
    }
    async rangeFromUpdatedWithCursor(ctx: Context, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUpdated.directory, [], limit, after, reversed);
    }
    async allFromUpdated(ctx: Context, ) {
        return await this._findAll(ctx, this.indexUpdated.directory, []);
    }
    createUpdatedStream(limit: number, after?: string) {
        return this._createStream(this.indexUpdated.directory, [], limit, after); 
    }
    async findFromRepeat(ctx: Context, uid: number, cid: number, repeatKey: string) {
        return await this._findFromIndex(ctx, this.indexRepeat.directory, [uid, cid, repeatKey]);
    }
    async allFromRepeatAfter(ctx: Context, uid: number, cid: number, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexRepeat.directory, [uid, cid], after);
    }
    async rangeFromRepeatAfter(ctx: Context, uid: number, cid: number, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexRepeat.directory, [uid, cid], after, limit, reversed);
    }
    async rangeFromRepeat(ctx: Context, uid: number, cid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexRepeat.directory, [uid, cid], limit, reversed);
    }
    async rangeFromRepeatWithCursor(ctx: Context, uid: number, cid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexRepeat.directory, [uid, cid], limit, after, reversed);
    }
    async allFromRepeat(ctx: Context, uid: number, cid: number) {
        return await this._findAll(ctx, this.indexRepeat.directory, [uid, cid]);
    }
    createRepeatStream(uid: number, cid: number, limit: number, after?: string) {
        return this._createStream(this.indexRepeat.directory, [uid, cid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Message(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Message');
    }
}
export interface CommentShape {
    peerId: number;
    peerType: 'message';
    parentCommentId?: number| null;
    uid: number;
    text?: string| null;
    reactions?: ({ userId: number, reaction: string, })[]| null;
    spans?: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[]| null;
    attachments?: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[]| null;
    deleted?: boolean| null;
    edited?: boolean| null;
    visible?: boolean| null;
}

export class Comment extends FEntity {
    readonly entityName: 'Comment' = 'Comment';
    get id(): number { return this._value.id; }
    get peerId(): number {
        return this._value.peerId;
    }
    set peerId(value: number) {
        this._checkIsWritable();
        if (value === this._value.peerId) { return; }
        this._value.peerId = value;
        this.markDirty();
    }
    get peerType(): 'message' {
        return this._value.peerType;
    }
    set peerType(value: 'message') {
        this._checkIsWritable();
        if (value === this._value.peerType) { return; }
        this._value.peerType = value;
        this.markDirty();
    }
    get parentCommentId(): number | null {
        let res = this._value.parentCommentId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set parentCommentId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.parentCommentId) { return; }
        this._value.parentCommentId = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get text(): string | null {
        let res = this._value.text;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set text(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.text) { return; }
        this._value.text = value;
        this.markDirty();
    }
    get reactions(): ({ userId: number, reaction: string, })[] | null {
        let res = this._value.reactions;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set reactions(value: ({ userId: number, reaction: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.reactions) { return; }
        this._value.reactions = value;
        this.markDirty();
    }
    get spans(): ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null {
        let res = this._value.spans;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set spans(value: ({ type: 'user_mention', offset: number, length: number, user: number, } | { type: 'multi_user_mention', offset: number, length: number, users: (number)[], } | { type: 'room_mention', offset: number, length: number, room: number, } | { type: 'link', offset: number, length: number, url: string, } | { type: 'bold_text', offset: number, length: number, } | { type: 'italic_text', offset: number, length: number, } | { type: 'irony_text', offset: number, length: number, } | { type: 'inline_code_text', offset: number, length: number, } | { type: 'code_block_text', offset: number, length: number, } | { type: 'insane_text', offset: number, length: number, } | { type: 'loud_text', offset: number, length: number, } | { type: 'rotating_text', offset: number, length: number, } | { type: 'date_text', offset: number, length: number, date: number, } | { type: 'all_mention', offset: number, length: number, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.spans) { return; }
        this._value.spans = value;
        this.markDirty();
    }
    get attachments(): ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null {
        let res = this._value.attachments;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set attachments(value: ({ type: 'file_attachment', fileId: string, filePreview: string | null, fileMetadata: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, id: string, } | { type: 'rich_attachment', title: string | null, subTitle: string | null, titleLink: string | null, text: string | null, icon: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, image: { uuid: string, crop: { x: number, y: number, w: number, h: number, } | null, } | null, iconInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, imageInfo: { isImage: boolean, isStored: boolean, imageWidth: number | null, imageHeight: number | null, imageFormat: string | null, mimeType: string, name: string, size: number, } | null, titleLinkHostname: string | null, keyboard: { buttons: (({ title: string, style: 'DEFAULT' | 'LIGHT', url: string | null, })[])[], } | null, id: string, })[] | null) {
        this._checkIsWritable();
        if (value === this._value.attachments) { return; }
        this._value.attachments = value;
        this.markDirty();
    }
    get deleted(): boolean | null {
        let res = this._value.deleted;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set deleted(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.deleted) { return; }
        this._value.deleted = value;
        this.markDirty();
    }
    get edited(): boolean | null {
        let res = this._value.edited;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set edited(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.edited) { return; }
        this._value.edited = value;
        this.markDirty();
    }
    get visible(): boolean | null {
        let res = this._value.visible;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set visible(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.visible) { return; }
        this._value.visible = value;
        this.markDirty();
    }
}

export class CommentFactory extends FEntityFactory<Comment> {
    static schema: FEntitySchema = {
        name: 'Comment',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'peerId', type: 'number' },
            { name: 'peerType', type: 'enum', enumValues: ['message'] },
            { name: 'parentCommentId', type: 'number' },
            { name: 'uid', type: 'number' },
            { name: 'text', type: 'string', secure: true },
            { name: 'reactions', type: 'json' },
            { name: 'spans', type: 'json' },
            { name: 'attachments', type: 'json' },
            { name: 'deleted', type: 'boolean' },
            { name: 'edited', type: 'boolean' },
            { name: 'visible', type: 'boolean' },
        ],
        indexes: [
            { name: 'peer', type: 'range', fields: ['peerType', 'peerId', 'id'] },
            { name: 'child', type: 'range', fields: ['parentCommentId', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('comment');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentFactory.validate, keyValidator: CommentFactory.validateKey, hasLiveStreams: false };
        let indexPeer = new FEntityIndex(await layer.resolveEntityIndexDirectory('comment', 'peer'), 'peer', ['peerType', 'peerId', 'id'], false);
        let indexChild = new FEntityIndex(await layer.resolveEntityIndexDirectory('comment', 'child'), 'child', ['parentCommentId', 'id'], false);
        let indexes = {
            peer: indexPeer,
            child: indexChild,
        };
        return new CommentFactory(layer, directory, config, indexes);
    }

    readonly indexPeer: FEntityIndex;
    readonly indexChild: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('peerType', src.peerType);
        validators.isEnum('peerType', src.peerType, ['message']);
        validators.isNumber('parentCommentId', src.parentCommentId);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.isString('text', src.text);
        validators.isJson('reactions', src.reactions, jVec(json(() => {
            jField('userId', jNumber());
            jField('reaction', jString());
        })));
        validators.isJson('spans', src.spans, jVec(jEnum(
            json(() => {
                jField('type', jString('user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('user', jNumber());
            }), 
            json(() => {
                jField('type', jString('multi_user_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('users', jVec(jNumber()));
            }), 
            json(() => {
                jField('type', jString('room_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('room', jNumber());
            }), 
            json(() => {
                jField('type', jString('link'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('url', jString());
            }), 
            json(() => {
                jField('type', jString('bold_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('italic_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('irony_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('inline_code_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('code_block_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('insane_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('loud_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('rotating_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
            }), 
            json(() => {
                jField('type', jString('date_text'));
                jField('offset', jNumber());
                jField('length', jNumber());
                jField('date', jNumber());
            }), 
            json(() => {
                jField('type', jString('all_mention'));
                jField('offset', jNumber());
                jField('length', jNumber());
            })
        )));
        validators.isJson('attachments', src.attachments, jVec(jEnum(
            json(() => {
                jField('type', jString('file_attachment'));
                jField('fileId', jString());
                jField('filePreview', jString()).nullable();
                jField('fileMetadata', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('id', jString());
            }), 
            json(() => {
                jField('type', jString('rich_attachment'));
                jField('title', jString()).nullable();
                jField('subTitle', jString()).nullable();
                jField('titleLink', jString()).nullable();
                jField('text', jString()).nullable();
                jField('icon', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('image', json(() => {
                jField('uuid', jString());
                jField('crop', json(() => {
                jField('x', jNumber());
                jField('y', jNumber());
                jField('w', jNumber());
                jField('h', jNumber());
            })).nullable();
            })).nullable();
                jField('iconInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('imageInfo', json(() => {
                jField('isImage', jBool());
                jField('isStored', jBool());
                jField('imageWidth', jNumber()).nullable();
                jField('imageHeight', jNumber()).nullable();
                jField('imageFormat', jString()).nullable();
                jField('mimeType', jString());
                jField('name', jString());
                jField('size', jNumber());
            })).nullable();
                jField('titleLinkHostname', jString()).nullable();
                jField('keyboard', json(() => {
                jField('buttons', jVec(jVec(json(() => {
                jField('title', jString());
                jField('style', jEnumString('DEFAULT', 'LIGHT'));
                jField('url', jString()).nullable();
            }))));
            })).nullable();
                jField('id', jString());
            })
        )));
        validators.isBoolean('deleted', src.deleted);
        validators.isBoolean('edited', src.edited);
        validators.isBoolean('visible', src.visible);
    }

    private static validateKey(key: Tuple[]) {
        validators.isNumber('0', key[0]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { peer: FEntityIndex, child: FEntityIndex }) {
        super('Comment', 'comment', config, [indexes.peer, indexes.child], layer, directory);
        this.indexPeer = indexes.peer;
        this.indexChild = indexes.child;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: CommentShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: CommentShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromPeerAfter(ctx: Context, peerType: 'message', peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPeer.directory, [peerType, peerId], after);
    }
    async rangeFromPeerAfter(ctx: Context, peerType: 'message', peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPeer.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromPeer(ctx: Context, peerType: 'message', peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPeer.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromPeerWithCursor(ctx: Context, peerType: 'message', peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPeer.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromPeer(ctx: Context, peerType: 'message', peerId: number) {
        return await this._findAll(ctx, this.indexPeer.directory, [peerType, peerId]);
    }
    createPeerStream(peerType: 'message', peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexPeer.directory, [peerType, peerId], limit, after); 
    }
    async allFromChildAfter(ctx: Context, parentCommentId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexChild.directory, [parentCommentId], after);
    }
    async rangeFromChildAfter(ctx: Context, parentCommentId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexChild.directory, [parentCommentId], after, limit, reversed);
    }
    async rangeFromChild(ctx: Context, parentCommentId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexChild.directory, [parentCommentId], limit, reversed);
    }
    async rangeFromChildWithCursor(ctx: Context, parentCommentId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexChild.directory, [parentCommentId], limit, after, reversed);
    }
    async allFromChild(ctx: Context, parentCommentId: number) {
        return await this._findAll(ctx, this.indexChild.directory, [parentCommentId]);
    }
    createChildStream(parentCommentId: number, limit: number, after?: string) {
        return this._createStream(this.indexChild.directory, [parentCommentId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new Comment(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'Comment');
    }
}
export interface CommentStateShape {
    commentsCount: number;
}

export class CommentState extends FEntity {
    readonly entityName: 'CommentState' = 'CommentState';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get commentsCount(): number {
        return this._value.commentsCount;
    }
    set commentsCount(value: number) {
        this._checkIsWritable();
        if (value === this._value.commentsCount) { return; }
        this._value.commentsCount = value;
        this.markDirty();
    }
}

export class CommentStateFactory extends FEntityFactory<CommentState> {
    static schema: FEntitySchema = {
        name: 'CommentState',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
        ],
        fields: [
            { name: 'commentsCount', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentState');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentStateFactory.validate, keyValidator: CommentStateFactory.validateKey, hasLiveStreams: false };
        return new CommentStateFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('commentsCount', src.commentsCount);
        validators.isNumber('commentsCount', src.commentsCount);
    }

    private static validateKey(key: Tuple[]) {
        validators.notNull('0', key[0]);
        validators.isString('0', key[0]);
        validators.isNumber('1', key[1]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('CommentState', 'commentState', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1] };
    }
    async findById(ctx: Context, peerType: string, peerId: number) {
        return await this._findById(ctx, [peerType, peerId]);
    }
    async create(ctx: Context, peerType: string, peerId: number, shape: CommentStateShape) {
        return await this._create(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, shape: CommentStateShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number) {
        return this._watch(ctx, [peerType, peerId]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentState(ctx, this.layer, this.directory, [value.peerType, value.peerId], value, this.options, isNew, this.indexes, 'CommentState');
    }
}
export interface CommentSeqShape {
    seq: number;
}

export class CommentSeq extends FEntity {
    readonly entityName: 'CommentSeq' = 'CommentSeq';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get seq(): number {
        return this._value.seq;
    }
    set seq(value: number) {
        this._checkIsWritable();
        if (value === this._value.seq) { return; }
        this._value.seq = value;
        this.markDirty();
    }
}

export class CommentSeqFactory extends FEntityFactory<CommentSeq> {
    static schema: FEntitySchema = {
        name: 'CommentSeq',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
        ],
        fields: [
            { name: 'seq', type: 'number' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentSeq');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentSeqFactory.validate, keyValidator: CommentSeqFactory.validateKey, hasLiveStreams: false };
        return new CommentSeqFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
    }

    private static validateKey(key: Tuple[]) {
        validators.notNull('0', key[0]);
        validators.isString('0', key[0]);
        validators.isNumber('1', key[1]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('CommentSeq', 'commentSeq', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1] };
    }
    async findById(ctx: Context, peerType: string, peerId: number) {
        return await this._findById(ctx, [peerType, peerId]);
    }
    async create(ctx: Context, peerType: string, peerId: number, shape: CommentSeqShape) {
        return await this._create(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, shape: CommentSeqShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId], { peerType, peerId, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number) {
        return this._watch(ctx, [peerType, peerId]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentSeq(ctx, this.layer, this.directory, [value.peerType, value.peerId], value, this.options, isNew, this.indexes, 'CommentSeq');
    }
}
export interface CommentEventShape {
    uid?: number| null;
    commentId?: number| null;
    kind: 'comment_received' | 'comment_updated';
}

export class CommentEvent extends FEntity {
    readonly entityName: 'CommentEvent' = 'CommentEvent';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get seq(): number { return this._value.seq; }
    get uid(): number | null {
        let res = this._value.uid;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set uid(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get commentId(): number | null {
        let res = this._value.commentId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set commentId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.commentId) { return; }
        this._value.commentId = value;
        this.markDirty();
    }
    get kind(): 'comment_received' | 'comment_updated' {
        return this._value.kind;
    }
    set kind(value: 'comment_received' | 'comment_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class CommentEventFactory extends FEntityFactory<CommentEvent> {
    static schema: FEntitySchema = {
        name: 'CommentEvent',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'uid', type: 'number' },
            { name: 'commentId', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['comment_received', 'comment_updated'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['peerType', 'peerId', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentEvent');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentEventFactory.validate, keyValidator: CommentEventFactory.validateKey, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentEvent', 'user'), 'user', ['peerType', 'peerId', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new CommentEventFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isNumber('uid', src.uid);
        validators.isNumber('commentId', src.commentId);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['comment_received', 'comment_updated']);
    }

    private static validateKey(key: Tuple[]) {
        validators.notNull('0', key[0]);
        validators.isString('0', key[0]);
        validators.isNumber('1', key[1]);
        validators.isNumber('2', key[2]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('CommentEvent', 'commentEvent', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 3) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1], 'seq': rawId[2] };
    }
    async findById(ctx: Context, peerType: string, peerId: number, seq: number) {
        return await this._findById(ctx, [peerType, peerId, seq]);
    }
    async create(ctx: Context, peerType: string, peerId: number, seq: number, shape: CommentEventShape) {
        return await this._create(ctx, [peerType, peerId, seq], { peerType, peerId, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, seq: number, shape: CommentEventShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId, seq], { peerType, peerId, seq, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number, seq: number) {
        return this._watch(ctx, [peerType, peerId, seq]);
    }
    async allFromUserAfter(ctx: Context, peerType: string, peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [peerType, peerId], after);
    }
    async rangeFromUserAfter(ctx: Context, peerType: string, peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, peerType: string, peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, peerType: string, peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromUser(ctx: Context, peerType: string, peerId: number) {
        return await this._findAll(ctx, this.indexUser.directory, [peerType, peerId]);
    }
    createUserStream(peerType: string, peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [peerType, peerId], limit, after); 
    }
    createUserLiveStream(ctx: Context, peerType: string, peerId: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [peerType, peerId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentEvent(ctx, this.layer, this.directory, [value.peerType, value.peerId, value.seq], value, this.options, isNew, this.indexes, 'CommentEvent');
    }
}
export interface CommentsSubscriptionShape {
    kind: 'all' | 'direct';
    status: 'active' | 'disabled';
}

export class CommentsSubscription extends FEntity {
    readonly entityName: 'CommentsSubscription' = 'CommentsSubscription';
    get peerType(): string { return this._value.peerType; }
    get peerId(): number { return this._value.peerId; }
    get uid(): number { return this._value.uid; }
    get kind(): 'all' | 'direct' {
        return this._value.kind;
    }
    set kind(value: 'all' | 'direct') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
    get status(): 'active' | 'disabled' {
        return this._value.status;
    }
    set status(value: 'active' | 'disabled') {
        this._checkIsWritable();
        if (value === this._value.status) { return; }
        this._value.status = value;
        this.markDirty();
    }
}

export class CommentsSubscriptionFactory extends FEntityFactory<CommentsSubscription> {
    static schema: FEntitySchema = {
        name: 'CommentsSubscription',
        editable: false,
        primaryKeys: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'uid', type: 'number' },
        ],
        fields: [
            { name: 'kind', type: 'enum', enumValues: ['all', 'direct'] },
            { name: 'status', type: 'enum', enumValues: ['active', 'disabled'] },
        ],
        indexes: [
            { name: 'peer', type: 'range', fields: ['peerType', 'peerId', 'uid'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentsSubscription');
        let config = { enableVersioning: false, enableTimestamps: false, validator: CommentsSubscriptionFactory.validate, keyValidator: CommentsSubscriptionFactory.validateKey, hasLiveStreams: false };
        let indexPeer = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentsSubscription', 'peer'), 'peer', ['peerType', 'peerId', 'uid'], false);
        let indexes = {
            peer: indexPeer,
        };
        return new CommentsSubscriptionFactory(layer, directory, config, indexes);
    }

    readonly indexPeer: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('peerType', src.peerType);
        validators.isString('peerType', src.peerType);
        validators.notNull('peerId', src.peerId);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['all', 'direct']);
        validators.notNull('status', src.status);
        validators.isEnum('status', src.status, ['active', 'disabled']);
    }

    private static validateKey(key: Tuple[]) {
        validators.notNull('0', key[0]);
        validators.isString('0', key[0]);
        validators.isNumber('1', key[1]);
        validators.isNumber('2', key[2]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { peer: FEntityIndex }) {
        super('CommentsSubscription', 'commentsSubscription', config, [indexes.peer], layer, directory);
        this.indexPeer = indexes.peer;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 3) { throw Error('Invalid key length!'); }
        return { 'peerType': rawId[0], 'peerId': rawId[1], 'uid': rawId[2] };
    }
    async findById(ctx: Context, peerType: string, peerId: number, uid: number) {
        return await this._findById(ctx, [peerType, peerId, uid]);
    }
    async create(ctx: Context, peerType: string, peerId: number, uid: number, shape: CommentsSubscriptionShape) {
        return await this._create(ctx, [peerType, peerId, uid], { peerType, peerId, uid, ...shape });
    }
    async create_UNSAFE(ctx: Context, peerType: string, peerId: number, uid: number, shape: CommentsSubscriptionShape) {
        return await this._create_UNSAFE(ctx, [peerType, peerId, uid], { peerType, peerId, uid, ...shape });
    }
    watch(ctx: Context, peerType: string, peerId: number, uid: number) {
        return this._watch(ctx, [peerType, peerId, uid]);
    }
    async allFromPeerAfter(ctx: Context, peerType: string, peerId: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexPeer.directory, [peerType, peerId], after);
    }
    async rangeFromPeerAfter(ctx: Context, peerType: string, peerId: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexPeer.directory, [peerType, peerId], after, limit, reversed);
    }
    async rangeFromPeer(ctx: Context, peerType: string, peerId: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexPeer.directory, [peerType, peerId], limit, reversed);
    }
    async rangeFromPeerWithCursor(ctx: Context, peerType: string, peerId: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexPeer.directory, [peerType, peerId], limit, after, reversed);
    }
    async allFromPeer(ctx: Context, peerType: string, peerId: number) {
        return await this._findAll(ctx, this.indexPeer.directory, [peerType, peerId]);
    }
    createPeerStream(peerType: string, peerId: number, limit: number, after?: string) {
        return this._createStream(this.indexPeer.directory, [peerType, peerId], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentsSubscription(ctx, this.layer, this.directory, [value.peerType, value.peerId, value.uid], value, this.options, isNew, this.indexes, 'CommentsSubscription');
    }
}
export interface CommentEventGlobalShape {
    peerType?: string| null;
    peerId?: number| null;
    kind: 'comments_peer_updated';
}

export class CommentEventGlobal extends FEntity {
    readonly entityName: 'CommentEventGlobal' = 'CommentEventGlobal';
    get uid(): number { return this._value.uid; }
    get seq(): number { return this._value.seq; }
    get peerType(): string | null {
        let res = this._value.peerType;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set peerType(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.peerType) { return; }
        this._value.peerType = value;
        this.markDirty();
    }
    get peerId(): number | null {
        let res = this._value.peerId;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set peerId(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.peerId) { return; }
        this._value.peerId = value;
        this.markDirty();
    }
    get kind(): 'comments_peer_updated' {
        return this._value.kind;
    }
    set kind(value: 'comments_peer_updated') {
        this._checkIsWritable();
        if (value === this._value.kind) { return; }
        this._value.kind = value;
        this.markDirty();
    }
}

export class CommentEventGlobalFactory extends FEntityFactory<CommentEventGlobal> {
    static schema: FEntitySchema = {
        name: 'CommentEventGlobal',
        editable: false,
        primaryKeys: [
            { name: 'uid', type: 'number' },
            { name: 'seq', type: 'number' },
        ],
        fields: [
            { name: 'peerType', type: 'string' },
            { name: 'peerId', type: 'number' },
            { name: 'kind', type: 'enum', enumValues: ['comments_peer_updated'] },
        ],
        indexes: [
            { name: 'user', type: 'range', fields: ['uid', 'seq'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('commentEventGlobal');
        let config = { enableVersioning: true, enableTimestamps: true, validator: CommentEventGlobalFactory.validate, keyValidator: CommentEventGlobalFactory.validateKey, hasLiveStreams: true };
        let indexUser = new FEntityIndex(await layer.resolveEntityIndexDirectory('commentEventGlobal', 'user'), 'user', ['uid', 'seq'], false);
        let indexes = {
            user: indexUser,
        };
        return new CommentEventGlobalFactory(layer, directory, config, indexes);
    }

    readonly indexUser: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('uid', src.uid);
        validators.isNumber('uid', src.uid);
        validators.notNull('seq', src.seq);
        validators.isNumber('seq', src.seq);
        validators.isString('peerType', src.peerType);
        validators.isNumber('peerId', src.peerId);
        validators.notNull('kind', src.kind);
        validators.isEnum('kind', src.kind, ['comments_peer_updated']);
    }

    private static validateKey(key: Tuple[]) {
        validators.isNumber('0', key[0]);
        validators.isNumber('1', key[1]);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { user: FEntityIndex }) {
        super('CommentEventGlobal', 'commentEventGlobal', config, [indexes.user], layer, directory);
        this.indexUser = indexes.user;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 2) { throw Error('Invalid key length!'); }
        return { 'uid': rawId[0], 'seq': rawId[1] };
    }
    async findById(ctx: Context, uid: number, seq: number) {
        return await this._findById(ctx, [uid, seq]);
    }
    async create(ctx: Context, uid: number, seq: number, shape: CommentEventGlobalShape) {
        return await this._create(ctx, [uid, seq], { uid, seq, ...shape });
    }
    async create_UNSAFE(ctx: Context, uid: number, seq: number, shape: CommentEventGlobalShape) {
        return await this._create_UNSAFE(ctx, [uid, seq], { uid, seq, ...shape });
    }
    watch(ctx: Context, uid: number, seq: number) {
        return this._watch(ctx, [uid, seq]);
    }
    async allFromUserAfter(ctx: Context, uid: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUser.directory, [uid], after);
    }
    async rangeFromUserAfter(ctx: Context, uid: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUser.directory, [uid], after, limit, reversed);
    }
    async rangeFromUser(ctx: Context, uid: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUser.directory, [uid], limit, reversed);
    }
    async rangeFromUserWithCursor(ctx: Context, uid: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUser.directory, [uid], limit, after, reversed);
    }
    async allFromUser(ctx: Context, uid: number) {
        return await this._findAll(ctx, this.indexUser.directory, [uid]);
    }
    createUserStream(uid: number, limit: number, after?: string) {
        return this._createStream(this.indexUser.directory, [uid], limit, after); 
    }
    createUserLiveStream(ctx: Context, uid: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUser.directory, [uid], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new CommentEventGlobal(ctx, this.layer, this.directory, [value.uid, value.seq], value, this.options, isNew, this.indexes, 'CommentEventGlobal');
    }
}

export interface AllEntities {
    readonly layer: EntityLayer;
    readonly allEntities: FEntityFactory<FEntity>[];
    readonly Message: MessageFactory;
    readonly Comment: CommentFactory;
    readonly CommentState: CommentStateFactory;
    readonly CommentSeq: CommentSeqFactory;
    readonly CommentEvent: CommentEventFactory;
    readonly CommentsSubscription: CommentsSubscriptionFactory;
    readonly CommentEventGlobal: CommentEventGlobalFactory;
}
export class AllEntitiesDirect extends EntitiesBase implements AllEntities {
    static readonly schema: FEntitySchema[] = [
        MessageFactory.schema,
        CommentFactory.schema,
        CommentStateFactory.schema,
        CommentSeqFactory.schema,
        CommentEventFactory.schema,
        CommentsSubscriptionFactory.schema,
        CommentEventGlobalFactory.schema,
    ];

    static async create(layer: EntityLayer) {
        let allEntities: FEntityFactory<FEntity>[] = [];
        let MessagePromise = MessageFactory.create(layer);
        let CommentPromise = CommentFactory.create(layer);
        let CommentStatePromise = CommentStateFactory.create(layer);
        let CommentSeqPromise = CommentSeqFactory.create(layer);
        let CommentEventPromise = CommentEventFactory.create(layer);
        let CommentsSubscriptionPromise = CommentsSubscriptionFactory.create(layer);
        let CommentEventGlobalPromise = CommentEventGlobalFactory.create(layer);
        allEntities.push(await MessagePromise);
        allEntities.push(await CommentPromise);
        allEntities.push(await CommentStatePromise);
        allEntities.push(await CommentSeqPromise);
        allEntities.push(await CommentEventPromise);
        allEntities.push(await CommentsSubscriptionPromise);
        allEntities.push(await CommentEventGlobalPromise);
        let entities = {
            layer, allEntities,
            Message: await MessagePromise,
            Comment: await CommentPromise,
            CommentState: await CommentStatePromise,
            CommentSeq: await CommentSeqPromise,
            CommentEvent: await CommentEventPromise,
            CommentsSubscription: await CommentsSubscriptionPromise,
            CommentEventGlobal: await CommentEventGlobalPromise,
        };
        return new AllEntitiesDirect(entities);
    }

    readonly allEntities: FEntityFactory<FEntity>[] = [];
    readonly Message: MessageFactory;
    readonly Comment: CommentFactory;
    readonly CommentState: CommentStateFactory;
    readonly CommentSeq: CommentSeqFactory;
    readonly CommentEvent: CommentEventFactory;
    readonly CommentsSubscription: CommentsSubscriptionFactory;
    readonly CommentEventGlobal: CommentEventGlobalFactory;

    private constructor(entities: AllEntities) {
        super(entities.layer);
        this.Message = entities.Message;
        this.allEntities.push(this.Message);
        this.Comment = entities.Comment;
        this.allEntities.push(this.Comment);
        this.CommentState = entities.CommentState;
        this.allEntities.push(this.CommentState);
        this.CommentSeq = entities.CommentSeq;
        this.allEntities.push(this.CommentSeq);
        this.CommentEvent = entities.CommentEvent;
        this.allEntities.push(this.CommentEvent);
        this.CommentsSubscription = entities.CommentsSubscription;
        this.allEntities.push(this.CommentsSubscription);
        this.CommentEventGlobal = entities.CommentEventGlobal;
        this.allEntities.push(this.CommentEventGlobal);
    }
}
