// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
import { FEntity } from 'foundation-orm/FEntity';
import { FEntityIndex } from 'foundation-orm/FEntityIndex';
import { FNamespace } from 'foundation-orm/FNamespace';
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
import { FConnection } from 'foundation-orm/FConnection';

export interface OnlineShape {
    lastSeen: number;
}

export class Online extends FEntity {
    get uid() { return this._value.uid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
}

export class OnlineFactory extends FEntityFactory<Online> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'online'),
            { enableVersioning: false, enableTimestamps: false },
            []
        );
    }
    async findById(uid: number) {
        return await this._findById([uid]);
    }
    async create(uid: number, shape: OnlineShape) {
        return await this._create([uid], { uid, ...shape });
    }
    watch(uid: number, cb: () => void) {
        return this._watch([uid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Online(this.connection, this.namespace, [value.uid], value, this.options, isNew, this.indexes);
    }
}
export interface PresenceShape {
    lastSeen: number;
    lastSeenTimeout: number;
    platform: string;
}

export class Presence extends FEntity {
    get uid() { return this._value.uid; }
    get tid() { return this._value.tid; }
    get lastSeen(): number {
        return this._value.lastSeen;
    }
    set lastSeen(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeen) { return; }
        this._value.lastSeen = value;
        this.markDirty();
    }
    get lastSeenTimeout(): number {
        return this._value.lastSeenTimeout;
    }
    set lastSeenTimeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.lastSeenTimeout) { return; }
        this._value.lastSeenTimeout = value;
        this.markDirty();
    }
    get platform(): string {
        return this._value.platform;
    }
    set platform(value: string) {
        this._checkIsWritable();
        if (value === this._value.platform) { return; }
        this._value.platform = value;
        this.markDirty();
    }
}

export class PresenceFactory extends FEntityFactory<Presence> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'presence'),
            { enableVersioning: false, enableTimestamps: false },
            []
        );
    }
    async findById(uid: number, tid: string) {
        return await this._findById([uid, tid]);
    }
    async create(uid: number, tid: string, shape: PresenceShape) {
        return await this._create([uid, tid], { uid, tid, ...shape });
    }
    watch(uid: number, tid: string, cb: () => void) {
        return this._watch([uid, tid], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Presence(this.connection, this.namespace, [value.uid, value.tid], value, this.options, isNew, this.indexes);
    }
}
export interface CounterShape {
    value: number;
}

export class Counter extends FEntity {
    get name() { return this._value.name; }
    get value(): number {
        return this._value.value;
    }
    set value(value: number) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class CounterFactory extends FEntityFactory<Counter> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'counter'),
            { enableVersioning: false, enableTimestamps: false },
            []
        );
    }
    async findById(name: string) {
        return await this._findById([name]);
    }
    async create(name: string, shape: CounterShape) {
        return await this._create([name], { name, ...shape });
    }
    watch(name: string, cb: () => void) {
        return this._watch([name], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Counter(this.connection, this.namespace, [value.name], value, this.options, isNew, this.indexes);
    }
}
export interface AuthTokenShape {
    salt: string;
    uid: number;
    lastIp: string;
}

export class AuthToken extends FEntity {
    get uuid() { return this._value.uuid; }
    get salt(): string {
        return this._value.salt;
    }
    set salt(value: string) {
        this._checkIsWritable();
        if (value === this._value.salt) { return; }
        this._value.salt = value;
        this.markDirty();
    }
    get uid(): number {
        return this._value.uid;
    }
    set uid(value: number) {
        this._checkIsWritable();
        if (value === this._value.uid) { return; }
        this._value.uid = value;
        this.markDirty();
    }
    get lastIp(): string {
        return this._value.lastIp;
    }
    set lastIp(value: string) {
        this._checkIsWritable();
        if (value === this._value.lastIp) { return; }
        this._value.lastIp = value;
        this.markDirty();
    }
}

export class AuthTokenFactory extends FEntityFactory<AuthToken> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'authToken'),
            { enableVersioning: true, enableTimestamps: true },
            [new FEntityIndex('salt', ['salt'], true)]
        );
    }
    async findById(uuid: string) {
        return await this._findById([uuid]);
    }
    async create(uuid: string, shape: AuthTokenShape) {
        return await this._create([uuid], { uuid, ...shape });
    }
    watch(uuid: string, cb: () => void) {
        return this._watch([uuid], cb);
    }
    async findFromSalt(salt: string) {
        return await this._findById(['__indexes', 'salt', salt]);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new AuthToken(this.connection, this.namespace, [value.uuid], value, this.options, isNew, this.indexes);
    }
}
export interface ServiceCacheShape {
    value: string;
}

export class ServiceCache extends FEntity {
    get service() { return this._value.service; }
    get key() { return this._value.key; }
    get value(): string {
        return this._value.value;
    }
    set value(value: string) {
        this._checkIsWritable();
        if (value === this._value.value) { return; }
        this._value.value = value;
        this.markDirty();
    }
}

export class ServiceCacheFactory extends FEntityFactory<ServiceCache> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'serviceCache'),
            { enableVersioning: true, enableTimestamps: true },
            []
        );
    }
    async findById(service: string, key: string) {
        return await this._findById([service, key]);
    }
    async create(service: string, key: string, shape: ServiceCacheShape) {
        return await this._create([service, key], { service, key, ...shape });
    }
    watch(service: string, key: string, cb: () => void) {
        return this._watch([service, key], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new ServiceCache(this.connection, this.namespace, [value.service, value.key], value, this.options, isNew, this.indexes);
    }
}
export interface LockShape {
    seed: string;
    timeout: number;
    version: number;
    minVersion: number;
}

export class Lock extends FEntity {
    get key() { return this._value.key; }
    get seed(): string {
        return this._value.seed;
    }
    set seed(value: string) {
        this._checkIsWritable();
        if (value === this._value.seed) { return; }
        this._value.seed = value;
        this.markDirty();
    }
    get timeout(): number {
        return this._value.timeout;
    }
    set timeout(value: number) {
        this._checkIsWritable();
        if (value === this._value.timeout) { return; }
        this._value.timeout = value;
        this.markDirty();
    }
    get version(): number {
        return this._value.version;
    }
    set version(value: number) {
        this._checkIsWritable();
        if (value === this._value.version) { return; }
        this._value.version = value;
        this.markDirty();
    }
    get minVersion(): number {
        return this._value.minVersion;
    }
    set minVersion(value: number) {
        this._checkIsWritable();
        if (value === this._value.minVersion) { return; }
        this._value.minVersion = value;
        this.markDirty();
    }
}

export class LockFactory extends FEntityFactory<Lock> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'lock'),
            { enableVersioning: false, enableTimestamps: false },
            []
        );
    }
    async findById(key: string) {
        return await this._findById([key]);
    }
    async create(key: string, shape: LockShape) {
        return await this._create([key], { key, ...shape });
    }
    watch(key: string, cb: () => void) {
        return this._watch([key], cb);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Lock(this.connection, this.namespace, [value.key], value, this.options, isNew, this.indexes);
    }
}
export interface TaskShape {
    arguments: any;
    result?: any;
    taskStatus: 'pending' | 'executing' | 'failing' | 'failed' | 'completed';
    taskFailureCount?: number;
    taskFailureTime?: number;
    taskLockSeed?: string;
    taskLockTimeout?: number;
    taskFailureMessage?: string;
}

export class Task extends FEntity {
    get taskType() { return this._value.taskType; }
    get uid() { return this._value.uid; }
    get arguments(): any {
        return this._value.arguments;
    }
    set arguments(value: any) {
        this._checkIsWritable();
        if (value === this._value.arguments) { return; }
        this._value.arguments = value;
        this.markDirty();
    }
    get result(): any | null {
        let res = this._value.result;
        if (res) { return res; }
        return null;
    }
    set result(value: any | null) {
        this._checkIsWritable();
        if (value === this._value.result) { return; }
        this._value.result = value;
        this.markDirty();
    }
    get taskStatus(): 'pending' | 'executing' | 'failing' | 'failed' | 'completed' {
        return this._value.taskStatus;
    }
    set taskStatus(value: 'pending' | 'executing' | 'failing' | 'failed' | 'completed') {
        this._checkIsWritable();
        if (value === this._value.taskStatus) { return; }
        this._value.taskStatus = value;
        this.markDirty();
    }
    get taskFailureCount(): number | null {
        let res = this._value.taskFailureCount;
        if (res) { return res; }
        return null;
    }
    set taskFailureCount(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureCount) { return; }
        this._value.taskFailureCount = value;
        this.markDirty();
    }
    get taskFailureTime(): number | null {
        let res = this._value.taskFailureTime;
        if (res) { return res; }
        return null;
    }
    set taskFailureTime(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureTime) { return; }
        this._value.taskFailureTime = value;
        this.markDirty();
    }
    get taskLockSeed(): string | null {
        let res = this._value.taskLockSeed;
        if (res) { return res; }
        return null;
    }
    set taskLockSeed(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockSeed) { return; }
        this._value.taskLockSeed = value;
        this.markDirty();
    }
    get taskLockTimeout(): number | null {
        let res = this._value.taskLockTimeout;
        if (res) { return res; }
        return null;
    }
    set taskLockTimeout(value: number | null) {
        this._checkIsWritable();
        if (value === this._value.taskLockTimeout) { return; }
        this._value.taskLockTimeout = value;
        this.markDirty();
    }
    get taskFailureMessage(): string | null {
        let res = this._value.taskFailureMessage;
        if (res) { return res; }
        return null;
    }
    set taskFailureMessage(value: string | null) {
        this._checkIsWritable();
        if (value === this._value.taskFailureMessage) { return; }
        this._value.taskFailureMessage = value;
        this.markDirty();
    }
}

export class TaskFactory extends FEntityFactory<Task> {
    constructor(connection: FConnection) {
        super(connection,
            new FNamespace('entity', 'task'),
            { enableVersioning: true, enableTimestamps: true },
            [new FEntityIndex('pending', ['taskType', 'createdAt'], false, (src) => src.taskStatus === 'pending'), new FEntityIndex('executing', ['taskLockTimeout'], false, (src) => src.taskStatus === 'executing'), new FEntityIndex('failing', ['taskFailureTime'], false, (src) => src.taskStatus === 'failing')]
        );
    }
    async findById(taskType: string, uid: string) {
        return await this._findById([taskType, uid]);
    }
    async create(taskType: string, uid: string, shape: TaskShape) {
        return await this._create([taskType, uid], { taskType, uid, ...shape });
    }
    watch(taskType: string, uid: string, cb: () => void) {
        return this._watch([taskType, uid], cb);
    }
    async rangeFromPending(taskType: string, limit: number) {
        return await this._findRange(['__indexes', 'pending', taskType], limit);
    }
    async rangeFromExecuting(limit: number) {
        return await this._findRange(['__indexes', 'executing'], limit);
    }
    async rangeFromFailing(limit: number) {
        return await this._findRange(['__indexes', 'failing'], limit);
    }
    protected _createEntity(value: any, isNew: boolean) {
        return new Task(this.connection, this.namespace, [value.taskType, value.uid], value, this.options, isNew, this.indexes);
    }
}

export class AllEntities {
    Online: OnlineFactory;
    Presence: PresenceFactory;
    Counter: CounterFactory;
    AuthToken: AuthTokenFactory;
    ServiceCache: ServiceCacheFactory;
    Lock: LockFactory;
    Task: TaskFactory;

    constructor(connection: FConnection) {
        this.Online = new OnlineFactory(connection);
        this.Presence = new PresenceFactory(connection);
        this.Counter = new CounterFactory(connection);
        this.AuthToken = new AuthTokenFactory(connection);
        this.ServiceCache = new ServiceCacheFactory(connection);
        this.Lock = new LockFactory(connection);
        this.Task = new TaskFactory(connection);
    }
}
