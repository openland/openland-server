// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { EntitiesBase } from 'foundation-orm/EntitiesBase';
// @ts-ignore
import { Subspace } from '@openland/foundationdb';
// @ts-ignore
import { FEntity, FEntityOptions } from 'foundation-orm/FEntity';
// @ts-ignore
import { FEntitySchema } from 'foundation-orm/FEntitySchema';
// @ts-ignore
import { FEntityIndex } from 'foundation-orm/FEntityIndex';
// @ts-ignore
import { FEntityFactory } from 'foundation-orm/FEntityFactory';
// @ts-ignore
import { FAtomicIntegerFactory } from 'foundation-orm/FAtomicIntegerFactory';
// @ts-ignore
import { FAtomicBooleanFactory } from 'foundation-orm/FAtomicBooleanFactory';
// @ts-ignore
import { FDirectory } from 'foundation-orm/FDirectory';
// @ts-ignore
import { FConnection } from 'foundation-orm/FConnection';
// @ts-ignore
import { validators } from 'foundation-orm/utils/validators';
// @ts-ignore
import { EntityLayer } from 'foundation-orm/EntityLayer';
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { json, jField, jNumber, jString, jBool, jVec, jEnum, jEnumString } from 'openland-utils/jsonSchema';

export interface SimpleEntityShape {
    data: string;
}

export class SimpleEntity extends FEntity {
    readonly entityName: 'SimpleEntity' = 'SimpleEntity';
    get id(): number { return this._value.id; }
    get data(): string {
        return this._value.data;
    }
    set data(value: string) {
        this._checkIsWritable();
        if (value === this._value.data) { return; }
        this._value.data = value;
        this.markDirty();
    }
}

export class SimpleEntityFactory extends FEntityFactory<SimpleEntity> {
    static schema: FEntitySchema = {
        name: 'SimpleEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('simpleEntity');
        let config = { enableVersioning: false, enableTimestamps: false, validator: SimpleEntityFactory.validate, hasLiveStreams: false };
        return new SimpleEntityFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data', src.data);
        validators.isString('data', src.data);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('SimpleEntity', 'simpleEntity', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: SimpleEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: SimpleEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new SimpleEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'SimpleEntity');
    }
}
export interface VersionedEntityShape {
    data: string;
}

export class VersionedEntity extends FEntity {
    readonly entityName: 'VersionedEntity' = 'VersionedEntity';
    get id(): number { return this._value.id; }
    get data(): string {
        return this._value.data;
    }
    set data(value: string) {
        this._checkIsWritable();
        if (value === this._value.data) { return; }
        this._value.data = value;
        this.markDirty();
    }
}

export class VersionedEntityFactory extends FEntityFactory<VersionedEntity> {
    static schema: FEntitySchema = {
        name: 'VersionedEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('versionedEntity');
        let config = { enableVersioning: true, enableTimestamps: false, validator: VersionedEntityFactory.validate, hasLiveStreams: false };
        return new VersionedEntityFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data', src.data);
        validators.isString('data', src.data);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('VersionedEntity', 'versionedEntity', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: VersionedEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: VersionedEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new VersionedEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'VersionedEntity');
    }
}
export interface TimestampedEntityShape {
    data: string;
}

export class TimestampedEntity extends FEntity {
    readonly entityName: 'TimestampedEntity' = 'TimestampedEntity';
    get id(): number { return this._value.id; }
    get data(): string {
        return this._value.data;
    }
    set data(value: string) {
        this._checkIsWritable();
        if (value === this._value.data) { return; }
        this._value.data = value;
        this.markDirty();
    }
}

export class TimestampedEntityFactory extends FEntityFactory<TimestampedEntity> {
    static schema: FEntitySchema = {
        name: 'TimestampedEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data', type: 'string' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('timestampedEntity');
        let config = { enableVersioning: false, enableTimestamps: true, validator: TimestampedEntityFactory.validate, hasLiveStreams: false };
        return new TimestampedEntityFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data', src.data);
        validators.isString('data', src.data);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('TimestampedEntity', 'timestampedEntity', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: TimestampedEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: TimestampedEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new TimestampedEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'TimestampedEntity');
    }
}
export interface IndexedEntityShape {
    data1: string;
    data2: string;
    data3: string;
}

export class IndexedEntity extends FEntity {
    readonly entityName: 'IndexedEntity' = 'IndexedEntity';
    get id(): number { return this._value.id; }
    get data1(): string {
        return this._value.data1;
    }
    set data1(value: string) {
        this._checkIsWritable();
        if (value === this._value.data1) { return; }
        this._value.data1 = value;
        this.markDirty();
    }
    get data2(): string {
        return this._value.data2;
    }
    set data2(value: string) {
        this._checkIsWritable();
        if (value === this._value.data2) { return; }
        this._value.data2 = value;
        this.markDirty();
    }
    get data3(): string {
        return this._value.data3;
    }
    set data3(value: string) {
        this._checkIsWritable();
        if (value === this._value.data3) { return; }
        this._value.data3 = value;
        this.markDirty();
    }
}

export class IndexedEntityFactory extends FEntityFactory<IndexedEntity> {
    static schema: FEntitySchema = {
        name: 'IndexedEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data1', type: 'string' },
            { name: 'data2', type: 'string' },
            { name: 'data3', type: 'string' },
        ],
        indexes: [
            { name: 'default', type: 'unique', fields: ['data1', 'data2', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('indexedEntity');
        let config = { enableVersioning: false, enableTimestamps: false, validator: IndexedEntityFactory.validate, hasLiveStreams: true };
        let indexDefault = new FEntityIndex(await layer.resolveEntityIndexDirectory('indexedEntity', 'default'), 'default', ['data1', 'data2', 'id'], true);
        let indexes = {
            default: indexDefault,
        };
        return new IndexedEntityFactory(layer, directory, config, indexes);
    }

    readonly indexDefault: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data1', src.data1);
        validators.isString('data1', src.data1);
        validators.notNull('data2', src.data2);
        validators.isString('data2', src.data2);
        validators.notNull('data3', src.data3);
        validators.isString('data3', src.data3);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { default: FEntityIndex }) {
        super('IndexedEntity', 'indexedEntity', config, [indexes.default], layer, directory);
        this.indexDefault = indexes.default;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: IndexedEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: IndexedEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromDefault(ctx: Context, data1: string, data2: string, id: number) {
        return await this._findFromIndex(ctx, this.indexDefault.directory, [data1, data2, id]);
    }
    async allFromDefaultAfter(ctx: Context, data1: string, data2: string, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexDefault.directory, [data1, data2], after);
    }
    async rangeFromDefaultAfter(ctx: Context, data1: string, data2: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexDefault.directory, [data1, data2], after, limit, reversed);
    }
    async rangeFromDefault(ctx: Context, data1: string, data2: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexDefault.directory, [data1, data2], limit, reversed);
    }
    async rangeFromDefaultWithCursor(ctx: Context, data1: string, data2: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexDefault.directory, [data1, data2], limit, after, reversed);
    }
    async allFromDefault(ctx: Context, data1: string, data2: string) {
        return await this._findAll(ctx, this.indexDefault.directory, [data1, data2]);
    }
    createDefaultStream(data1: string, data2: string, limit: number, after?: string) {
        return this._createStream(this.indexDefault.directory, [data1, data2], limit, after); 
    }
    createDefaultLiveStream(ctx: Context, data1: string, data2: string, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexDefault.directory, [data1, data2], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new IndexedEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'IndexedEntity');
    }
}
export interface IndexedRangeEntityShape {
    data1: string;
    data2: string;
    data3: string;
}

export class IndexedRangeEntity extends FEntity {
    readonly entityName: 'IndexedRangeEntity' = 'IndexedRangeEntity';
    get id(): number { return this._value.id; }
    get data1(): string {
        return this._value.data1;
    }
    set data1(value: string) {
        this._checkIsWritable();
        if (value === this._value.data1) { return; }
        this._value.data1 = value;
        this.markDirty();
    }
    get data2(): string {
        return this._value.data2;
    }
    set data2(value: string) {
        this._checkIsWritable();
        if (value === this._value.data2) { return; }
        this._value.data2 = value;
        this.markDirty();
    }
    get data3(): string {
        return this._value.data3;
    }
    set data3(value: string) {
        this._checkIsWritable();
        if (value === this._value.data3) { return; }
        this._value.data3 = value;
        this.markDirty();
    }
}

export class IndexedRangeEntityFactory extends FEntityFactory<IndexedRangeEntity> {
    static schema: FEntitySchema = {
        name: 'IndexedRangeEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data1', type: 'string' },
            { name: 'data2', type: 'string' },
            { name: 'data3', type: 'string' },
        ],
        indexes: [
            { name: 'default', type: 'range', fields: ['data1', 'data2'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('indexedRangeEntity');
        let config = { enableVersioning: false, enableTimestamps: false, validator: IndexedRangeEntityFactory.validate, hasLiveStreams: true };
        let indexDefault = new FEntityIndex(await layer.resolveEntityIndexDirectory('indexedRangeEntity', 'default'), 'default', ['data1', 'data2'], false);
        let indexes = {
            default: indexDefault,
        };
        return new IndexedRangeEntityFactory(layer, directory, config, indexes);
    }

    readonly indexDefault: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data1', src.data1);
        validators.isString('data1', src.data1);
        validators.notNull('data2', src.data2);
        validators.isString('data2', src.data2);
        validators.notNull('data3', src.data3);
        validators.isString('data3', src.data3);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { default: FEntityIndex }) {
        super('IndexedRangeEntity', 'indexedRangeEntity', config, [indexes.default], layer, directory);
        this.indexDefault = indexes.default;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: IndexedRangeEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: IndexedRangeEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromDefaultAfter(ctx: Context, data1: string, after: string) {
        return await this._findRangeAllAfter(ctx, this.indexDefault.directory, [data1], after);
    }
    async rangeFromDefaultAfter(ctx: Context, data1: string, after: string, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexDefault.directory, [data1], after, limit, reversed);
    }
    async rangeFromDefault(ctx: Context, data1: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexDefault.directory, [data1], limit, reversed);
    }
    async rangeFromDefaultWithCursor(ctx: Context, data1: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexDefault.directory, [data1], limit, after, reversed);
    }
    async allFromDefault(ctx: Context, data1: string) {
        return await this._findAll(ctx, this.indexDefault.directory, [data1]);
    }
    createDefaultStream(data1: string, limit: number, after?: string) {
        return this._createStream(this.indexDefault.directory, [data1], limit, after); 
    }
    createDefaultLiveStream(ctx: Context, data1: string, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexDefault.directory, [data1], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new IndexedRangeEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'IndexedRangeEntity');
    }
}
export interface IndexedPartialEntityShape {
    data1: string;
    data2: string;
    data3: string;
}

export class IndexedPartialEntity extends FEntity {
    readonly entityName: 'IndexedPartialEntity' = 'IndexedPartialEntity';
    get id(): number { return this._value.id; }
    get data1(): string {
        return this._value.data1;
    }
    set data1(value: string) {
        this._checkIsWritable();
        if (value === this._value.data1) { return; }
        this._value.data1 = value;
        this.markDirty();
    }
    get data2(): string {
        return this._value.data2;
    }
    set data2(value: string) {
        this._checkIsWritable();
        if (value === this._value.data2) { return; }
        this._value.data2 = value;
        this.markDirty();
    }
    get data3(): string {
        return this._value.data3;
    }
    set data3(value: string) {
        this._checkIsWritable();
        if (value === this._value.data3) { return; }
        this._value.data3 = value;
        this.markDirty();
    }
}

export class IndexedPartialEntityFactory extends FEntityFactory<IndexedPartialEntity> {
    static schema: FEntitySchema = {
        name: 'IndexedPartialEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'data1', type: 'string' },
            { name: 'data2', type: 'string' },
            { name: 'data3', type: 'string' },
        ],
        indexes: [
            { name: 'default', type: 'unique', fields: ['data1', 'data2', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('indexedPartialEntity');
        let config = { enableVersioning: false, enableTimestamps: false, validator: IndexedPartialEntityFactory.validate, hasLiveStreams: true };
        let indexDefault = new FEntityIndex(await layer.resolveEntityIndexDirectory('indexedPartialEntity', 'default'), 'default', ['data1', 'data2', 'id'], true, (src) => src.data1 === 'hello');
        let indexes = {
            default: indexDefault,
        };
        return new IndexedPartialEntityFactory(layer, directory, config, indexes);
    }

    readonly indexDefault: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('data1', src.data1);
        validators.isString('data1', src.data1);
        validators.notNull('data2', src.data2);
        validators.isString('data2', src.data2);
        validators.notNull('data3', src.data3);
        validators.isString('data3', src.data3);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { default: FEntityIndex }) {
        super('IndexedPartialEntity', 'indexedPartialEntity', config, [indexes.default], layer, directory);
        this.indexDefault = indexes.default;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: IndexedPartialEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: IndexedPartialEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async findFromDefault(ctx: Context, data1: string, data2: string, id: number) {
        return await this._findFromIndex(ctx, this.indexDefault.directory, [data1, data2, id]);
    }
    async allFromDefaultAfter(ctx: Context, data1: string, data2: string, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexDefault.directory, [data1, data2], after);
    }
    async rangeFromDefaultAfter(ctx: Context, data1: string, data2: string, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexDefault.directory, [data1, data2], after, limit, reversed);
    }
    async rangeFromDefault(ctx: Context, data1: string, data2: string, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexDefault.directory, [data1, data2], limit, reversed);
    }
    async rangeFromDefaultWithCursor(ctx: Context, data1: string, data2: string, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexDefault.directory, [data1, data2], limit, after, reversed);
    }
    async allFromDefault(ctx: Context, data1: string, data2: string) {
        return await this._findAll(ctx, this.indexDefault.directory, [data1, data2]);
    }
    createDefaultStream(data1: string, data2: string, limit: number, after?: string) {
        return this._createStream(this.indexDefault.directory, [data1, data2], limit, after); 
    }
    createDefaultLiveStream(ctx: Context, data1: string, data2: string, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexDefault.directory, [data1, data2], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new IndexedPartialEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'IndexedPartialEntity');
    }
}
export interface NullableEntityShape {
    flag?: boolean| null;
}

export class NullableEntity extends FEntity {
    readonly entityName: 'NullableEntity' = 'NullableEntity';
    get id(): number { return this._value.id; }
    get flag(): boolean | null {
        let res = this._value.flag;
        if (res !== null && res !== undefined) { return res; }
        return null;
    }
    set flag(value: boolean | null) {
        this._checkIsWritable();
        if (value === this._value.flag) { return; }
        this._value.flag = value;
        this.markDirty();
    }
}

export class NullableEntityFactory extends FEntityFactory<NullableEntity> {
    static schema: FEntitySchema = {
        name: 'NullableEntity',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'flag', type: 'boolean' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('nullableEntity');
        let config = { enableVersioning: false, enableTimestamps: false, validator: NullableEntityFactory.validate, hasLiveStreams: false };
        return new NullableEntityFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.isBoolean('flag', src.flag);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('NullableEntity', 'nullableEntity', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: NullableEntityShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: NullableEntityShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new NullableEntity(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'NullableEntity');
    }
}
export interface RangeTestShape {
    key: number;
}

export class RangeTest extends FEntity {
    readonly entityName: 'RangeTest' = 'RangeTest';
    get id(): number { return this._value.id; }
    get key(): number {
        return this._value.key;
    }
    set key(value: number) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
}

export class RangeTestFactory extends FEntityFactory<RangeTest> {
    static schema: FEntitySchema = {
        name: 'RangeTest',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'number' },
        ],
        indexes: [
            { name: 'default', type: 'range', fields: ['key', 'id'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('rangeTest');
        let config = { enableVersioning: false, enableTimestamps: false, validator: RangeTestFactory.validate, hasLiveStreams: true };
        let indexDefault = new FEntityIndex(await layer.resolveEntityIndexDirectory('rangeTest', 'default'), 'default', ['key', 'id'], false);
        let indexes = {
            default: indexDefault,
        };
        return new RangeTestFactory(layer, directory, config, indexes);
    }

    readonly indexDefault: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('key', src.key);
        validators.isNumber('key', src.key);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { default: FEntityIndex }) {
        super('RangeTest', 'rangeTest', config, [indexes.default], layer, directory);
        this.indexDefault = indexes.default;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: RangeTestShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: RangeTestShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromDefaultAfter(ctx: Context, key: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexDefault.directory, [key], after);
    }
    async rangeFromDefaultAfter(ctx: Context, key: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexDefault.directory, [key], after, limit, reversed);
    }
    async rangeFromDefault(ctx: Context, key: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexDefault.directory, [key], limit, reversed);
    }
    async rangeFromDefaultWithCursor(ctx: Context, key: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexDefault.directory, [key], limit, after, reversed);
    }
    async allFromDefault(ctx: Context, key: number) {
        return await this._findAll(ctx, this.indexDefault.directory, [key]);
    }
    createDefaultStream(key: number, limit: number, after?: string) {
        return this._createStream(this.indexDefault.directory, [key], limit, after); 
    }
    createDefaultLiveStream(ctx: Context, key: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexDefault.directory, [key], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new RangeTest(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'RangeTest');
    }
}
export interface ComplexRangeTestShape {
    key: string;
    subId1: number;
    subId2: number;
}

export class ComplexRangeTest extends FEntity {
    readonly entityName: 'ComplexRangeTest' = 'ComplexRangeTest';
    get id(): number { return this._value.id; }
    get key(): string {
        return this._value.key;
    }
    set key(value: string) {
        this._checkIsWritable();
        if (value === this._value.key) { return; }
        this._value.key = value;
        this.markDirty();
    }
    get subId1(): number {
        return this._value.subId1;
    }
    set subId1(value: number) {
        this._checkIsWritable();
        if (value === this._value.subId1) { return; }
        this._value.subId1 = value;
        this.markDirty();
    }
    get subId2(): number {
        return this._value.subId2;
    }
    set subId2(value: number) {
        this._checkIsWritable();
        if (value === this._value.subId2) { return; }
        this._value.subId2 = value;
        this.markDirty();
    }
}

export class ComplexRangeTestFactory extends FEntityFactory<ComplexRangeTest> {
    static schema: FEntitySchema = {
        name: 'ComplexRangeTest',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'key', type: 'string' },
            { name: 'subId1', type: 'number' },
            { name: 'subId2', type: 'number' },
        ],
        indexes: [
            { name: 'nonUnique', type: 'range', fields: ['subId1', 'subId2'] },
            { name: 'unique', type: 'unique', fields: ['subId1', 'subId2'] },
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('complexRangeTest');
        let config = { enableVersioning: false, enableTimestamps: false, validator: ComplexRangeTestFactory.validate, hasLiveStreams: true };
        let indexNonUnique = new FEntityIndex(await layer.resolveEntityIndexDirectory('complexRangeTest', 'nonUnique'), 'nonUnique', ['subId1', 'subId2'], false);
        let indexUnique = new FEntityIndex(await layer.resolveEntityIndexDirectory('complexRangeTest', 'unique'), 'unique', ['subId1', 'subId2'], true);
        let indexes = {
            nonUnique: indexNonUnique,
            unique: indexUnique,
        };
        return new ComplexRangeTestFactory(layer, directory, config, indexes);
    }

    readonly indexNonUnique: FEntityIndex;
    readonly indexUnique: FEntityIndex;

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('key', src.key);
        validators.isString('key', src.key);
        validators.notNull('subId1', src.subId1);
        validators.isNumber('subId1', src.subId1);
        validators.notNull('subId2', src.subId2);
        validators.isNumber('subId2', src.subId2);
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions, indexes: { nonUnique: FEntityIndex, unique: FEntityIndex }) {
        super('ComplexRangeTest', 'complexRangeTest', config, [indexes.nonUnique, indexes.unique], layer, directory);
        this.indexNonUnique = indexes.nonUnique;
        this.indexUnique = indexes.unique;
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: ComplexRangeTestShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: ComplexRangeTestShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    async allFromNonUniqueAfter(ctx: Context, subId1: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexNonUnique.directory, [subId1], after);
    }
    async rangeFromNonUniqueAfter(ctx: Context, subId1: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexNonUnique.directory, [subId1], after, limit, reversed);
    }
    async rangeFromNonUnique(ctx: Context, subId1: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexNonUnique.directory, [subId1], limit, reversed);
    }
    async rangeFromNonUniqueWithCursor(ctx: Context, subId1: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexNonUnique.directory, [subId1], limit, after, reversed);
    }
    async allFromNonUnique(ctx: Context, subId1: number) {
        return await this._findAll(ctx, this.indexNonUnique.directory, [subId1]);
    }
    createNonUniqueStream(subId1: number, limit: number, after?: string) {
        return this._createStream(this.indexNonUnique.directory, [subId1], limit, after); 
    }
    createNonUniqueLiveStream(ctx: Context, subId1: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexNonUnique.directory, [subId1], limit, after); 
    }
    async findFromUnique(ctx: Context, subId1: number, subId2: number) {
        return await this._findFromIndex(ctx, this.indexUnique.directory, [subId1, subId2]);
    }
    async allFromUniqueAfter(ctx: Context, subId1: number, after: number) {
        return await this._findRangeAllAfter(ctx, this.indexUnique.directory, [subId1], after);
    }
    async rangeFromUniqueAfter(ctx: Context, subId1: number, after: number, limit: number, reversed?: boolean) {
        return await this._findRangeAfter(ctx, this.indexUnique.directory, [subId1], after, limit, reversed);
    }
    async rangeFromUnique(ctx: Context, subId1: number, limit: number, reversed?: boolean) {
        return await this._findRange(ctx, this.indexUnique.directory, [subId1], limit, reversed);
    }
    async rangeFromUniqueWithCursor(ctx: Context, subId1: number, limit: number, after?: string, reversed?: boolean) {
        return await this._findRangeWithCursor(ctx, this.indexUnique.directory, [subId1], limit, after, reversed);
    }
    async allFromUnique(ctx: Context, subId1: number) {
        return await this._findAll(ctx, this.indexUnique.directory, [subId1]);
    }
    createUniqueStream(subId1: number, limit: number, after?: string) {
        return this._createStream(this.indexUnique.directory, [subId1], limit, after); 
    }
    createUniqueLiveStream(ctx: Context, subId1: number, limit: number, after?: string) {
        return this._createLiveStream(ctx, this.indexUnique.directory, [subId1], limit, after); 
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new ComplexRangeTest(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'ComplexRangeTest');
    }
}
export interface JsonTestShape {
    test: { type: 'link', offset: number, length: number, url: string, };
}

export class JsonTest extends FEntity {
    readonly entityName: 'JsonTest' = 'JsonTest';
    get id(): number { return this._value.id; }
    get test(): { type: 'link', offset: number, length: number, url: string, } {
        return this._value.test;
    }
    set test(value: { type: 'link', offset: number, length: number, url: string, }) {
        this._checkIsWritable();
        if (value === this._value.test) { return; }
        this._value.test = value;
        this.markDirty();
    }
}

export class JsonTestFactory extends FEntityFactory<JsonTest> {
    static schema: FEntitySchema = {
        name: 'JsonTest',
        editable: false,
        primaryKeys: [
            { name: 'id', type: 'number' },
        ],
        fields: [
            { name: 'test', type: 'json' },
        ],
        indexes: [
        ],
    };

    static async create(layer: EntityLayer) {
        let directory = await layer.resolveEntityDirectory('jsonTest');
        let config = { enableVersioning: false, enableTimestamps: false, validator: JsonTestFactory.validate, hasLiveStreams: false };
        return new JsonTestFactory(layer, directory, config);
    }

    private static validate(src: any) {
        validators.notNull('id', src.id);
        validators.isNumber('id', src.id);
        validators.notNull('test', src.test);
        validators.isJson('test', src.test, json(() => {
            jField('type', jString('link'));
            jField('offset', jNumber());
            jField('length', jNumber());
            jField('url', jString());
        }));
    }

    constructor(layer: EntityLayer, directory: Subspace, config: FEntityOptions) {
        super('JsonTest', 'jsonTest', config, [], layer, directory);
    }
    extractId(rawId: any[]) {
        if (rawId.length !== 1) { throw Error('Invalid key length!'); }
        return { 'id': rawId[0] };
    }
    async findById(ctx: Context, id: number) {
        return await this._findById(ctx, [id]);
    }
    async create(ctx: Context, id: number, shape: JsonTestShape) {
        return await this._create(ctx, [id], { id, ...shape });
    }
    async create_UNSAFE(ctx: Context, id: number, shape: JsonTestShape) {
        return await this._create_UNSAFE(ctx, [id], { id, ...shape });
    }
    watch(ctx: Context, id: number) {
        return this._watch(ctx, [id]);
    }
    protected _createEntity(ctx: Context, value: any, isNew: boolean) {
        return new JsonTest(ctx, this.layer, this.directory, [value.id], value, this.options, isNew, this.indexes, 'JsonTest');
    }
}
export class SampleAtomicFactory extends FAtomicIntegerFactory {
    static async create(layer: EntityLayer) {
        let directory = await layer.resolveAtomicDirectory('sampleAtomic');
        return new SampleAtomicFactory(layer, directory);
    }
    byId(id: string) {
        return this._findById([id]);
    }
    private constructor(layer: EntityLayer, subspace: Subspace) {
        super(layer, subspace);
    }
}
export class SampleAtomicBooleanFactory extends FAtomicBooleanFactory {
    static async create(layer: EntityLayer) {
        let directory = await layer.resolveAtomicDirectory('sampleAtomicBoolean');
        return new SampleAtomicBooleanFactory(layer, directory);
    }
    byId(id: string) {
        return this._findById([id]);
    }
    private constructor(layer: EntityLayer, subspace: Subspace) {
        super(layer, subspace);
    }
}

export interface AllEntities {
    readonly layer: EntityLayer;
    readonly allEntities: FEntityFactory<FEntity>[];
    readonly SimpleEntity: SimpleEntityFactory;
    readonly VersionedEntity: VersionedEntityFactory;
    readonly TimestampedEntity: TimestampedEntityFactory;
    readonly IndexedEntity: IndexedEntityFactory;
    readonly IndexedRangeEntity: IndexedRangeEntityFactory;
    readonly IndexedPartialEntity: IndexedPartialEntityFactory;
    readonly NullableEntity: NullableEntityFactory;
    readonly RangeTest: RangeTestFactory;
    readonly ComplexRangeTest: ComplexRangeTestFactory;
    readonly JsonTest: JsonTestFactory;
    readonly SampleAtomic: SampleAtomicFactory;
    readonly SampleAtomicBoolean: SampleAtomicBooleanFactory;
}
export class AllEntitiesDirect extends EntitiesBase implements AllEntities {
    static readonly schema: FEntitySchema[] = [
        SimpleEntityFactory.schema,
        VersionedEntityFactory.schema,
        TimestampedEntityFactory.schema,
        IndexedEntityFactory.schema,
        IndexedRangeEntityFactory.schema,
        IndexedPartialEntityFactory.schema,
        NullableEntityFactory.schema,
        RangeTestFactory.schema,
        ComplexRangeTestFactory.schema,
        JsonTestFactory.schema,
    ];

    static async create(layer: EntityLayer) {
        let allEntities: FEntityFactory<FEntity>[] = [];
        let SimpleEntityPromise = SimpleEntityFactory.create(layer);
        let VersionedEntityPromise = VersionedEntityFactory.create(layer);
        let TimestampedEntityPromise = TimestampedEntityFactory.create(layer);
        let IndexedEntityPromise = IndexedEntityFactory.create(layer);
        let IndexedRangeEntityPromise = IndexedRangeEntityFactory.create(layer);
        let IndexedPartialEntityPromise = IndexedPartialEntityFactory.create(layer);
        let NullableEntityPromise = NullableEntityFactory.create(layer);
        let RangeTestPromise = RangeTestFactory.create(layer);
        let ComplexRangeTestPromise = ComplexRangeTestFactory.create(layer);
        let JsonTestPromise = JsonTestFactory.create(layer);
        let SampleAtomicPromise = SampleAtomicFactory.create(layer);
        let SampleAtomicBooleanPromise = SampleAtomicBooleanFactory.create(layer);
        allEntities.push(await SimpleEntityPromise);
        allEntities.push(await VersionedEntityPromise);
        allEntities.push(await TimestampedEntityPromise);
        allEntities.push(await IndexedEntityPromise);
        allEntities.push(await IndexedRangeEntityPromise);
        allEntities.push(await IndexedPartialEntityPromise);
        allEntities.push(await NullableEntityPromise);
        allEntities.push(await RangeTestPromise);
        allEntities.push(await ComplexRangeTestPromise);
        allEntities.push(await JsonTestPromise);
        let entities = {
            layer, allEntities,
            SimpleEntity: await SimpleEntityPromise,
            VersionedEntity: await VersionedEntityPromise,
            TimestampedEntity: await TimestampedEntityPromise,
            IndexedEntity: await IndexedEntityPromise,
            IndexedRangeEntity: await IndexedRangeEntityPromise,
            IndexedPartialEntity: await IndexedPartialEntityPromise,
            NullableEntity: await NullableEntityPromise,
            RangeTest: await RangeTestPromise,
            ComplexRangeTest: await ComplexRangeTestPromise,
            JsonTest: await JsonTestPromise,
            SampleAtomic: await SampleAtomicPromise,
            SampleAtomicBoolean: await SampleAtomicBooleanPromise,
        };
        return new AllEntitiesDirect(entities);
    }

    readonly allEntities: FEntityFactory<FEntity>[] = [];
    readonly SimpleEntity: SimpleEntityFactory;
    readonly VersionedEntity: VersionedEntityFactory;
    readonly TimestampedEntity: TimestampedEntityFactory;
    readonly IndexedEntity: IndexedEntityFactory;
    readonly IndexedRangeEntity: IndexedRangeEntityFactory;
    readonly IndexedPartialEntity: IndexedPartialEntityFactory;
    readonly NullableEntity: NullableEntityFactory;
    readonly RangeTest: RangeTestFactory;
    readonly ComplexRangeTest: ComplexRangeTestFactory;
    readonly JsonTest: JsonTestFactory;
    readonly SampleAtomic: SampleAtomicFactory;
    readonly SampleAtomicBoolean: SampleAtomicBooleanFactory;

    private constructor(entities: AllEntities) {
        super(entities.layer);
        this.SimpleEntity = entities.SimpleEntity;
        this.allEntities.push(this.SimpleEntity);
        this.VersionedEntity = entities.VersionedEntity;
        this.allEntities.push(this.VersionedEntity);
        this.TimestampedEntity = entities.TimestampedEntity;
        this.allEntities.push(this.TimestampedEntity);
        this.IndexedEntity = entities.IndexedEntity;
        this.allEntities.push(this.IndexedEntity);
        this.IndexedRangeEntity = entities.IndexedRangeEntity;
        this.allEntities.push(this.IndexedRangeEntity);
        this.IndexedPartialEntity = entities.IndexedPartialEntity;
        this.allEntities.push(this.IndexedPartialEntity);
        this.NullableEntity = entities.NullableEntity;
        this.allEntities.push(this.NullableEntity);
        this.RangeTest = entities.RangeTest;
        this.allEntities.push(this.RangeTest);
        this.ComplexRangeTest = entities.ComplexRangeTest;
        this.allEntities.push(this.ComplexRangeTest);
        this.JsonTest = entities.JsonTest;
        this.allEntities.push(this.JsonTest);
        this.SampleAtomic = entities.SampleAtomic;
        this.SampleAtomicBoolean = entities.SampleAtomicBoolean;
    }
}
export class AllEntitiesProxy implements AllEntities {
    get layer(): EntityLayer {
        return this.resolver().layer;
    }
    get SimpleEntity(): SimpleEntityFactory {
        return this.resolver().SimpleEntity;
    }
    get VersionedEntity(): VersionedEntityFactory {
        return this.resolver().VersionedEntity;
    }
    get TimestampedEntity(): TimestampedEntityFactory {
        return this.resolver().TimestampedEntity;
    }
    get IndexedEntity(): IndexedEntityFactory {
        return this.resolver().IndexedEntity;
    }
    get IndexedRangeEntity(): IndexedRangeEntityFactory {
        return this.resolver().IndexedRangeEntity;
    }
    get IndexedPartialEntity(): IndexedPartialEntityFactory {
        return this.resolver().IndexedPartialEntity;
    }
    get NullableEntity(): NullableEntityFactory {
        return this.resolver().NullableEntity;
    }
    get RangeTest(): RangeTestFactory {
        return this.resolver().RangeTest;
    }
    get ComplexRangeTest(): ComplexRangeTestFactory {
        return this.resolver().ComplexRangeTest;
    }
    get JsonTest(): JsonTestFactory {
        return this.resolver().JsonTest;
    }
    get SampleAtomic(): SampleAtomicFactory {
        return this.resolver().SampleAtomic;
    }
    get SampleAtomicBoolean(): SampleAtomicBooleanFactory {
        return this.resolver().SampleAtomicBoolean;
    }
    get allEntities(): FEntityFactory<FEntity>[] {
        return this.resolver().allEntities;
    }
    private resolver: () => AllEntities;
    constructor(resolver: () => AllEntities) {
        this.resolver = resolver;
    }
}
