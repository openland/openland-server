#
# Super Accounting
#

enum SuperAccountState {
    PENDING,
    ACTIVATED,
    SUSPENDED
}

type SuperAccount {
    id: ID!
    orgId: ID!
    title: String!
    name: String!
    state: SuperAccountState!
    members: [User!]!
    features: [FeatureFlag!]!
    alphaPublished: Boolean!
    createdAt: String,
    createdBy: User,
}

extend type Query {
    superAccounts: [SuperAccount!]!
    superAccount(id: ID!, viaOrgId: Boolean): SuperAccount!
}

extend type Mutation {
    superAccountAdd(title: String!): SuperAccount!
    superAccountRename(id: ID!, title: String!): SuperAccount!
    superAccountActivate(id: ID!): SuperAccount!
    superAccountSuspend(id: ID!): SuperAccount!
    superAccountPend(id: ID!): SuperAccount!

    superAccountMemberAdd(id: ID!, userId: ID!): SuperAccount!
    superAccountMemberRemove(id: ID!, userId: ID!): SuperAccount!
}

#
# Super Admins
#

enum SuperAdminRole {
    SUPER_ADMIN,
    SOFTWARE_DEVELOPER,
    EDITOR
}

type SuperAdmin {
    user: User!
    role: SuperAdminRole!
    email: String
}

extend type Mutation {
    superAdminAdd(userId: ID!, role: SuperAdminRole!): String!
    superAdminRemove(userId: ID!): String!
}

extend type Query {
    superAdmins: [SuperAdmin!]!
}

#
# City Configurations
#

type SuperCity {
    id: ID!
    key: String!
    name: String!
    enabled: Boolean!
    blockSource: String
    blockSourceLayer: String
    parcelSource: String
    parcelSourceLayer: String
}

extend type Query {
    superCities: [SuperCity!]!
}

#
# Feature Flags
#

type FeatureFlag {
    id: ID!
    key: String!
    title: String!
}

extend type Query {
    featureFlags: [FeatureFlag!]!
}

extend type Mutation {
    featureFlagAdd(key: String!, title: String!): FeatureFlag!
    superAccountFeatureAdd(id: ID!, featureId: ID!): SuperAccount!
    superAccountFeatureRemove(id: ID!, featureId: ID!): SuperAccount!
}

#
# Reader States
#

type DebugReaderState {
    id: ID!
    title: String!
    remaining: Int!
}

type URLInfo {
    url: String!
    title: String
    description: String
    imageURL: String
}

# scalar TestType

scalar OrganizationID
scalar OrganizationAccountID
scalar OrganizationListingID
scalar InviteID
scalar InviteInfoID
scalar StateID
scalar CountyID
scalar CityID
scalar UserID
scalar ProfileID
scalar DealID
scalar BlockID
scalar SuperAccountID
scalar SuperCityID
scalar FeatureFlagID
scalar OpportunitiesID
scalar DebugReaderID
scalar FolderID
scalar FolderItemID
scalar TaskID
scalar ConversationID
scalar ConversationSettingsID
scalar ConversationMessageID
scalar NotificationCounterID
scalar UserEventID
scalar SettingsID
scalar WallEntityID


input TestInput {
    testStr: String! @stringNotEmpty  #@stringNotEmpty

    mda: ID! @userID
}

extend type Query {
    debugReaderStates: [DebugReaderState!]!

    debugURLInfo(url: String!): URLInfo!
    debugSerializeId(id: Int!, type: String): ID!
    debugImagePreview(uuid: String!): String

    # directives are executed in reverse-order
    debugTest(lol: ID! @userID, input: TestInput!): ID @userID # @withPermission(permission: "software-developer") @withAuth
}

#
# Subscriptions
#

extend type Mutation {
    debugSendWelcomeEmail: String!

    debugSendEmail(email: String!, text: String!): String!

    debugTestNotification: String
}